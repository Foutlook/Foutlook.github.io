<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Foutin</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-21T07:40:05.695Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Foutlook</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="http://yoursite.com/2019/01/20/ThreadLocal/"/>
    <id>http://yoursite.com/2019/01/20/ThreadLocal/</id>
    <published>2019-01-20T04:00:00.000Z</published>
    <updated>2019-01-21T07:40:05.695Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>成熟成熟</p></blockquote><hr><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ThreadLocal也是一种解决多线程并发无锁的方法。这里简单分析一下。以下内容仅仅是个人的记录。</p><hr><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="为什么用ThreadLocal"><a href="#为什么用ThreadLocal" class="headerlink" title="为什么用ThreadLocal"></a>为什么用ThreadLocal</h2><p><code>ThreadLocal</code> 提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同，而同一个线程在任何时候访问这个本地变量的结果都是一致的。当此线程结束生命周期时，所有的线程本地实例都会被 GC。<code>ThreadLocal</code> 相当于提供了一种线程隔离，将变量与线程相绑定。ThreadLocal 通常定义为 <code>private static</code> 类型。</p><p>假如让我们来实现一个变量与线程相绑定的功能，我们可以很容易地想到用<code>HashMap</code>来实现，Thread作为key，变量作为<code>value</code>。事实上，JDK 中确实使用了类似 Map 的结构存储变量，但不是像我们想的那样。下面我们来探究OpenJDK 1.8中ThreadLocal的实现。</p><p>从线程Thread的角度来看，每个线程内部都会持有一个对ThreadLocalMap实例的引用，ThreadLocalMap实例相当于线程的局部变量空间，存储着线程各自的数据，具体如下图：</p><h2 id="ThreadLocal源码"><a href="#ThreadLocal源码" class="headerlink" title="ThreadLocal源码"></a>ThreadLocal源码</h2><h3 id="ThreadLocal-1"><a href="#ThreadLocal-1" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal 通过 threadLocalHashCode 来标识每一个 ThreadLocal 的唯一性。threadLocalHashCode 通过 CAS 操作进行更新，每次 hash 操作的增量为 0x61c88647(为什么用这个数，可以自行查)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;T&gt; &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadLocals rely on per-thread linear-probe hash maps attached</span></span><br><span class="line"><span class="comment">     * to each thread (Thread.threadLocals and</span></span><br><span class="line"><span class="comment">     * inheritableThreadLocals).  The ThreadLocal objects act as keys,</span></span><br><span class="line"><span class="comment">     * searched via threadLocalHashCode.  This is a custom hash code</span></span><br><span class="line"><span class="comment">     * (useful only within ThreadLocalMaps) that eliminates collisions</span></span><br><span class="line"><span class="comment">     * in the common case where consecutively constructed ThreadLocals</span></span><br><span class="line"><span class="comment">     * are used by the same threads, while remaining well-behaved in</span></span><br><span class="line"><span class="comment">     * less common cases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> final <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next hash code to be given out. Updated atomically. Starts at</span></span><br><span class="line"><span class="comment">     * zero.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">        <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The difference between successively generated hash codes - turns</span></span><br><span class="line"><span class="comment">     * implicit sequential thread-local IDs into near-optimally spread</span></span><br><span class="line"><span class="comment">     * multiplicative hash values for power-of-two-sized tables.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the next hash code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>set 方法：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="literal">void</span> <span class="built_in">set</span>(T value) &#123;</span><br><span class="line">        <span class="keyword">Thread</span> t = <span class="keyword">Thread</span>.currentThread();</span><br><span class="line">        ThreadLocalMap <span class="built_in">map</span> = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span> != <span class="built_in">null</span>)</span><br><span class="line">            <span class="built_in">map</span>.<span class="built_in">set</span>(this, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到通过<code>Thread.currentThread()</code>方法获取了当前的线程引用，并传给了getMap(Thread)方法获取一个ThreadLocalMap的实例。我们继续跟进getMap(Thread)方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到getMap(Thread)方法直接返回Thread实例的成员变量threadLocals。它的定义在Thread内部，访问级别为package级别：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* ThreadLocal values pertaining <span class="keyword">to</span> this thread. This map <span class="keyword">is</span> maintained</span><br><span class="line">     * <span class="keyword">by</span> <span class="keyword">the</span> ThreadLocal <span class="built_in">class</span>. */</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure><p>到了这里，我们可以看出，每个Thread里面都有一个ThreadLocal.ThreadLocalMap成员变量，也就是说每个线程通过ThreadLocal.ThreadLocalMap与ThreadLocal相绑定，这样可以确保每个线程访问到的thread-local variable都是本线程的。</p><p>我们往下继续分析。获取了ThreadLocalMap实例以后，如果它不为空则调用<code>ThreadLocalMap.ThreadLocalMap#set</code>方法设值；若为空则调用ThreadLocal#createMap方法new一个ThreadLocalMap实例并赋给<code>Thread.threadLocals</code>。</p><p>ThreadLocal#createMap方法的源码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>ThreadLocalMap 是 ThreadLocal 的静态内部类，它的结构如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">         * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">         * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        static <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</span> </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            <span class="type">Object</span> value;</span><br><span class="line"></span><br><span class="line">            <span class="type">Entry</span>(<span class="type">ThreadLocal</span>&lt;?&gt; k, <span class="type">Object</span> v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The initial capacity -- MUST be a power of two.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> static <span class="keyword">final</span> int <span class="type">INITIAL_CAPACITY</span> = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The table, resized as necessary.</span></span><br><span class="line"><span class="comment">         * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">Entry</span>[] table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The number of entries in the table.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> int size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The next size value at which to resize.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> int threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p>可以看到ThreadLocalMap有一个常量和三个成员变量：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The initial capacity -- MUST be a power of two.</span></span><br><span class="line"><span class="comment"> * Map的初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, resized as necessary.</span></span><br><span class="line"><span class="comment"> * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment"> * Entry类型的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of entries in the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">size</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p><strong>其中 INITIAL_CAPACITY代表这个Map的初始容量；table 是一个Entry 类型的数组，用于存储数据；size 代表表中的存储数目； threshold 代表需要扩容时对应 size 的阈值。</strong></p><p>Entry 类是 ThreadLocalMap 的静态内部类，用于存储数据。它的源码如下：</p><p><strong>Entry类继承了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，即每个Entry对象都有一个ThreadLocal的弱引用（作为key），这是为了防止内存泄露。一旦线程结束，key变为一个不可达的对象，这个Entry就可以被GC了。</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</span> </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            <span class="type">Object</span> value;</span><br><span class="line"></span><br><span class="line">            <span class="type">Entry</span>(<span class="type">ThreadLocal</span>&lt;?&gt; k, <span class="type">Object</span> v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ThreadLocalMap类有两个构造函数，其中常用的是ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue)：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class="line"><span class="comment"> * ThreadLocalMaps are constructed lazily, so we only create</span></span><br><span class="line"><span class="comment"> * one when we have at least one entry to put in it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="keyword">table</span> = new <span class="comment">Entry[INITIAL_CAPACITY]</span>;</span><br><span class="line">    int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">table</span>[i] = new <span class="comment">Entry(firstKey, firstValue)</span>;</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造函数的第一个参数就是本ThreadLocal实例(this)，第二个参数就是要保存的线程本地变量。构造函数首先创建一个长度为16的Entry数组，然后计算出firstKey对应的哈希值，然后存储到table中，并设置size和threshold。</strong></p><p>注意一个细节，计算hash的时候里面采用了<code>hashCode &amp; (size - 1)</code>的算法，这相当于取模运算<code>hashCode % size</code>的一个更高效的实现（和HashMap中的思路相同）。正是因为这种算法，我们要求size必须是 <code>2的指数</code>，因为这可以使得<code>hash发生冲突的次数减小</code>。</p><p>我们来看ThreadLocalMap#set方法的实现：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the value associated with key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param key the thread local object</span></span><br><span class="line"><span class="comment">     * @param value the value to be set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="built_in">set</span>(ThreadLocal&lt;?&gt; <span class="built_in">key</span>, <span class="keyword">Object</span> value) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">        <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">        <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">        <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="built_in">int</span> len = tab.length;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="built_in">key</span>.threadLocalHashCode &amp; (len<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="built_in">key</span>) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                replaceStaleEntry(<span class="built_in">key</span>, value, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tab[i] = <span class="keyword">new</span> Entry(<span class="built_in">key</span>, value);</span><br><span class="line">        <span class="built_in">int</span> sz = ++<span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">            rehash();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>如果冲突了，就会通过nextIndex方法再次计算哈希值：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Increment i modulo len.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>到这里，我们看到 ThreadLocalMap 解决冲突的方法是 <code>线性探测法（不断加 1）</code>，而不是 HashMap 的 <code>链地址法</code>，这一点也能从 Entry 的结构上推断出来。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每个 <strong>Thread 里都含有一个 ThreadLocalMap 的成员变量，这种机制将 ThreadLocal 和线程巧妙地绑定在了一起，即可以保证无用的ThreadLocal被及时回收，不会造成内存泄露，又可以提升性能</strong>。假如我们把 <code>ThreadLocalMap</code> 做成一个<code>Map&lt;t extends Thread, ?&gt;</code> 类型的 Map，那么它存储的东西将会非常多（相当于一张全局线程本地变量表），这样的情况下用线性探测法解决哈希冲突的问题效率会非常差。而 JDK 里的这种利用 ThreadLocal 作为 key，再将<code>ThreadLocalMap</code>与线程相绑定的实现，完美地解决了这个问题。</p><p>总结一下什么时候无用的 Entry 会被清理：</p><blockquote><ul><li>Thread 结束的时候</li><li>插入元素时，发现 staled entry，则会进行替换并清理</li><li>插入元素时，ThreadLocalMap 的 size 达到 threshold，并且没有任何 staled entries 的时候，会调用 rehash 方法清理并扩容</li><li>调用 ThreadLocalMap 的 remove 方法或set(null) 时</li></ul></blockquote><p>尽管不会造成内存泄露，但是可以看到无用的Entry只会在以上四种情况下才会被清理，这就可能导致一些 Entry 虽然无用但还占内存的情况。<strong>因此，我们在使用完 ThreadLocal 后一定要remove一下，保证及时回收掉无用的 Entry。</strong></p><p><strong>特别地，当应用线程池的时候，由于线程池的线程一般会复用，Thread 不结束，这时候用完更需要 <code>remove</code> 了。</strong></p><p><strong>总的来说，对于多线程资源共享的问题，同步机制采用了 <code>以时间换空间</code> 的方式，而 ThreadLocal 则采用了 以<code>空间换时间</code> 的方式。前者仅提供一份变量，让不同的线程排队访问；而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</strong></p><hr><h2 id="哈希表-线性探测法和链地址法"><a href="#哈希表-线性探测法和链地址法" class="headerlink" title="哈希表-线性探测法和链地址法"></a>哈希表-线性探测法和链地址法</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><strong>1、概念</strong></p><p><strong>哈希表(Hash Table)也叫散列表，是根据关键码值（Key Value）而直接进行访问的数据结构</strong>。它通过把关键码值映射到哈希表中的一个位置来访问记录，以加快查找的速度。这个映射函数就做散列函数，存放记录的数组叫做散列表。</p><p><strong>2、散列存储的基本思路</strong></p><p>以数据中每个元素的关键字K为自变量，通过散列函数H（k）计算出函数值，以该函数值作为一块连续存储空间的的单元地址，将该元素存储到函数值对应的单元中。</p><p><strong>3、哈希表查找的时间复杂度</strong></p><p>哈希表存储的是键值对，其查找的时间复杂度与元素数量多少无关，哈希表在查找元素时是通过计算哈希码值来定位元素的位置从而直接访问元素的，因此，哈希表查找的时间复杂度为O（1）</p><h4 id="常用哈希函数"><a href="#常用哈希函数" class="headerlink" title="常用哈希函数"></a>常用哈希函数</h4><p><strong>1.直接寻址法</strong></p><p>取关键字或者关键字的某个线性函数值作为哈希地址,即H(Key)=Key或者H(Key)=a*Key+b(a,b为整数),这种散列函数也叫做自身函数.如果H(Key)的哈希地址上已经有值了,那么就往下一个位置找,知道找到H(Key)的位置没有值了就把元素放进去.</p><p><strong>2.数字分析法</strong></p><p>分析一组数据,比如一组员工的出生年月,这时我们发现出生年月的前几位数字一般都相同,因此,出现冲突的概率就会很大,但是我们发现年月日的后几位表示月份和具体日期的数字差别很大,如果利用后面的几位数字来构造散列地址,则冲突的几率则会明显降低.因此数字分析法就是找出数字的规律,尽可能利用这些数据来构造冲突几率较低的散列地址.</p><p><strong>3.平方取中法</strong></p><p>取关键字平方后的中间几位作为散列地址.一个数的平方值的中间几位和数的每一位都有关。因此，有平方取中法得到的哈希地址同关键字的每一位都有关，是的哈希地址具有较好的分散性。该方法适用于关键字中的每一位取值都不够分散或者较分散的位数小于哈希地址所需要的位数的情况。</p><p><strong>4.折叠法</strong></p><p>折叠法即将关键字分割成位数相同的几部分,最后一部分位数可以不同,然后取这几部分的叠加和(注意:叠加和时去除进位)作为散列地址.数位叠加可以有移位叠加和间界叠加两种方法.移位叠加是将分割后的每一部分的最低位对齐,然后相加;间界叠加是从一端向另一端沿分割界来回折叠,然后对齐相加.</p><p><strong>5.随机数法</strong></p><p>选择一个随机数,去关键字的随机值作为散列地址,通常用于关键字长度不同的场合.</p><p><strong>6.除留余数法</strong></p><p>取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址.即H(Key)=Key MOD p,p&lt;=m.不仅可以对关键字直接取模,也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选得不好，则很容易产生冲突。一般p取值为表的长度tableSize。</p><h3 id="哈希冲突的处理方法"><a href="#哈希冲突的处理方法" class="headerlink" title="哈希冲突的处理方法"></a>哈希冲突的处理方法</h3><p><strong>1、开放定址法——线性探测</strong></p><p>线性探测法的地址增量di = 1, 2, … , m-1，其中，i为探测次数。该方法一次探测下一个地址，知道有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。</p><p>线性探测容易产生“聚集”现象。当表中的第i、i+1、i+2的位置上已经存储某些关键字，则下一次哈希地址为i、i+1、i+2、i+3的关键字都将企图填入到i+3的位置上，这种多个哈希地址不同的关键字争夺同一个后继哈希地址的现象称为“聚集”。聚集对查找效率有很大影响。</p><p><strong>2、开放地址法——二次探测</strong></p><p>二次探测法的地址增量序列为 di =1^2， -1^2， 2^2， -2^2，… ， q2, -q2(q &lt;= m/2)。二次探测能有效避免“聚集”现象，但是不能够探测到哈希表上所有的存储单元，但是至少能够探测到一半。</p><p><strong>3、链地址法(HashMap中用到的方法)</strong></p><p>链地址法也成为拉链法。其基本思路是：<strong>将所有具有相同哈希地址的而不同关键字的数据元素连接到同一个单链表中</strong>。如果选定的哈希表长度为m，则可将哈希表定义为一个有m个头指针组成的指针数组<code>T[0..m-1]</code>，凡是哈希地址为i的数据元素，均以节点的形式插入到T[i]为头指针的单链表中。并且新的元素插入到链表的前端，这不仅因为方便，还因为经常发生这样的事实：新近插入的元素最优可能不久又被访问。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;成熟成熟&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;ThreadLocal也是一种解决多线程并发无锁的方
      
    
    </summary>
    
      <category term="线程" scheme="http://yoursite.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Netty简介</title>
    <link href="http://yoursite.com/2019/01/20/Netty/"/>
    <id>http://yoursite.com/2019/01/20/Netty/</id>
    <published>2019-01-20T04:00:00.000Z</published>
    <updated>2019-03-11T12:17:24.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>图片<br><img src="https://github.com/Foutlook/Faceyou/blob/master/picture/wangcangstart.png?raw=true" alt="一张无聊的图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;图片&lt;br&gt;&lt;img src=&quot;https://github.com/Foutlook/Faceyou/blob/master/pictur
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="NIO，IO" scheme="http://yoursite.com/tags/NIO%EF%BC%8CIO/"/>
    
  </entry>
  
  <entry>
    <title>来自2019的2018</title>
    <link href="http://yoursite.com/2019/01/01/2018%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/01/01/2018总结/</id>
    <published>2019-01-01T01:00:00.000Z</published>
    <updated>2019-01-02T15:25:39.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>18年悄然已过，有点匆忙，有的不知所措。18年一直被时间催着走。</p><p>现在我是个很在意时间节点的人，好像非要做点什么才不辜负这个特殊的时间节点，也许是感觉时间过得有点快，也许是想留点值得回忆的事，也许是过去时间里得到的没有想象中的多，也许心中对过去的不舍。不过今年元旦我自己一个人在屋子里躺了三天，这样的时刻里独自度过倒也不错，趁这个机会总结一下过去的一年。</p><hr><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>今年最大的遗憾就是工作了，可谓是有点惨。技术上没有太多的收获。其中的经历就不多说了，不过对我的教训也是一辈子的，忘不掉了，说实话不抱怨是不可能的，心里总有点不服，不甘，又有点委屈，公司的人可能好久都忘不掉。开玩笑了，主要的原因还是自身的原因：</p><blockquote><ul><li><strong>首先</strong>，自身的技术不过硬，没有太多的项目经验，开发起来比较吃力，没有为公司的项目带来开发上的推进。</li><li><strong>第二</strong>，中期态度上有很大的问题，一开始的时候，简单的工作还好，没有出现太多的comment，心态很可以正常维持，到后面comment实在太多，中间又遇到一个自己无法解决的问题，搞了好久，心态瞬间崩了，态度就变得十分不友好，不够坚定和自信。</li><li><strong>第三</strong>，交流上一直是我的弊端，我不太擅长和不熟的人交流，我说话比较耿直，工作上的反馈也很少，像个傻子一样坐在那里。</li></ul></blockquote><p>这些教训是一次很大的收获，19年我会时刻提醒自己，学会在工作中生活。希望19年的我技术上达到一个更高的层次。工资更高点。</p><hr><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>去年上半年因为还没有毕业，那生活过的真舒服。没有太多顾虑，一切都为毕业忙碌着，很累，很快乐。<br>真正工作后，生活就过得很是单调，因为是一个人住，下了班就无所事事，看书实在看不进去。整个人变得十分的无聊，也是从那个时候开始，自己更不喜欢说话。</p><p>19年希望我要活得更自在。不工作的时候就出去转转，是时候和同学互动一下了，一个人也好，一群人也罢，都是生活，好好活着。19年想来一次健身，希望自己有一身的腱子肉。</p><hr><h2 id="性格"><a href="#性格" class="headerlink" title="性格"></a>性格</h2><p>自己的性格有时像个柔弱的女生，做事说话不想一个阳刚男生：矫情、腼腆、幼稚、爱抱怨、受不了委屈、说话太温柔、不自信、没用的想的太多…  也许是生活环境原因吧，我妈在我小时候天天唠叨我要是个女生就好了。</p><p>19年希望我能够继续改变自己的性格，遇到事情能够更加沉着稳重，更加现实一点，能够多方面的看待问题。自己更加成熟，更自信，更能抗住来自各方面的压力。做个更加健全的少年。</p><hr><h2 id="要学的还有很多"><a href="#要学的还有很多" class="headerlink" title="要学的还有很多"></a>要学的还有很多</h2><p>学习不能够停止，就像吃饭一样。</p><p>这个社会知识更新的速度感觉要超过学习的速度。自己不懂的还有很多很多，每一个领域每一个层次都有着自己深奥之处。只有不断的学习才能够跟上世界的脚步。</p><p>希望19年自己能够养成看书的习惯，闲暇的时候，能够抱着书认真的看一看。把自己囤的基本技术书看完。</p><hr><h2 id="愿"><a href="#愿" class="headerlink" title="愿"></a>愿</h2><p>希望我在意的人能够健康幸福，我的存在能够给他们带来更多的快乐。愿你一切安好。</p><blockquote><p>什么是生活？</p><p>想念某人了，便日行千里来相见，是生活。嘴馋了，穿行一座城找到熟悉的小摊，是生活。甚至疲倦无聊了，闷头睡上一整天，也是生活。</p><p>生活既是是风花雪月、悲欢离合，也是人间烟火、饮食男女。</p><p>既然活着当然要好好活着。我会好好活，你也要好好的。</p></blockquote><p><strong>一切都会变得好起来。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;18年悄然已过，有点匆忙，有的不知所措。18年一直被时间催着走。&lt;/p&gt;
&lt;p&gt;现在我是个很在意时间节点的人，好像非要做点什么才不辜负这个特
      
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="所思所想" scheme="http://yoursite.com/tags/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo与Zookeeper</title>
    <link href="http://yoursite.com/2018/12/20/Dubbo%E4%B8%8EZookeeper/"/>
    <id>http://yoursite.com/2018/12/20/Dubbo与Zookeeper/</id>
    <published>2018-12-20T01:00:00.000Z</published>
    <updated>2019-01-17T08:21:12.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>目前进入一家，做仓库存储的公司，公司使用的技术也都是现在使用比较多的。以下只是个人记录，不做任何商业用途。</p><h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><p>关于Dubbo，网上的资料很多，我也都看了很多，林林丛丛的都是对Dubbo技术的介绍，Dubbo用起来很简单，基本上就是配置配置xml文件。这里就不在介绍Dubbo怎么使用了。</p><p>我对Dubbo主要的疑虑主要有以下几点：</p><blockquote><ol><li>RPC原理是什么?</li><li>为什么Dubbo可以达到调用远程服务的目的？</li><li>Dubbo为什么能够实现软负载均衡，服务注册与发现的？</li></ol></blockquote><p>不过想要解决这些疑问，需要研究源码。因为对Dubbo涉及到的部分技术还有很多不是特别懂，暂时没有看源码。这部分技术分享暂时不做，等我看完源码再好好分享。</p><p><a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html" target="_blank" rel="noopener">Dubbo官方文档</a></p><h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h2 id="Zookeeper的简介"><a href="#Zookeeper的简介" class="headerlink" title="Zookeeper的简介"></a>Zookeeper的简介</h2><p>ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode。每个ZNode都可以通过其路径唯一标识，<strong>在每个ZNode上可存储少量数据(默认是1M</strong>, 可以通过配置修改,通常不建议在ZNode上存储大量的数据)。另外，每个ZNode上还存储了其Acl信息，这里需要注意，虽说ZNode的树形结构跟Unix文件系统很类似，但是其Acl与Unix文件系统是完全不同的，每个ZNode的Acl是独立的，子结点不会继承父结点的。</p><p><img src="zk2.jpg" alt="ZK"></p><p>ZNode根据其本身的特性，可以分为下面两类：</p><blockquote><ul><li>Regular ZNode: 常规型ZNode, 用户需要显式的创建、删除</li><li>Ephemeral ZNode: 临时型ZNode,用户创建它之后，可以显式的删除，也可以在创建它的Session结束后，由ZooKeeper Server自动删除</li></ul></blockquote><p><strong>Zookeeper这种数据结构有如下这些特点：</strong></p><blockquote><ul><li><p>1）<strong>每个子目录项如NameService都被称作为znode</strong>，这个znode是被它所在的路径唯一标识，如Server1这个znode的标识为/NameService/Server1。</p></li><li><p>2）<strong>znode可以有子节点目录</strong>，并且每个znode可以存储数据，注意EPHEMERAL（临时的）类型的目录节点不能有子节点目录。ZNode一个Sequential的特性，如果创建的时候指定的话，该ZNode的名字后面会自动Append一个不断增加的SequenceNo。</p></li><li><p>3）<strong>znode是有版本的</strong>（version），每个znode中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据，version号自动增加。</p></li><li><p>4）<strong>znode可以是临时节点（EPHEMERAL），可以是持久节点（PERSISTENT）</strong>。如果创建的是临时节点，一旦创建这个EPHEMERALznode的客户端与服务器失去联系，这个znode也将自动删除，Zookeeper的客户端和服务器通信采用长连接方式，每个客户端和服务器通过心跳来保持连接，这个连接状态称为session，如果znode是临时节点，这个session失效，znode也就删除了。</p></li><li><p>5）<strong>znode的目录名可以自动编号</strong>，如App1已经存在，再创建的话，将会自动命名为App2。</p></li><li><p>6）<strong>znode可以被监控</strong>，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端，这个是Zookeeper的核心特性，Zookeeper的很多功能都是基于这个特性实现的。Watcher ZooKeeper支持一种Watch操作，Client可以在某个ZNode上设置一个Watcher，来Watch该ZNode上的变化。如果该ZNode上有相应的变化，就会触发这个Watcher，把相应的事件通知给设置Watcher的Client。需要注意的是，ZooKeeper中的Watcher是一次性的，即触发一次就会被取消，如果想继续Watch的话，需要客户端重新设置Watcher。这个跟epoll里的oneshot模式有点类似。</p></li><li><p>7）<strong>ZXID</strong>：每次对Zookeeper的状态的改变都会产生一个zxid（ZooKeeper Transaction Id），zxid是全局有序的，如果zxid1小于zxid2，则zxid1在zxid2之前发生。</p></li><li><p>8)<strong>Session</strong>: Client与ZooKeeper之间的通信，需要创建一个Session，这个Session会有一个超时时间。因为ZooKeeper集群会把Client的Session信息持久化，所以在Session没超时之前，Client与ZooKeeper Server的连接可以在各个ZooKeeper Server之间透明地移动。在实际的应用中，如果Client与Server之间的通信足够频繁，Session的维护就不需要其它额外的消息了。否则，ZooKeeper Client会每t/3 ms发一次心跳给Server，如果Client 2t/3 ms没收到来自Server的心跳回应，就会换到一个新的ZooKeeper Server上。这里t是用户配置的Session的超时时间。</p></li></ul></blockquote><h2 id="Zookeeper的结构"><a href="#Zookeeper的结构" class="headerlink" title="Zookeeper的结构"></a>Zookeeper的结构</h2><p>如下图：</p><p><img src="zk3.jpg" alt="ZK"></p><p><img src="zk1.jpg" alt="ZK"></p><p>client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。</p><h3 id="ZooKeeper-Watch"><a href="#ZooKeeper-Watch" class="headerlink" title="ZooKeeper Watch"></a>ZooKeeper Watch</h3><p><strong>Zookeeper watch是一种监听通知机制</strong>。Zookeeper所有的读操作getData(), getChildren()和 exists()都可以设置监视(watch)，监视事件可以理解为一次性的触发器，官方定义如下：<code>a watch event is one-time trigger, sent to the client that set the watch, whichoccurs when the data for which the watch was set changes。</code></p><p><strong>Watch的三个关键点：</strong></p><h4 id="（一次性触发）One-time-trigger"><a href="#（一次性触发）One-time-trigger" class="headerlink" title="（一次性触发）One-time trigger"></a>（一次性触发）One-time trigger</h4><p>当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了getData(“/znode1”, true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件<strong>，而如果 /znode1 再一次发生了变化，除非客户端再次对/znode1 设置监视，否则客户端不会收到事件通知。</strong></p><h4 id="（发送至客户端）Sent-to-the-client"><a href="#（发送至客户端）Sent-to-the-client" class="headerlink" title="（发送至客户端）Sent to the client"></a>（发送至客户端）Sent to the client</h4><p><strong>Zookeeper客户端和服务端是通过 socket 进行通信的</strong>，由于网络存在故障， 所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了顺序保证(ordering guarantee)：<strong>即客户端只有首先看到了监视事件后，才会感知到它所设置监视的znode发生了变化</strong>。网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。</p><h4 id="（被设置-watch-的数据）The-data-for-which-the-watch-was-set"><a href="#（被设置-watch-的数据）The-data-for-which-the-watch-was-set" class="headerlink" title="（被设置 watch 的数据）The data for which the watch was set"></a>（被设置 watch 的数据）The data for which the watch was set</h4><p><strong>这意味着znode节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表</strong>：<strong>数据监视和子节点监视</strong>(data watches and child watches) <code>getData() 和exists()</code>设置数据监视，<code>getChildren()</code>设置子节点监视。或者你也可以想象 Zookeeper 设置的不同监视返回不同的数据，<code>getData() 和 exists()</code> 返回znode节点的相关信息，而<code>getChildren()</code> 返回子节点列表。因此，<code>setData()</code> 会触发设置在某一节点上所设置的数据监视（假定数据设置成功），而一次成功的<code>create()</code> 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。</p><p><strong>Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发</strong>。当客户端与 Zookeeper 服务器失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说这通常是透明的。只有一种情况会导致监视事件的丢失，<strong>即：通过exists()设置了某个znode节点的监视，但是如果某个客户端在此znode节点被创建和删除的时间间隔内与zookeeper服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。</strong></p><h2 id="ZooKeeper的工作原理"><a href="#ZooKeeper的工作原理" class="headerlink" title="ZooKeeper的工作原理"></a>ZooKeeper的工作原理</h2><p>在zookeeper的集群中，各个节点共有下面3种角色和4种状态：</p><blockquote><ul><li>角色：leader,follower,observer</li><li>状态：leading,following,observing,looking</li></ul></blockquote><p><strong>Zookeeper的核心是原子广播</strong>，这个机制保证了各个<code>Server</code>之间的同步。实现这个机制的协议叫做<code>Zab协议（ZooKeeper Atomic Broadcast protocol）</code>。Zab协议有<code>两种</code>模式，它们分别是<code>恢复模式（Recovery选主）和广播模式（Broadcast同步）</code>。当服务启动或者在领导者崩溃后，<strong>Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了</strong>。状态同步保证了leader和Server具有相同的系统状态。</p><p>为了<code>保证事务的顺序一致性</code>，zookeeper采用了递增的事务<code>id号（zxid）</code>来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</p><p>每个Server在工作过程中有4种状态：</p><blockquote><ul><li>LOOKING：当前Server不知道leader是谁，正在搜寻。</li><li>LEADING：当前Server即为选举出来的leader。</li><li>FOLLOWING：leader已经选举出来，当前Server与之同步。</li><li>OBSERVING：observer的行为在大多数情况下与follower完全一致，但是他们不参加选举和投票，而仅仅接受(observing)选举和投票的结果。</li></ul></blockquote><h2 id="Zookeeper的典型应用场景"><a href="#Zookeeper的典型应用场景" class="headerlink" title="Zookeeper的典型应用场景"></a>Zookeeper的典型应用场景</h2><p>参考：<a href="http://jm.taobao.org/2011/10/08/1232/" target="_blank" rel="noopener">阿里中间件博客</a></p><h3 id="数据发布与订阅（配置中心）"><a href="#数据发布与订阅（配置中心）" class="headerlink" title="数据发布与订阅（配置中心）"></a>数据发布与订阅（配置中心）</h3><p>发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到ZK节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，服务式服务框架的服务地址列表等就非常适合使用。</p><blockquote><p><strong>应用中用到的一些配置信息放到ZK上进行集中管理。这类场景通常是这样</strong>：应用在启动的时候会主动来获取一次配置，同时，在节点上注册一个Watcher，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。 分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在ZK的一些指定节点，供各个客户端订阅使用。</p><p><strong>分布式日志收集系统</strong>。这个系统的核心工作是收集分布在不同机器的日志。收集器通常是按照应用来分配收集任务单元，因此需要在ZK上创建一个以应用名作为path的节点P，并将这个应用的所有机器ip，以子节点的形式注册到节点P上，这样一来就能够实现机器变动的时候，能够实时通知到收集器调整任务分配。 系统中有些信息需要动态获取，并且还会存在人工手动去修改这个信息的发问。通常是暴露出接口，例如JMX接口，来获取一些运行时的信息。引入ZK之后，就不用自己实现一套方案了，只要将这些信息存放到指定的ZK节点上即可。 </p><p>==注意：在上面提到的应用场景中，有个默认前提是：数据量很小，但是数据更新可能会比较快的场景。==</p></blockquote><hr><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>这里说的负载均衡是指软负载均衡。在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，其中比较典型的是消息中间件中的生产者，消费者负载均衡。<br>消息中间件中发布者和订阅者的负载均衡，linkedin开源的KafkaMQ和阿里开源的metaq都是通过zookeeper来做到生产者、消费者的负载均衡。这里以metaq为例如讲下：</p><blockquote><p><strong>生产者负载均衡</strong>：metaq发送消息的时候，生产者在发送消息的时候必须选择一台broker上的一个分区来发送消息，因此metaq在运行过程中，会把所有broker和对应的分区信息全部注册到ZK指定节点上，默认的策略是一个依次轮询的过程，生产者在通过ZK获取分区列表之后，会按照brokerId和partition的顺序排列组织成一个有序的分区列表，发送的时候按照从头到尾循环往复的方式选择一个分区来发送消息。 </p><p><strong>消费负载均衡：</strong> 在消费过程中，一个消费者会消费一个或多个分区中的消息，但是一个分区只会由一个消费者来消费。MetaQ的消费策略是：</p><ul><li>每个分区针对同一个group只挂载一个消费者。 </li><li>如果同一个group的消费者数目大于分区数目，则多出来的消费者将不参与消费。</li><li>如果同一个group的消费者数目小于分区数目，则有部分消费者需要额外承担消费任务。</li><li>在某个消费者故障或者重启等情况下，其他消费者会感知到这一变化（通过 zookeeper watch消费者列表），然后重新进行负载均衡，保证所有的分区都有消费者进行消费。</li></ul></blockquote><hr><h3 id="命名服务-Naming-Service"><a href="#命名服务-Naming-Service" class="headerlink" title="命名服务(Naming Service)"></a>命名服务(Naming Service)</h3><p><strong>命名服务也是分布式系统中比较常见的一类场景</strong>。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等——这些我们都可以统称他们为名字（Name）。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建节点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。</p><blockquote><p>阿里巴巴集团开源的分布式服务框架Dubbo中使用ZooKeeper来作为其命名服务，维护全局的服务地址列表，点击这里查看Dubbo开源项目。在Dubbo实现中：</p><ul><li><p>服务提供者在启动的时候，向ZK上的指定节点/dubbo/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的发布。</p></li><li><p>服务消费者启动的时候，订阅/dubbo/${serviceName}/providers目录下的提供者URL地址， 并向/dubbo/${serviceName} /consumers目录下写入自己的URL地址。</p></li></ul><p>==<strong>注意，所有向ZK上注册的地址都是临时节点，这样就能够保证服务提供者和消费者能够自动感应资源的变化。</strong>==</p><p>另外，Dubbo还有针对服务粒度的监控，方法是订阅/dubbo/${serviceName}目录下所有提供者和消费者的信息。</p></blockquote><hr><h3 id="分布式通知-协调"><a href="#分布式通知-协调" class="headerlink" title="分布式通知/协调"></a>分布式通知/协调</h3><p>ZooKeeper中特有watcher注册与异步通知机制，能够很好的实现分布式环境下不同系统之间的通知与协调，实现对数据变更的实时处理。使用方法通常是不同系统都对ZK上同一个znode进行注册，监听znode的变化（包括znode本身内容及子节点的），其中一个系统update了znode，那么另一个系统能够收到通知，并作出相应处理</p><blockquote><ul><li><strong>另一种心跳检测机制</strong>：检测系统和被检测系统之间并不直接关联起来，而是通过zk上某个节点关联，大大减少系统耦合。 </li><li><strong>另一种系统调度模式</strong>：某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了ZK上某些节点的状态，而ZK就把这些变化通知给他们注册Watcher的客户端，即推送系统，于是，作出相应的推送任务。</li><li><strong>另一种工作汇报模式</strong>：一些类似于任务分发系统，子任务启动后，到zk来注册一个临时节点，并且定时将自己的进度进行汇报（将进度写回这个临时节点），这样任务管理者就能够实时知道任务进度。</li></ul><p>总之，使用zookeeper来进行分布式通知和协调能够大大降低系统之间的耦合</p></blockquote><hr><h3 id="集群管理与Master选举"><a href="#集群管理与Master选举" class="headerlink" title="集群管理与Master选举"></a>集群管理与Master选举</h3><p>集群机器监控：这通常用于那种对集群中机器状态，机器在线率有较高要求的场景，能够快速对集群中机器变化作出响应。这样的场景中，往往有一个监控系统，实时检测集群机器是否存活。过去的做法通常是：监控系统通过某种手段（比如ping）定时检测每个机器，或者每个机器自己定时向监控系统汇报“我还活着”。 这种做法可行，但是存在两个比较明显的问题：</p><blockquote><ol><li>集群中机器有变动的时候，牵连修改的东西比较多。</li><li>有一定的延时。</li></ol><p>利用ZooKeeper有两个特性，就可以实时另一种集群机器存活性监控系统：</p><ol><li>客户端在节点 x 上注册一个Watcher，那么如果 x?的子节点变化了，会通知该客户端。</li><li>创建EPHEMERAL类型的节点，一旦客户端和服务器的会话结束或过期，那么该节点就会消失。</li></ol><p>例如，监控系统在 /clusterServers 节点上注册一个Watcher，以后每动态加机器，那么就往 /clusterServers 下创建一个 EPHEMERAL类型的节点：/clusterServers/{hostname}. 这样，监控系统就能够实时知道机器的增减情况，至于后续处理就是监控系统的业务了。 Master选举则是zookeeper中最为经典的应用场景了。</p><p>在分布式环境中，相同的业务应用分布在不同的机器上，有些业务逻辑（例如一些耗时的计算，网络I/O处理），往往只需要让整个集群中的某一台机器进行执行，其余机器可以共享这个结果，这样可以大大减少重复劳动，提高性能，于是这个master选举便是这种场景下的碰到的主要问题。</p><p>利用ZooKeeper的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建 /currentMaster 节点，最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很轻易的在分布式环境中进行集群选取了。</p></blockquote><p>另外，这种场景演化一下，就是动态Master选举。这就要用到?EPHEMERAL_SEQUENTIAL类型节点的特性了。</p><p>上文中提到，所有客户端创建请求，最终只有一个能够创建成功。在这里稍微变化下，就是允许所有请求都能够创建成功，但是得有个创建顺序，于是所有的请求最终在ZK上创建结果的一种可能情况是这样： /currentMaster/{sessionId}-1 ,?/currentMaster/{sessionId}-2 ,?/currentMaster/{sessionId}-3 ….. 每次选取序列号最小的那个机器作为Master，如果这个机器挂了，由于他创建的节点会马上小时，那么之后最小的那个机器就是Master了。</p><p>在搜索系统中，如果集群中每个机器都生成一份全量索引，不仅耗时，而且不能保证彼此之间索引数据一致。因此让集群中的Master来进行全量索引的生成，然后同步到集群中其它机器。另外，Master选举的容灾措施是，可以随时进行手动指定master，就是说应用在zk在无法获取master信息时，可以通过比如http方式，向一个地方获取master。 在Hbase中，也是使用ZooKeeper来实现动态HMaster的选举。在Hbase实现中，会在ZK上存储一些ROOT表的地址和HMaster的地址，HRegionServer也会把自己以临时节点（Ephemeral）的方式注册到Zookeeper中，使得HMaster可以随时感知到各个HRegionServer的存活状态，同时，一旦HMaster出现问题，会重新选举出一个HMaster来运行，从而避免了HMaster的单点问题</p><hr><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁，这个主要得益于ZooKeeper为我们保证了数据的强一致性。锁服务可以分为两类，一个是保持独占，另一个是控制时序。</p><blockquote><p><strong>所谓保持独占</strong>，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把zk上的一个znode看作是一把锁，通过create znode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。</p><p><strong>控制时序</strong>，就是所有视图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里 /distribute_lock 已经预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode.EPHEMERAL_SEQUENTIAL来指定）。Zk的父节点（/distribute_lock）维持一份sequence,保证子节点创建的时序性，从而也形成了每个客户端的全局时序。</p></blockquote><hr><h3 id="分布式队列"><a href="#分布式队列" class="headerlink" title="分布式队列"></a>分布式队列</h3><p>队列方面，简单地讲有两种，一种是常规的先进先出队列，另一种是要等到队列成员聚齐之后的才统一按序执行。对于第一种先进先出队列，和分布式锁服务中的控制时序场景基本原理一致，这里不再赘述。</p><blockquote><p><strong>第二种队列其实是在FIFO队列的基础上作了一个增强</strong>。通常可以在 /queue 这个znode下预先建立一个/queue/num 节点，并且赋值为n（或者直接给/queue赋值n），表示队列大小，之后每次有队列成员加入后，就判断下是否已经到达队列大小，决定是否可以开始执行了。这种用法的典型场景是，分布式环境中，一个大任务Task A，需要在很多子任务完成（或条件就绪）情况下才能进行。这个时候，凡是其中一个子任务完成（就绪），那么就去 /taskList 下建立自己的临时时序节点（CreateMode.EPHEMERAL_SEQUENTIAL），当 /taskList 发现自己下面的子节点满足指定个数，就可以进行下一步按序进行处理了。</p></blockquote><hr><h2 id="Zookeeper应用"><a href="#Zookeeper应用" class="headerlink" title="Zookeeper应用"></a>Zookeeper应用</h2><p>近期公司给了我一个简单的任务，就是利用zk 实现当外界的某一个条件改变的时候，通知客户端或者服务端重新获取新的取值。技术上使用zk的分布式通知/协调来实现。</p><h3 id="Zookeeper客户端Curator的使用"><a href="#Zookeeper客户端Curator的使用" class="headerlink" title="Zookeeper客户端Curator的使用"></a>Zookeeper客户端Curator的使用</h3><p>Curator是Netflix公司开源的一套zookeeper客户端框架，解决了很多Zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册Watcher和NodeExistsException异常等等。</p><p>Curator包含了几个包：</p><blockquote><ul><li>curator-framework：对zookeeper的底层api的一些封装。</li><li>curator-client：提供一些客户端的操作，例如重试策略等。</li><li>curator-recipes：封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式计数器、分布式Barrier等。</li></ul></blockquote><p>Maven依赖(使用curator的版本：2.12.0，对应Zookeeper的版本为：3.4.x，如果跨版本会有兼容性问题，很有可能导致节点操作失败)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Curator的基本Api"><a href="#Curator的基本Api" class="headerlink" title="Curator的基本Api"></a>Curator的基本Api</h3><h4 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h4><p><strong>1.使用静态工程方法创建客户端</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);</span><br><span class="line">CuratorFramework<span class="built_in"> client </span>= CuratorFrameworkFactory.newClient(</span><br><span class="line">        connectionInfo,</span><br><span class="line">        5000,</span><br><span class="line">        3000,</span><br><span class="line">        retryPolicy);</span><br></pre></td></tr></table></figure><p><strong>newClient静态工厂方法包含四个主要参数：</strong></p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>connectionString</td><td>服务器列表，格式host1:port1,host2:port2,…</td></tr><tr><td>retryPolicy</td><td>重试策略,内建有四种重试策略,也可以自行实现RetryPolicy接口</td></tr><tr><td>sessionTimeoutMs</td><td>会话超时时间，单位毫秒，默认60000ms</td></tr><tr><td>connectionTimeoutMs</td><td>连接创建超时时间，单位毫秒，默认60000ms</td></tr></tbody></table><p><strong>2.使用Fluent风格的Api创建会话</strong></p><p>核心参数变为流式设置，一个列子如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);</span><br><span class="line">CuratorFramework<span class="built_in"> client </span>=</span><br><span class="line">CuratorFrameworkFactory.builder()</span><br><span class="line">.connectString(connectionInfo)</span><br><span class="line">.sessionTimeoutMs(5000)</span><br><span class="line">.connectionTimeoutMs(5000)</span><br><span class="line">.retryPolicy(retryPolicy)</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure><p><strong>3.创建包含隔离命名空间的会话</strong></p><p>为了实现不同的Zookeeper业务之间的隔离，需要为每个业务分配一个独立的命名空间（<strong>NameSpace</strong>），即指定一个Zookeeper的根路径（官方术语：为Zookeeper添加“Chroot”特性）。例如（下面的例子）当客户端指定了独立命名空间为“/base”，那么该客户端对Zookeeper上的数据节点的操作都是基于该目录进行的。通过设置Chroot可以将客户端应用与Zookeeper服务端的一棵子树相对应，在多个应用共用一个Zookeeper集群的场景下，这对于实现不同应用之间的相互隔离十分有意义。</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RetryPolicy</span> retryPolicy = <span class="function"><span class="keyword">new</span> <span class="title">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>);</span></span><br><span class="line"><span class="function"><span class="title">CuratorFramework</span> <span class="title">client</span> =</span></span><br><span class="line"><span class="function"><span class="title">CuratorFrameworkFactory</span>.<span class="title">builder</span>()</span></span><br><span class="line"><span class="function">.<span class="title">connectString</span>(connectionInfo)</span></span><br><span class="line"><span class="function">.<span class="title">sessionTimeoutMs</span>(<span class="number">5000</span>)</span></span><br><span class="line"><span class="function">.<span class="title">connectionTimeoutMs</span>(<span class="number">5000</span>)</span></span><br><span class="line"><span class="function">.<span class="title">retryPolicy</span>(retryPolicy)</span></span><br><span class="line"><span class="function">.<span class="title">namespace</span>("base")     <span class="comment">//命名空间</span></span></span><br><span class="line"><span class="function">.<span class="title">build</span>();</span></span><br></pre></td></tr></table></figure><h3 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h3><p>当创建会话成功，得到client的实例然后可以直接调用其 <strong>start( )</strong> 方法：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.start()<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="CuratorFramework的方法"><a href="#CuratorFramework的方法" class="headerlink" title="CuratorFramework的方法"></a>CuratorFramework的方法</h3><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>create()</td><td>开始创建操作， 可以调用额外的方法(比如方式mode 或者后台执行background) 并在最后调用forPath()指定要操作的ZNode</td></tr><tr><td>delete()</td><td>开始删除操作. 可以调用额外的方法(版本或者后台处理version or background)并在最后调用forPath()指定要操作的ZNode</td></tr><tr><td>checkExists()</td><td>开始检查ZNode是否存在的操作. 可以调用额外的方法(监控或者后台处理)并在最后调用forPath()指定要操作的ZNode</td></tr><tr><td>getData()</td><td>开始获得ZNode节点数据的操作. 可以调用额外的方法(监控、后台处理或者获取状态watch, background or get stat) 并在最后调用forPath()指定要操作的ZNode</td></tr><tr><td>setData()</td><td>开始设置ZNode节点数据的操作. 可以调用额外的方法(版本或者后台处理) 并在最后调用forPath()指定要操作的ZNode</td></tr><tr><td>getChildren()</td><td>开始获得ZNode的子节点列表。 以调用额外的方法(监控、后台处理或者获取状态watch, background or get stat) 并在最后调用forPath()指定要操作的ZNode</td></tr><tr><td>inTransaction()</td><td>开始是原子ZooKeeper事务. 可以复合create, setData, check, and/or delete 等操作然后调用commit()作为一个原子操作提交</td></tr></tbody></table><h3 id="数据节点操作"><a href="#数据节点操作" class="headerlink" title="数据节点操作"></a>数据节点操作</h3><h4 id="创建数据节点"><a href="#创建数据节点" class="headerlink" title="创建数据节点"></a>创建数据节点</h4><p><strong>Zookeeper的节点属性：</strong></p><blockquote><ul><li>PERSISTENT：持久化</li><li>PERSISTENT_SEQUENTIAL：持久化并且带序列号</li><li>EPHEMERAL：临时</li><li>EPHEMERAL_SEQUENTIAL：临时并且带序列号</li></ul></blockquote><p><strong>注意：如果没有设置节点属性，节点创建模式默认为持久化节点，内容默认为空</strong></p><p>a.创建一个节点，初始内容为空：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">client</span><span class="selector-class">.create</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>);</span><br></pre></td></tr></table></figure><p>b.创建一个节点，附带初始化内容</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">client</span><span class="selector-class">.create</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>,<span class="string">"init"</span>.getBytes());</span><br></pre></td></tr></table></figure><p>c.创建一个节点，指定创建模式（临时节点），内容为空</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">client</span><span class="selector-class">.create</span>()<span class="selector-class">.withMode</span>(<span class="selector-tag">CreateMode</span><span class="selector-class">.EPHEMERAL</span>)<span class="selector-class">.forPath</span>("<span class="selector-tag">path</span>");</span><br></pre></td></tr></table></figure><p>d.创建一个节点，指定创建模式（临时节点），附带初始化内容</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">client</span><span class="selector-class">.create</span>()<span class="selector-class">.withMode</span>(<span class="selector-tag">CreateMode</span><span class="selector-class">.EPHEMERAL</span>)<span class="selector-class">.forPath</span>("<span class="selector-tag">path</span>","<span class="selector-tag">init</span>"<span class="selector-class">.getBytes</span>());</span><br></pre></td></tr></table></figure><p>e.创建一个节点，指定创建模式（临时节点），附带初始化内容，并且自动递归创建父节点</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">client</span><span class="selector-class">.create</span>()</span><br><span class="line">      <span class="selector-class">.creatingParentContainersIfNeeded</span>()</span><br><span class="line">      <span class="selector-class">.withMode</span>(<span class="selector-tag">CreateMode</span><span class="selector-class">.EPHEMERAL</span>)</span><br><span class="line">      <span class="selector-class">.forPath</span>("<span class="selector-tag">path</span>","<span class="selector-tag">init</span>"<span class="selector-class">.getBytes</span>());</span><br></pre></td></tr></table></figure><p><strong>这个creatingParentContainersIfNeeded()接口非常有用，因为一般情况开发人员在创建一个子节点必须判断它的父节点是否存在，如果不存在直接创建会抛出NoNodeException，使用creatingParentContainersIfNeeded()之后Curator能够自动递归创建所有所需的父节点。</strong></p><h4 id="删除数据节点"><a href="#删除数据节点" class="headerlink" title="删除数据节点"></a>删除数据节点</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.删除一个节点，此方法只能删除叶子节点，否则会抛出异常。</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.delete</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.删除一个节点，并且递归删除其所有的子节点</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.delete</span>()<span class="selector-class">.deletingChildrenIfNeeded</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.删除一个节点，强制指定版本进行删除</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.delete</span>()<span class="selector-class">.withVersion</span>(<span class="number">10086</span>)<span class="selector-class">.forPath</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.删除一个节点，强制保证删除,guaranteed()接口是一个保障措施，只要客户端会话有效，那么Curator会在后台持续进行删除操作，直到删除节点成功。</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.delete</span>()<span class="selector-class">.guaranteed</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.上面的多个流式接口是可以自由组合,例如:</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.delete</span>()<span class="selector-class">.guaranteed</span>()<span class="selector-class">.deletingChildrenIfNeeded</span>()<span class="selector-class">.withVersion</span>(<span class="number">10086</span>)<span class="selector-class">.forPath</span>(<span class="string">"path"</span>);</span><br></pre></td></tr></table></figure><h4 id="读取数据节点数据"><a href="#读取数据节点数据" class="headerlink" title="读取数据节点数据"></a>读取数据节点数据</h4><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.读取一个节点的数据内容,注意，此方法返的返回值是byte[ ];</span></span><br><span class="line">client.getData().forPath(<span class="string">"path"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读取一个节点的数据内容，同时获取到该节点的stat</span></span><br><span class="line"><span class="keyword">Stat</span> <span class="keyword">stat</span> = new <span class="keyword">Stat</span>()<span class="comment">;</span></span><br><span class="line">client.getData().storingStatIn(<span class="keyword">stat</span>).forPath(<span class="string">"path"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="更新数据节点数据"><a href="#更新数据节点数据" class="headerlink" title="更新数据节点数据"></a>更新数据节点数据</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.更新一个节点的数据内容,该接口会返回一个Stat实例</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.setData</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>,<span class="string">"data"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.更新一个节点的数据内容，强制指定版本进行更新</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.setData</span>()<span class="selector-class">.withVersion</span>(<span class="number">10086</span>)<span class="selector-class">.forPath</span>(<span class="string">"path"</span>,<span class="string">"data"</span>.getBytes());</span><br></pre></td></tr></table></figure><h4 id="检查节点是否存在"><a href="#检查节点是否存在" class="headerlink" title="检查节点是否存在"></a>检查节点是否存在</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法返回一个Stat实例，用于检查ZNode是否存在的操作.</span></span><br><span class="line"><span class="comment">//可以调用额外的方法(监控或者后台处理)并在最后调用forPath()指定要操作的ZNode</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.checkExists</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>);</span><br></pre></td></tr></table></figure><h4 id="获取某个节点的所有子节点路径"><a href="#获取某个节点的所有子节点路径" class="headerlink" title="获取某个节点的所有子节点路径"></a>获取某个节点的所有子节点路径</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法的返回值为List,获得ZNode的子节点Path列表。</span></span><br><span class="line"><span class="comment">//可以调用额外的方法(监控、后台处理或者获取状态watch, background or get stat)</span></span><br><span class="line"><span class="comment">//并在最后调用forPath()指定要操作的父ZNode</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.getChildren</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>);</span><br></pre></td></tr></table></figure><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>CuratorFramework的实例包含inTransaction( )接口方法，调用此方法开启一个ZooKeeper事务. 可以复合create, setData, check, and/or delete 等操作然后调用commit()作为一个原子操作提交。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">client</span><span class="selector-class">.inTransaction</span>()<span class="selector-class">.check</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>)</span><br><span class="line">      <span class="selector-class">.and</span>()</span><br><span class="line">      <span class="selector-class">.create</span>()<span class="selector-class">.withMode</span>(CreateMode.EPHEMERAL)<span class="selector-class">.forPath</span>(<span class="string">"path"</span>,<span class="string">"data"</span>.getBytes())</span><br><span class="line">      <span class="selector-class">.and</span>()</span><br><span class="line">      <span class="selector-class">.setData</span>()<span class="selector-class">.withVersion</span>(<span class="number">10086</span>)<span class="selector-class">.forPath</span>(<span class="string">"path"</span>,<span class="string">"data2"</span>.getBytes())</span><br><span class="line">      <span class="selector-class">.and</span>()</span><br><span class="line">      <span class="selector-class">.commit</span>();</span><br></pre></td></tr></table></figure><h4 id="异步接口"><a href="#异步接口" class="headerlink" title="异步接口"></a>异步接口</h4><p>上面提到的创建、删除、更新、读取等方法都是同步的，Curator提供异步接口，引入了<strong>BackgroundCallback</strong>接口用于处理异步接口调用之后服务端返回的结果信息。<strong>BackgroundCallback</strong>接口中一个重要的回调值为<strong>CuratorEvent</strong>，里面包含事件类型、响应吗和节点的详细信息。</p><p><strong>CuratorEventType</strong></p><table><thead><tr><th>事件类型</th><th>对应CuratorFramework实例的方法</th></tr></thead><tbody><tr><td>CREATE</td><td>create()</td></tr><tr><td>DELETE</td><td>delete()</td></tr><tr><td>EXISTS</td><td>checkExists()</td></tr><tr><td>GET_DATA</td><td>getData()</td></tr><tr><td>SET_DATA</td><td>setData()</td></tr><tr><td>CHILDREN</td><td>getChildren()</td></tr><tr><td>SYNC</td><td>sync(String,Object)</td></tr><tr><td>GET_ACL</td><td>getACL()</td></tr><tr><td>SET_ACL</td><td>setACL()</td></tr><tr><td>WATCHED</td><td>Watcher(Watcher)</td></tr><tr><td>CLOSING</td><td>close()</td></tr></tbody></table><p><strong>响应码(#getResultCode())</strong></p><table><thead><tr><th>响应码</th><th>意义</th></tr></thead><tbody><tr><td>0</td><td>OK，即调用成功</td></tr><tr><td>-4</td><td>ConnectionLoss，即客户端与服务端断开连接</td></tr><tr><td>-110</td><td>NodeExists，即节点已经存在</td></tr><tr><td>-112</td><td>SessionExpired，即会话过期</td></tr></tbody></table><p><strong>异步创建节点的示例如下：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Executor executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">client.create()</span><br><span class="line">      .creatingParentsIfNeeded()</span><br><span class="line">      .withMode(CreateMode.EPHEMERAL)</span><br><span class="line">      .inBackground<span class="function"><span class="params">((curatorFramework, curatorEvent) -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            System.out.println(String.format(<span class="string">"eventType:%s,resultCode:%s"</span>,curatorEvent.getType(),curatorEvent.getResultCode()));</span></span></span><br><span class="line"><span class="function"><span class="params">      &#125;,executor)</span>.<span class="title">forPath</span><span class="params">(<span class="string">"path"</span>)</span>;</span></span><br></pre></td></tr></table></figure><p><strong>注意：如果#inBackground()方法不指定executor，那么会默认使用Curator的EventThread去进行异步处理。</strong></p><h3 id="Curator高级特性"><a href="#Curator高级特性" class="headerlink" title="Curator高级特性"></a>Curator高级特性</h3><p>以上都是Curator简单的使用，在实际应用中会使用更高级的方式来管理zk节点。</p><p><strong>提醒：首先你必须添加curator-recipes依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>Zookeeper原生支持通过注册<strong>Watcher</strong>来进行事件监听，但是开发者需要反复注册(Watcher只能单次注册单次使用)。<strong>Cache</strong>是Curator中对事件监听的包装，可以看作是对事件监听的本地缓存视图，能够自动为开发者处理反复注册监听。Curator提供了三种 <strong>Watcher(Cache)</strong> 来监听结点的变化。</p><h5 id="Path-Cache"><a href="#Path-Cache" class="headerlink" title="Path Cache"></a>Path Cache</h5><p>Path Cache用来监控一个<strong>ZNode的子节点</strong>. 当一个子节点增加， 更新，删除时， Path Cache会改变它的状态， 会包含最新的子节点， 子节点的数据和状态，而状态的更变将通过<strong>PathChildrenCacheListener</strong>通知。</p><p><strong>实际使用时会涉及到四个类：</strong></p><blockquote><ul><li>PathChildrenCache</li><li>PathChildrenCacheEvent</li><li>PathChildrenCacheListener</li><li>ChildData</li></ul></blockquote><p>通过下面的构造函数创建Path Cache:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PathChildrenCache(CuratorFramework client, <span class="keyword">String</span> path, <span class="keyword">boolean</span> cacheData)</span><br></pre></td></tr></table></figure><p>想使用cache，必须调用它的start方法，使用完后调用close方法。 可以设置StartMode来实现启动的模式，</p><p>StartMode有下面几种：</p><blockquote><ul><li>NORMAL：正常初始化。</li><li>BUILD_INITIAL_CACHE：在调用start()之前会调用rebuild()。</li><li>POST_INITIALIZED_EVENT：当Cache初始化数据后发送一个PathChildrenCacheEvent.Type#INITIALIZED事件</li></ul></blockquote><p>++public void addListener(PathChildrenCacheListener listener)++ 可以增加listener监听缓存的变化。</p><p>++getCurrentData()++ 方法返回一个<strong>List<childdata></childdata></strong> 对象，可以遍历所有的子节点。</p><p><strong>设置/更新、移除其实是使用client (CuratorFramework)来操作, 不通过PathChildrenCache操作：项目示例：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 监听子节点</span></span><br><span class="line"><span class="comment">    * 子节点新增，就往里面写数据</span></span><br><span class="line"><span class="comment">    * 子节点更新，</span></span><br><span class="line"><span class="comment">    * 子节点删除，</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">final</span> String path = ZKContant.ROOT_PATH + <span class="string">"/"</span> + strategy;</span><br><span class="line">       <span class="comment">//client是通过 CuratorFrameworkFactory.newClient创建的</span></span><br><span class="line">       <span class="keyword">final</span> PathChildrenCache cache = <span class="keyword">new</span> PathChildrenCache(client, path,<span class="keyword">true</span>);</span><br><span class="line">       ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">       cache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener()&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework curatorFramework, PathChildrenCacheEvent pathChildrenCacheEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               ChildData data = pathChildrenCacheEvent.getData();</span><br><span class="line">               <span class="keyword">switch</span> (pathChildrenCacheEvent.getType()) &#123;</span><br><span class="line">                   <span class="keyword">case</span> CHILD_ADDED:</span><br><span class="line">                       //向子节点写入信息 并更新信息</span><br><span class="line">                       childrenWatch.childrenAdd(data);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> CHILD_UPDATED:</span><br><span class="line">                       childrenWatch.childrenUpdate(data);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> CHILD_REMOVED:</span><br><span class="line">                       childrenWatch.childrenRemove(data);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, pool);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           cache.start();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           logger.<span class="keyword">error</span>(e.toString());</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>注意：如果new PathChildrenCache(client, PATH, true)中的参数cacheData值设置为false，则示例中的pathChildrenCacheEvent.getData().getData()、data.getData()将返回null，cache将不会缓存节点数据。</p><h5 id="Node-Cache"><a href="#Node-Cache" class="headerlink" title="Node Cache"></a>Node Cache</h5><p>Node Cache与Path Cache类似，Node Cache只是监听某一个特定的节点。它涉及到下面的三个类：</p><blockquote><ul><li>NodeCache - Node Cache实现类</li><li>NodeCacheListener - 节点监听器</li><li>ChildData - 节点数据</li></ul></blockquote><p><strong>注意：使用cache，依然要调用它的start()方法，使用完后调用close()方法。</strong></p><p>getCurrentData()将得到节点当前的状态，通过它的状态可以得到当前的值。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String path = ZKContant.ROOT_PATH + <span class="string">"/"</span> + strategy;</span><br><span class="line">        <span class="keyword">final</span> NodeCache cache = <span class="keyword">new</span> NodeCache(client, path, <span class="keyword">true</span>);</span><br><span class="line">        ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">        cache.getListenable().addListener(<span class="keyword">new</span> NodeCacheListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ChildData currentData = cache.getCurrentData();</span><br><span class="line">                <span class="keyword">if</span> (currentData != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    Properties props = ObjectUtil.toObject(currentData.getData());</span><br><span class="line">                    nodeWatch.handle(props, path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cache.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.<span class="keyword">error</span>(e.toString());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意：NodeCache只能监听一个节点的状态变化。</p><h5 id="Tree-Cache"><a href="#Tree-Cache" class="headerlink" title="Tree Cache"></a>Tree Cache</h5><p>Tree Cache可以监控整个树上的所有节点，类似于PathCache和NodeCache的组合，主要涉及到下面四个类：</p><blockquote><ul><li>TreeCache - Tree Cache实现类</li><li>TreeCacheListener - 监听器类</li><li>TreeCacheEvent - 触发的事件类</li><li>ChildData - 节点数据</li></ul></blockquote><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeCacheDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/cache"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws Exception &#123;</span><br><span class="line">TestingServer <span class="keyword">server</span> = <span class="keyword">new</span> TestingServer();</span><br><span class="line">CuratorFramework <span class="keyword">client</span> = CuratorFrameworkFactory.newClient(<span class="keyword">server</span>.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line"><span class="keyword">client</span>.start();</span><br><span class="line"><span class="keyword">client</span>.create().creatingParentsIfNeeded().forPath(PATH);</span><br><span class="line">TreeCache cache = <span class="keyword">new</span> TreeCache(<span class="keyword">client</span>, PATH);</span><br><span class="line">TreeCacheListener listener = (client1, event) -&gt;</span><br><span class="line">System.out.println(<span class="string">"事件类型："</span> + event.getType() +</span><br><span class="line"><span class="string">" | 路径："</span> + (<span class="keyword">null</span> != event.getData() ? event.getData().getPath() : <span class="keyword">null</span>));</span><br><span class="line">cache.getListenable().addListener(listener);</span><br><span class="line">cache.start();</span><br><span class="line"><span class="keyword">client</span>.setData().forPath(PATH, <span class="string">"01"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">client</span>.setData().forPath(PATH, <span class="string">"02"</span>.getBytes());</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">client</span>.delete().deletingChildrenIfNeeded().forPath(PATH);</span><br><span class="line">Thread.sleep(<span class="number">1000</span> * <span class="number">2</span>);</span><br><span class="line">cache.close();</span><br><span class="line"><span class="keyword">client</span>.close();</span><br><span class="line">System.out.println(<span class="string">"OK!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：TreeCache在初始化(调用start()方法)的时候会回调TreeCacheListener实例一个事TreeCacheEvent，而回调的TreeCacheEvent对象的Type为INITIALIZED，ChildData为null，此时event.getData().getPath()很有可能导致空指针异常，这里应该主动处理并避免这种情况。</strong></p><p>工作中主要使用了<strong>Path Cache</strong> 和<strong>Node Cache</strong>,一个监控子节点，一个监控节点。<br>系统中会有很多种策略，每种策略都会在根节点上创建一个ZKNode，当另一个系统启动的时候，也会检测这个策略节点，当这个策略节点信息改变的时候，监控客户端和服务端就回收到改变的通知。然后做出相应的处理。</p><p>大致如流程图所示：</p><p><img src="strategy流程图.jpg" alt="ZK"></p><hr><h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1><p>参考：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;目前进入一家，做仓库存储的公司，公司使用的技术也都是现在使用比较多的。以下只是个人记录，不做任何商业用途。&lt;/p&gt;
&lt;h1 id=&quot;Dubb
      
    
    </summary>
    
      <category term="分布式，Dubbo，Zookeeper" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%8CDubbo%EF%BC%8CZookeeper/"/>
    
    
      <category term="Dubbo，Zookeeper，分布式" scheme="http://yoursite.com/tags/Dubbo%EF%BC%8CZookeeper%EF%BC%8C%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈MQ</title>
    <link href="http://yoursite.com/2018/11/28/%E6%B5%85%E8%B0%88MQ/"/>
    <id>http://yoursite.com/2018/11/28/浅谈MQ/</id>
    <published>2018-11-28T01:00:00.000Z</published>
    <updated>2019-01-12T02:08:09.137Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>达到沟通目的才算有效沟通</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在上家公司工作的时候，ZStack架构的设计中用到RabbitMQ，让一个服务混乱的项目，变得简洁而清晰。所以对MQ又进一步进行研究。</p><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>我们可以把消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用。消息队列是分布式系统中重要的组件，<strong>使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。</strong><br>因为队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。消息队列管理器在将消息从它的源中继到它的目标时充当中间人。队列的主要目的是提供路由并保证消息的传递；如果发送消息时接收者不可用，消息队列会保留消息，直到可以成功地传递它。</p><hr><h2 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h2><p>使用消息队列主要有两点好处：<strong>1.通过异步处理提高系统性能（削峰、减少响应所需时间）;   2.降低系统耦合性。</strong></p><p><strong>(1) 通过异步处理提高系统性能（削峰、减少响应所需时间）</strong></p><p><img src="MQ1.jpg" alt="MQ"></p><p>如上图，<strong>在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。</strong></p><p>通过以上分析我们可以得出消息队列具有很好的<strong>削峰作用的功能——即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。</strong> 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p><p><img src="MQ2.jpg" alt="MQ"></p><p>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此使用<strong>消息队列进行异步处理之后，需要适当修改业务流程进行配合</strong>，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，<strong>需要在消息队列的订单消费者进程真正处理完该订单之后，</strong>甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p><p><strong>(2) 降低系统耦合性</strong><br>我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。</p><p>我们最常见的事件驱动架构类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所示：</p><p><img src="mq3.jpg" alt="MQ"></p><p><strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。</p><p><strong>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</strong></p><p>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</p><p>备注： <strong>在解耦这个特定业务环境下是使用发布-订阅模式的。除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。 另外，这两种消息模型是 JMS 提供的，AMQP 协议还提供了 5 种消息模型。</strong></p><hr><h2 id="消息队列带来的问题"><a href="#消息队列带来的问题" class="headerlink" title="消息队列带来的问题"></a>消息队列带来的问题</h2><blockquote><ul><li>系统可用性降低： 系统可用性在某种程度上降低，为什么这样说呢？在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！</li><li>系统复杂性提高： 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li>一致性问题：我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li></ul></blockquote><hr><h2 id="JMS-和AMQP比较"><a href="#JMS-和AMQP比较" class="headerlink" title="JMS 和AMQP比较"></a>JMS 和AMQP比较</h2><h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p><strong>JMS（JAVA Message Service,java消息服务）是java的消息服务，</strong>JMS的客户端之间可以通过JMS服务进行异步的消息传输。JMS（JAVA Message Service,Java消息服务）API是一个消息服务的标准或者说是规范，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。<strong>它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</strong></p><p> <strong>jms是消息队列中提供的一组API 接口，是提供的服务API。</strong><br> JMS和JDBC担任差不多的角色，用户都是根据相应的接口可以和实现了JMS的服务进行通信，进行相关的操作。<strong>ActiveMQ 就是基于 JMS 规范实现的。</strong></p><h4 id="JMS两种消息模型"><a href="#JMS两种消息模型" class="headerlink" title="JMS两种消息模型"></a>JMS两种消息模型</h4><p><strong>①点到点（P2P）模型</strong></p><p><img src="mq5.jpg" alt="MQ"></p><p>使用队列（Queue）<strong>作为消息通信载体；满足生产者与消费者模式，</strong>一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送100条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p><p><strong>② 发布/订阅（Pub/Sub）模型</strong></p><p><img src="mq6.jpg" alt="MQ"></p><p>发布订阅模型（Pub/Sub） 使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，<strong>该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。</strong></p><h4 id="JMS-五种不同的消息正文格式"><a href="#JMS-五种不同的消息正文格式" class="headerlink" title="JMS 五种不同的消息正文格式"></a>JMS 五种不同的消息正文格式</h4><p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p><blockquote><ul><li>StreamMessage –Java原始值的数据流</li><li>MapMessage–一套名称-值对</li><li>TextMessage–一个字符串对象</li><li>ObjectMessage–一个序列化的Java对象</li><li>BytesMessage–一个字节的数据流</li></ul></blockquote><h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p><strong>AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准 高级消息队列协议（二进制应用层协议</strong>），是应用层协议的一个开放标准,为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。RabbitMQ 就是基于 AMQP 协议实现的。</p><p><strong>AMQP模型</strong></p><p>AMPQ的消息模型示意图如下：</p><p><img src="mq7.jpg" alt="MQ"></p><p><strong>运作过程</strong></p><p>左边的客户端向右边的客户发送消息，流程如下：</p><blockquote><ol><li>获取Connection（客户端到MQ服务器的TCP链路） </li><li>获取Channel（逻辑层的链路，基于Conncetion） </li><li>定义交换器、队列</li><li>使用一个RoutingKey将队列绑定到一个交换器 </li><li>通过指定一个交换器和一个RoutingKey来消息发送到对应的队列上</li><li>接收方在接受时也是获取Connection，接着获取Channel，然后指定一个队列直接到它关心的队列上取消息，它对交换器、RoutingKey及如何绑定都不关心，到对应的对列上取消息就行了</li></ol></blockquote><p>名词解释<br>在该模型中，三个主要功能模块连接成一个处理链完成预期的功能：</p><blockquote><ul><li>exchange（交换器）：接收发布应用程序发送的消息，并根据一定的规则将这些消息路由到“消息队列”。</li><li>message queue（消息队列）：存储消息，直到这些消息被消费者安全处理完为止。</li><li>binding（绑定器）：定义了exchange和message queue之间的关联，提供路由规则。</li></ul></blockquote><p>Exchange本身不保持消息，只是起到路由的作用，Exchange接收消息生产者（MessageProducer）发送的消息根据不同的路由算法将消息发送往MessageQueue。MessageQueue会在消息不能被正常消费时缓存这些消息，具体的缓存策略由实现者决定，当MessageQueue与消息消费者（Messageconsumer）之间的连接通畅时，MessageQueue会将消息转发到consumer。</p><p>AMQP架构图如下：<br><img src="mq8.jpg" alt="MQ"></p><blockquote><p>该图（VirtualHost）用来指Exchange和MessageQueue组成的集合。它是一个虚拟概念，一个虚拟主机可以是一台服务器，还可以是由多台服务器组成的集群，还可以是一些虚拟机组成的集群，上面运行一些Exchange和MessageQueue。</p></blockquote><h3 id="JMS-vs-AMQP"><a href="#JMS-vs-AMQP" class="headerlink" title="JMS vs AMQP"></a>JMS vs AMQP</h3><p><img src="mq9.jpg" alt="MQ"></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>AMQP 为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。在 Java 体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平台、跨语言特性。</p><p>JMS 支持TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。</p><p>由于Exchange 提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。</p></blockquote><hr><h2 id="常见消息队列"><a href="#常见消息队列" class="headerlink" title="常见消息队列"></a>常见消息队列</h2><p><img src="mq10.jpg" alt="MQ"></p><hr><h2 id="MQ在实际项目中的使用"><a href="#MQ在实际项目中的使用" class="headerlink" title="MQ在实际项目中的使用"></a>MQ在实际项目中的使用</h2><h3 id="openStack中的MQ"><a href="#openStack中的MQ" class="headerlink" title="openStack中的MQ"></a>openStack中的MQ</h3><p>OpenStack遵循这样的设计原则：<strong>项目之间通过RESTful API进行通信；项目内部，不同服务进程之间的通信，则必须要通过消息总线。这种设计思想保证了各个项目对外提供服务的接口可以被不同类型的客户端高效支持，同时也保证了项目内部通信接口的可扩展性和可靠性，以支持大规模的部署</strong>。</p><p>软件从最初的面向过程，面向对象，再到面向服务（SOA），要求我们去考虑各个服务之间如何传递消息。借鉴硬件总线的概念，消息总线的模式被引入，顾名思义，一些服务向总线发送消息，其他服务从总线上获取消息。</p><p><strong>OpenStack oslo.messageing库实现了以下两种方式来完成项目内部各服务进程之间的通信：</strong></p><blockquote><ul><li>远程过程调用（RPC，Remote Procedure Call）</li></ul><p>通过远程过程调用，一个服务进程可以调用其他远程服务进程方法，并且有两种调用方式：call和cast。call 则是同步执行的，调用者会被阻塞直到结果返回；cast 则是异步执行，结果不会立刻被返回，调用者也不会被阻塞，但是调用者需要利用其他方式查询这次远程调用的结果。</p><ul><li>事件通知（Event Notification）</li></ul><p>某个服务进程可以把事件通知发送到消息总线上，该消息总线上所有对此类事件感兴趣的服务进程，都可以获得此事件通知并进行一步的处理，处理的结果并不会返回给事件发送者。这种通信方式，不但可以在同一个项目内部的各个服务进程之间发送通知，也可以实现跨项目之间的通知发送。Ceilometer就通过这种方式大量获取其他OpenStack项目的事件通知，从而进行计量和监控。</p></blockquote><p><strong>事件通知的方式在ZStack中也有体现：如下图所示：MQ用作消息总线</strong><br><img src="mq11.jpg" alt="MQ"></p><h3 id="OpenStack中的通信方式"><a href="#OpenStack中的通信方式" class="headerlink" title="OpenStack中的通信方式"></a>OpenStack中的通信方式</h3><p>OpenStack中所支持的消息总线类型中，大部分都是基于AMQP的。前面已经提到过了。</p><p><strong>基于AMPQ实现RPC</strong></p><p>这里引用别人画好的图：如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/4207742-fbd92febdf7d5738.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/676/format/webp" alt="基于AMPQ的RPC实现"></p><blockquote><ul><li>客户端发送一个请求消息给Exchange，指定routing key为”op_queue”，同时指明一个消息队列名用来获取响应，图中为”res_queue”，同时指明一个消息队列名用来获取响应。在图中为”res_queue”</li><li>Exchange把此消息转发到消息队列op_queue</li><li>消息队列op_queue把消息推送给服务端，服务端执行此RPC调用对应的任务。执行结束后，服务端把相应结果发送给消息队列，指明routing key为”res_queue”</li><li>Exchange 把此消息转发到消息队列res_queue</li><li>客户端从消息队列res_queue中获取响应。</li></ul></blockquote><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;达到沟通目的才算有效沟通&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在上家公司工作的时候，ZStack架
      
    
    </summary>
    
      <category term="MQ" scheme="http://yoursite.com/categories/MQ/"/>
    
    
      <category term="MQ，Java" scheme="http://yoursite.com/tags/MQ%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>此刻小记</title>
    <link href="http://yoursite.com/2018/11/24/%E6%AD%A4%E5%88%BB%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/11/24/此刻小记/</id>
    <published>2018-11-24T01:00:00.000Z</published>
    <updated>2018-11-26T01:05:07.094Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>吴军所写的《态度》一书真的不错</p></blockquote><hr><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>自从上家公司离职，最近一直在找工作，失业已经两周的时间了，这种没有事情做的感觉真的挺难受，就像随风飘摇的蒲公英一样，什么事都缺少趣味。除了学习看书，基本上没有事情可以干。不过这段时间也给我很多思考的时间，review之前工作中暴露的问题，当时是怎么做的，为什么这么做，有没有更好的办法。挺后悔前一两个月没有把态度摆正，以为自己是个应届毕业生，就可以不那么着急开始自己的工作，如果摆正自己学到的应该更多，但是<strong>我真的是特别珍惜上家公司的工作</strong>。离开就离开了，<strong>自己不要丢掉信心就好。</strong> </p><p>说实话这是我这一年来学到最多，感觉视野一下子宽了很多。从学生到一个社会人，职场人，中间遇到过很多自己以前不愿意做的事情。当你见识到比自己厉害的人后，你就会发现自己的弱小和无知 <strong>。那种想要超越别人的欲望愈发的强烈。</strong></p><p><code>懒惰已经成为前进的阻碍。</code>现在我才觉得自己真的挺懒的，规划的事情总是不能按当初想的完成。有一次一天给自己定好几个闹钟，提醒自己该做什么了。这段时间也正在努力让自己勤快一点。不想让自己失望。</p><p>工作这段时间挺感谢一个人的，那就是我师傅。第一个让我感觉强大的人，前几个月可以说是手把手教我敲代码。他的负责任的态度和他渊博的知识，帮助我很多。也同时感谢QBackup产品线的各位，让我有了一段难忘的经历。感谢大家的帮助。</p><hr><h2 id="迷茫的时候你会做什么？"><a href="#迷茫的时候你会做什么？" class="headerlink" title="迷茫的时候你会做什么？"></a>迷茫的时候你会做什么？</h2><p><strong>这是我在熊总即将离开公司的时候问他的一个问题。</strong> 熊总是我们产品部门的老大，也是我招我进公司的一个重要的人。他因为自己对技术的追求，离开自己亲手创办的公司，现在好像在美团工作。</p><p>听说他要离开公司，真的很诧异，有点惊呆了。他是一个幽默又特别好相处的一个人。我真的特别喜欢他，也特别感谢他让我有机会进入公司。知道他要离开的消息后，我就写了一封邮件，一来表达我内心的感谢，二来解答自己内心的疑惑。</p><p>当时这个问题还在公司的群里面谈论了一番，感觉自己提出了一个许多人都遇到过的问题，挺开心的。从他的回复和群中讨论大概结果如下：</p><blockquote><p>这个时代的焦虑更多的来自于对自身不足的不满，解决问题的最好办法就是更加的努力，花时间去想看不见摸不着的东西，不如指定一个更加长期的，艰苦的学习计划，提高能力的同时也磨炼自己的心性。</p></blockquote><p><strong>每个人对自己的鄙视都是对自己不足的不满。</strong> 迷茫的时候想的再多都是毫无作用，空想只会让你更加的迷茫，不如更加艰苦的学习（不是疯狂加班），我相信通过这种方式给予自己信心，也就慢慢的找到前进的方向。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>一个正确的态度是非常有必要的</strong>。工作中要把态度摆正，无论这个功能多简单或者多难都要尽力做到出人意料的精彩。</p><p><strong>一个人要有表达自己观点的勇气</strong>，新人也好，菜鸡也罢，都要有勇气面对他人，表达自己。</p><p><strong>学会沟通。</strong> 项目的进度或者困难都要给自己的上级进行及时的答复，不要每次都等到别人来问你工作的进度，你遇到什么困难等。</p><p><strong>自信。</strong> 自信对待代码，自信对待公司的人，自信对待自己。</p><hr><h2 id="态度与自信"><a href="#态度与自信" class="headerlink" title="态度与自信"></a>态度与自信</h2><p>无聊的时候我追了一部剧《将夜》，虽然有人说一般般，但是我感觉还挺好。</p><p>我最记忆犹新的一段是，作为一个 直通十窍，书院第十三个进入书院二层楼的人，又是世上最强符道之人的唯一徒弟，修炼速度就是个废柴的主人公宁缺。一度自信全无。</p><p>可是人生哪有什么顺顺利利，挫折总会克服，又总会到来。在在意他的人的帮助下，慢慢的把失去的信心找了回来，画出了<strong>人生的第一道符</strong>。</p><p><strong>态度和自信</strong> 人生路上必不可少。带着他们 我在未来的某一刻也会画出自己人生的第一道符。</p><blockquote><p>文采拙劣，敬请原谅</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;吴军所写的《态度》一书真的不错&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h2&gt;&lt;p&gt;自从上家公司离职，最近一直在找
      
    
    </summary>
    
      <category term="所思所想" scheme="http://yoursite.com/categories/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/"/>
    
    
      <category term="所思所想" scheme="http://yoursite.com/tags/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性</title>
    <link href="http://yoursite.com/2018/11/19/Java8/"/>
    <id>http://yoursite.com/2018/11/19/Java8/</id>
    <published>2018-11-19T01:00:00.000Z</published>
    <updated>2018-11-23T07:33:25.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>没有工作的生活感觉真的无聊</p></blockquote><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>自从毕业进入上家公司，感受到自己的无知和技术更新迭代速度是真的快。Java8中许多新特性都在ZStack中有所使用。故这里对Java8新特性进行总结一下。</p><p>近几年Java的发展的确挺快的，修改了许多令开发人员诟病的特性。正在逐渐吸收着其他语言的优点。我相信Java仍是许多项目中不可或缺的语言。前景仍然看好。</p><hr><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>官网表述：<br>Lambda表达式是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：函数式开发者非常熟悉这些概念。很多JVM平台上的语言（Groovy、Scala等）从诞生之日就支持Lambda表达式，但是早期Java开发者没有选择，只能使用<code>匿名内部类</code>代替Lambda表达式。</p><p>最简单的Lambda表达式可由逗号分隔的参数列表、-&gt;符号和语句块组成，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( e -&gt; System.out.println( e ) );</span><br></pre></td></tr></table></figure><p>在上面这个代码中的参数e的类型是由编译器<code>推理</code>得出的，你也可以显式指定该参数的类型，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( ( String e ) -&gt; System.out.println( e ) );</span><br></pre></td></tr></table></figure><p>如果Lambda表达式需要更复杂的语句块，则可以使用花括号将该语句块括起来，类似于Java中的函数体，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( e -&gt; &#123;</span><br><span class="line">    System.out.print( e );</span><br><span class="line">    System.out.print( e );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>Lambda表达式可以引用类成员和局部变量（会将这些变量隐式得转换成final的），例如下列两个代码块的效果完全相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String separator = <span class="string">","</span>;</span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( </span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String separator = <span class="string">","</span>;</span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( </span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure><p>Lambda表达式有返回值，返回值的类型也由编译器推理得出。如果Lambda表达式中的语句块只有一行，则可以不用使用return语句，下列两个代码片段效果相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).sort( ( e1, e2 ) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> result = e1.compareTo( e2 );</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>Java8实现Lambda表达式其实就是让<code>行为参数化</code>，就是把一个行为当做方法的参数，以此达到和以前版本进行兼容的目的。</p><blockquote><p><strong>注意：</strong><br>Java 8的Lambda和匿名类和闭包是有一些不同的地方。<br>用科学的说法来说，闭包就是一个函数的实例，且它可以无限制地访问那个函数的非本地变量。例如，闭包可以作为参数传递给另一个函数。它也可以访问和修改其作用域之外的变量。<br>Java 8的Lambda和匿名类可以做类似于闭包的事情：它们可以作为参数传递给方法，并且可以访问其作用域之外的变量。但有一个<code>限制</code>：它们不能修改定义Lambda的方法的局部变量的内容。这些变量必须是<code>隐式最终</code>的。可以认为Lambda是对值封闭，而不是对变量封闭。这种限制存在的原因在于<code>局部变量保存在栈</code>上，并且隐式表示它们仅限于其所在线程。如果允许捕获可改变的局部变量，就会引发造成线程不安全的新的可能性，而这是我们不想看到的。</p></blockquote><hr><h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><p>Lambda的设计者们为了让现有的功能与Lambda表达式良好兼容，考虑了很多方法，于是产生了函数接口这个概念。<br><code>函数接口</code>指的是只有<code>一个函数的接口</code>，这样的接口可以隐式转换为Lambda表达式。java.lang.Runnable和java.util.concurrent.Callable是函数式接口的最佳例子。在实践中，函数式接口非常脆弱：只要某个开发者在该接口中添加一个函数，则该接口就不再是函数式接口进而导致编译失败。为了克服这种代码层面的脆弱性，并显式说明某个接口是函数式接口，Java 8 提供了一个特殊的注解<code>@FunctionalInterface</code>（Java 库中的所有相关接口都已经带有这个注解了），举个简单的函数式接口的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Functional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你用<code>@FunctionalInterface</code>定义了一个接口，而它却不是函数式接口的话，编译器将返回一个提示原因的错误。例如，错误消息可能是“Multiple non-overriding abstract methods found in interface Foo”，表明存在多个抽象方法。<br>看下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cumputer</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">start</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">communication</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demoInterface</span><span class="params">(Cumputer cumputer)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        demoInterface(name -&gt; &#123;</span><br><span class="line">            name += <span class="string">"a"</span>;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个时候 name += “a”这句就会报错，Lambda表达式无法推断出name的参数类型。如果指定name的类型。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        demoInterface((String name)-&gt; &#123;</span><br><span class="line">            name += <span class="string">"a"</span>;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>编译器会提示：<code>Multiple non-overriding abstract methods found in interface Foo</code>错误。函数接口只能允许有一个方法。所以<code>@FunctionalInterface</code>就可以提示开发者在修改接口的时候，这个接口是否允许多个方法行为。</p><p>请注意，<code>@FunctionalInterface</code>不是必需的，但对于为此设计的接口而言，使用它是比较好的做法。它就像是@Override标注表示方法被重写了。并且<code>默认方法</code>和<code>静态方法</code>不会破坏函数式接口的定义，因此如下的代码是合法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionalDefaultMethods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h2><p>默认方法使得接口有点类似traits，不过要实现的目标不一样。默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。</p><p>默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Interfaces now allow default methods, the implementer may or </span></span><br><span class="line">    <span class="comment">// may not implement (override) them.</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">notRequired</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Default implementation"</span>; </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给java.util.Collection接口添加新方法，如stream()、parallelStream()、forEach()和removeIf()等等。</p><hr><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。<br>方法引用可以使用<code>::</code>。<br>定义了4个方法的Car这个类作为例子，区分Java中支持的4种不同的方法引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">create</span><span class="params">( <span class="keyword">final</span> Supplier&lt; Car &gt; supplier )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;              </span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">( <span class="keyword">final</span> Car car )</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Collided "</span> + car.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">( <span class="keyword">final</span> Car another )</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Following the "</span> + another.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repair</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        System.out.println( <span class="string">"Repaired "</span> + <span class="keyword">this</span>.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种方法引用是构造器引用，它的语法是Class::new，或者更一般的Class&lt; T &gt;::new。请注意构造器没有参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Car car = Car.create( Car::<span class="keyword">new</span> );</span><br><span class="line"><span class="keyword">final</span> List&lt; Car &gt; cars = Arrays.asList( car );</span><br></pre></td></tr></table></figure><p>第二种方法引用是静态方法引用，它的语法是Class::static_method。请注意这个方法接受一个Car类型的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.forEach( Car::collide );</span><br></pre></td></tr></table></figure><p>第三种方法引用是特定类的任意对象的方法引用，它的语法是Class::method。请注意，这个方法没有参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.forEach( Car::repair );</span><br></pre></td></tr></table></figure><p>最后，第四种方法引用是特定对象的方法引用，它的语法是instance::method。请注意，这个方法接受一个Car类型的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Car police = Car.create( Car::<span class="keyword">new</span> );</span><br><span class="line">cars.forEach( police::follow );</span><br></pre></td></tr></table></figure><hr><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。</p><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p><code>Stream</code> 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。<br>Stream 就如同一个<code>迭代器（Iterator）</code>，<code>单向</code>，<code>不可往复</code>，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。<br>而和迭代器又不同的是，Stream 可以<code>并行化</code>操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的<code>线程</code>中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的<code>Fork/Join 框架</code>（JSR166y）来拆分任务和加速处理过程。</p><h3 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤：<br>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。</p><p><strong>流管道 (Stream Pipeline) 的构成</strong><br><img src="stream.jpg" alt="1"></p><p><strong>流的操作类型分为三种：</strong></p><blockquote><ul><li>Intermediate（中间）：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li><li>Terminal（终点）：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果。</li><li>Short-Circuiting（短循环）：1.对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。<br>2.对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。<br>3.当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。</li></ul></blockquote><p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = widgets.stream()</span><br><span class="line">.filter(w -&gt; w.getColor() == RED)</span><br><span class="line"> .mapToInt(w -&gt; w.getWeight())</span><br><span class="line"> .sum();</span><br></pre></td></tr></table></figure><p>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。</p><p>流操作有两个重要的特点：</p><blockquote><ul><li>流水线——很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。这让我们下一章中的一些优化成为可能，如延迟和短路。流水线的操作可以看作对数据源进行数据库式查询。</li><li>内部迭代——与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li></ul></blockquote><h3 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h3><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。<br><strong>Intermediate：</strong></p><blockquote><p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、skip、 parallel、 sequential、 unordered</p></blockquote><p><strong>Terminal：</strong></p><blockquote><p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p></blockquote><p><strong>Short-circuiting：</strong></p><blockquote><p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p></blockquote><table><thead><tr><th>操作</th><th>类型</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td><code>map</code></td><td>中间</td><td><code>Stream&lt;R&gt;</code></td><td>map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。</td></tr><tr><td><code>flatMap</code></td><td>中间</td><td><code>Stream&lt;R&gt;</code></td><td>一对多， flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，看下面示例。</td></tr><tr><td><code>filter</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td>filter 对原始 Stream 进行某项过滤，通过过滤的元素被留下来生成一个新 Stream。</td></tr><tr><td><code>limit</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td>limit 返回 Stream 的前面 n 个元素；</td></tr><tr><td><code>skip</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td>skip 则是扔掉前 n 个元素</td></tr><tr><td><code>distinct</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td>找出不重复的单词</td></tr><tr><td><code>sorted</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序</td></tr><tr><td><code>min/max</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)</td></tr><tr><td><code>forEach</code></td><td>终端</td><td><code>void</code></td><td>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。</td></tr><tr><td><code>findFirst</code></td><td>终端</td><td><code>Optional&lt;T&gt;</code></td><td>返回 Stream 的第一个元素，或者空</td></tr><tr><td><code>reduce</code></td><td>终端</td><td><code>Optional&lt;T&gt;</code></td><td>主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。</td></tr><tr><td><code>findAny</code></td><td>终端</td><td><code>Optional&lt;T&gt;</code></td><td>查找到任何一个就返回</td></tr><tr><td><code>collect</code></td><td>终端</td><td><code>R</code></td><td>收集结果</td></tr><tr><td><code>count</code></td><td>终端</td><td><code>long</code></td><td>计算个数</td></tr><tr><td><code>allMatch</code></td><td>终端</td><td><code>boolean</code></td><td>Stream 中全部元素符合传入的断言（ predicate），返回 true</td></tr><tr><td><code>anyMatch</code></td><td>终端</td><td><code>boolean</code></td><td>Stream 中只要有一个元素符合传入的断言predicate，返回 true</td></tr><tr><td><code>noneMatch</code></td><td>终端</td><td><code>boolean</code></td><td>Stream 中没有一个元素符合传入的 断言predicate，返回 true</td></tr></tbody></table><p>flatMap示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class="line"> Arrays.asList(<span class="number">1</span>),</span><br><span class="line"> Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"> );</span><br><span class="line">Stream&lt;Integer&gt; outputStream = inputStream.</span><br><span class="line">flatMap((childList) -&gt; childList.stream());</span><br></pre></td></tr></table></figure><p>reduce 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串连接，concat = "ABCD"</span></span><br><span class="line">String concat = Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>).reduce(<span class="string">""</span>, String::concat); </span><br><span class="line"><span class="comment">// 求最小值，minValue = -3.0</span></span><br><span class="line"><span class="keyword">double</span> minValue = Stream.of(-<span class="number">1.5</span>, <span class="number">1.0</span>, -<span class="number">3.0</span>, -<span class="number">2.0</span>).reduce(Double.MAX_VALUE, Double::min); </span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 有起始值</span></span><br><span class="line"><span class="keyword">int</span> sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 无起始值</span></span><br><span class="line">sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(Integer::sum).get();</span><br><span class="line"><span class="comment">// 过滤，字符串连接，concat = "ace"</span></span><br><span class="line">concat = Stream.of(<span class="string">"a"</span>, <span class="string">"B"</span>, <span class="string">"c"</span>, <span class="string">"D"</span>, <span class="string">"e"</span>, <span class="string">"F"</span>).</span><br><span class="line"> filter(x -&gt; x.compareTo(<span class="string">"Z"</span>) &gt; <span class="number">0</span>).</span><br><span class="line"> reduce(<span class="string">""</span>, String::concat);</span><br></pre></td></tr></table></figure><h3 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h3><p>即Collectors类提供的工厂方法（例如groupingBy）创建的收集器。它们主要提供了三大功能：</p><blockquote><ul><li>将流元素归约和汇总为一个值 </li><li>元素分组 </li><li>元素分区</li></ul></blockquote><p>Collectors类的静态工厂方法:</p><table><thead><tr><th>工厂方法</th><th>返回类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>toList</td><td><code>List&lt;T&gt;</code></td><td>把流中所有项目收集到一个List</td><td><code>List&lt;Dish&gt; dishes = menuStream.collect(toList());</code></td></tr><tr><td>toSet</td><td><code>Set&lt;T&gt;</code></td><td>把流中所有项目收集到一个Set，删除重复项</td><td><code>Set&lt;Dish&gt; dishes = menuStream.collect(toSet());</code></td></tr><tr><td>toCollection</td><td><code>Collection&lt;T&gt;</code></td><td>把流中所有项目收集到给定的供应源创建的集合</td><td><code>Collection&lt;Dish&gt; dishes = menuStream.collect(toCollection(),ArrayList::new);</code></td></tr><tr><td>counting</td><td><code>Long</code></td><td>计算流中元素的个数</td><td><code>long howManyDishes = menuStream.collect(counting());</code></td></tr><tr><td>summingInt</td><td><code>Integer</code></td><td>对流中项目的一个整数属性求和</td><td><code>int totalCalories = menuStream.collect(summingInt(Dish::getCalories));</code></td></tr><tr><td>averagingInt</td><td><code>Double</code></td><td>计算流中项目Integer属性的平均值</td><td><code>double avgCalories =menuStream.collect(averagingInt(Dish::getCalories));</code></td></tr><tr><td>summarizingInt</td><td><code>IntSummaryStatistics</code></td><td>收集关于流中项目Integer属性的统计值，例如最大、最小、总和与平均值</td><td><code>IntSummaryStatistics menuStatistics = menuStream.collect(summarizingInt(Dish::getCalories));</code></td></tr><tr><td>joining</td><td><code>Sring</code></td><td>连接对流中每个项目调用toString方法所生成的字符串</td><td><code>String shortMenu = menuStream.map(Dish::getName).collect(joining(&quot;, &quot;));</code></td></tr><tr><td>groupingBy</td><td><code>Map&lt;K, List&lt;T&gt;&gt;</code></td><td>根据项目的一个属性的值对流中的项目作问组，并将属性值作为结果Map的键</td><td><code>Map&lt;Dish.Type,List&lt;Dish&gt;&gt; dishesByType = menuStream.collect(groupingBy(Dish::getType));</code></td></tr><tr><td>partitioningBy</td><td><code>Map&lt;Boolean,List&lt;T&gt;&gt;</code></td><td>根据对流中每个项目应用谓词的结果来对项目进行分区</td><td><code>Map&lt;Boolean,List&lt;Dish&gt;&gt; vegetarianDishes = menuStream.collect(partitioningBy(Dish::isVegetarian));</code></td></tr></tbody></table><blockquote><p>在Java 7之前，并行处理数据集合非常麻烦。第一，你得明确地把包含数据的数据结构分成若干子部分。第二，你要给每个子部分分配一个独立的线程。第三，你需要在恰当的时候对它们进行同步来避免不希望出现的竞争条件，等待所有线程完成，最后把这些部分结果合并起来。Java 7引入了一个叫作分支/合并的框架，让这些操作更稳定、更不易出错。<br>我们简要地提到了Stream接口可以让你非常方便地处理它的元素：可以通过对收集源调用parallelStream方法来把集合转换为并行流。并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。这样一来，你就可以自动把给定操作的工作负荷分配给多核处理器的所有内核，让它们都忙起来。</p></blockquote><hr><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Java应用中最常见的bug就是空值异常。在Java 8之前，Google Guava引入了Optionals类来解决NullPointerException，从而避免源码被各种null检查污染，以便开发者写出更加整洁的代码。Java 8也将Optional加入了官方库。<br>你现在可以通过一种数据类型表示显式缺失的值——使用空指针的问题在于你无法确切了解出现空指针的原因，它是预期的情况，还是说由于之前的某一次计算出错导致的一个偶然性的空值，有了Optional之后你就不需要再使用之前容易出错的空指针来表示缺失的值了。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>empty</td><td>返回一个空的Optional实例</td></tr><tr><td>filter</td><td>如果值存在并且满足提供的谓词，就返回包含该值的Optional对象；否则返回一个空的Optional对象</td></tr><tr><td>flatMap</td><td>如果值存在，就对该值执行提供的mapping函数调用，返回一个Optional类型的值，否则就返回一个空的Optional对象</td></tr><tr><td>get</td><td>如果该值存在，将该值用Optional封装返回，否则抛出一个NoSuchElementException异常</td></tr><tr><td>ifPresent</td><td>如果值存在，就执行使用该值的方法调用，否则什么也不做</td></tr><tr><td>isPresent</td><td>如果值存在就返回true，否则返回false</td></tr><tr><td>map</td><td>如果值存在，就对该值执行提供的mapping函数调用</td></tr><tr><td>of</td><td>将指定值用Optional封装之后返回，如果该值为null，则抛出一个NullPointerException异常</td></tr><tr><td>ofNullable</td><td>将指定值用Optional封装之后返回，如果该值为null，则返回一个空的Optional对象</td></tr><tr><td>orElse</td><td>如果有值则将其返回，否则返回一个默认值</td></tr><tr><td>orElseGet</td><td>如果有值则将其返回，否则返回一个由指定的Supplier接口生成的值</td></tr><tr><td>orElseThrow</td><td>如果有值则将其返回，否则抛出一个由指定的Supplier接口生成的异常</td></tr></tbody></table><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt; String &gt; fullName = Optional.ofNullable( <span class="keyword">null</span> );</span><br><span class="line">System.out.println( <span class="string">"Full Name is set? "</span> + fullName.isPresent() );        </span><br><span class="line">System.out.println( <span class="string">"Full Name: "</span> + fullName.orElseGet( () -&gt; <span class="string">"[none]"</span> ) ); </span><br><span class="line">System.out.println( fullName.map( s -&gt; <span class="string">"Hey "</span> + s + <span class="string">"!"</span> ).orElse( <span class="string">"Hey Stranger!"</span> )</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Full Name is set? <span class="keyword">false</span></span><br><span class="line">Full Name: [none]</span><br><span class="line">Hey Stranger!</span><br></pre></td></tr></table></figure><hr><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><p>Java 8中引入全新的日期和时间API：<br>日期、时间、时区、Instant（跟日期类似但是精确到纳秒）、duration（持续时间）和时钟操作的类。</p><blockquote><ul><li>LocalDate</li><li>LocalTime</li><li>LocalDateTime</li><li>Instant</li><li>Duration</li><li>Period</li></ul></blockquote><p>在Java8之前的版本中，日期时间API存在很多的问题，比如：</p><blockquote><ul><li>线程安全问题：java.util.Date是非线程安全的，所有的日期类都是可变的；</li><li>设计很差：在java.util和java.sql的包中都有日期类，此外，用于格式化和解析的类在java.text包中也有定义。而每个包将其合并在一起，也是不合理的；</li><li>时区处理麻烦：日期类不提供国际化，没有时区支持，因此Java中引入了java.util.Calendar和Java.util.TimeZone类；</li></ul></blockquote><p>Java8重新设计了日期时间相关的API，Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。在java.util.time包中常用的几个类有：</p><blockquote><p>它通过指定一个时区，然后就可以获取到当前的时刻，日期与时间。Clock可以替换System.currentTimeMillis()与TimeZone.getDefault()<br>Instant:一个instant对象表示时间轴上的一个时间点，Instant.now()方法会返回当前的瞬时点（格林威治时间）；<br>Duration:用于表示两个瞬时点相差的时间量；<br>LocalDate:一个带有年份，月份和天数的日期，可以使用静态方法now或者of方法进行创建；<br>LocalTime:表示一天中的某个时间，同样可以使用now和of进行创建； LocalDateTime：兼有日期和时间；<br>ZonedDateTime：通过设置时间的id来创建一个带时区的时间；<br>DateTimeFormatter：日期格式化类，提供了多种预定义的标准格式；</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Clock clock = Clock.systemUTC();</span><br><span class="line">        Instant instant = clock.instant();</span><br><span class="line">        System.out.println(instant.toString());</span><br><span class="line"></span><br><span class="line">        LocalDate localDate = LocalDate.now();</span><br><span class="line">        System.out.println(localDate.toString());</span><br><span class="line"></span><br><span class="line">        LocalTime localTime = LocalTime.now();</span><br><span class="line">        System.out.println(localTime.toString());</span><br><span class="line"></span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        System.out.println(localDateTime.toString());</span><br><span class="line"></span><br><span class="line">        ZonedDateTime zonedDateTime = ZonedDateTime.now(ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line">        System.out.println(zonedDateTime.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p>Future是Java 5添加的类，用来描述一个异步计算的结果，但是获取一个结果时方法较少,要么通过轮询isDone，确认完成后，调用get()获取值，要么调用get()设置一个超时时间。但是这个get()方法会阻塞住调用线程，这种阻塞的方式显然和我们的异步编程的初衷相违背。<br>为了解决这个问题，JDK吸收了guava的设计思想，加入了Future的诸多扩展功能形成了CompletableFuture。</p><p>请看：</p><blockquote><p><a href="https://www.jianshu.com/p/6f3ee90ab7d3" target="_blank" rel="noopener">CompletableFuture 详解</a></p></blockquote><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java8 的新特性给开发带来了很大的便利性，ZStack中用到了很多Java8的新特性。以前看Java8的新特性都是一知半解，因为没有在项目中应用到，当使用过以后，你会发现理解起来也是挺容易的。</p><blockquote><p>实践才是最快的学习方式</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;没有工作的生活感觉真的无聊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;自从毕业进入上家公司，感受到自己的
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>zstack的自动化测试</title>
    <link href="http://yoursite.com/2018/11/01/zstack%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2018/11/01/zstack的自动化测试/</id>
    <published>2018-10-31T18:09:00.000Z</published>
    <updated>2018-11-15T08:25:20.071Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>把简单的事情做得出人意料的精彩</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>zstack是什么？<br>zstack是一个IaaS软件，可以通过API灵活的管理存储，网络，路由，计算，KVM等资源。<br>什么是自动化测试？<br>我们可以简单的理解为前期通过人工编码完成框架，后期来解放人力并自动完成规定的测试。在测试人员测试之前，开发人员已经完成很大部分的功能测试，测试人员只需要调用后者运行代码就可以看到测试结果。具体实现是：在自动化测试框架下，开发人员对自己负责的模块要达到基本覆盖测试代码。</p><h2 id="zstack的Integration-Test框架"><a href="#zstack的Integration-Test框架" class="headerlink" title="zstack的Integration Test框架"></a>zstack的Integration Test框架</h2><p>作为产品型的IaaS项目，ZStack非常重视测试，我们要求每个功能、用户场景都有对应的测试用例覆盖。ZStack的测试有多种维度，本文介绍后端Java开发人员使用的基于模拟器的Integration Test框架。</p><p>ZStack的运行过程中，实际上是管理节点进程(Java编写)通过HTTP PRC调用控制部署在数据中心各物理设备上的Agent（Python或Golang编写），如下图：<br><img src="test.jpg" alt="1"><br>在Integreation Test中，我们用模拟器（通过内嵌的Jetty Server）实现所有Agent HTTP RPC接口，每个用例的JVM进程就是一个自包含的ZStack环境，如图：<br><img src="Jetty.jpg" alt="1"></p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneVmBasicLifeCycleCase</span> <span class="keyword">extends</span> <span class="title">SubCase</span> </span>&#123;</span><br><span class="line">    EnvSpec env</span><br><span class="line"></span><br><span class="line">    def DOC = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">test a VM's start/stop/reboot/destroy/recover operations </span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        spring &#123;</span><br><span class="line">            sftpBackupStorage()</span><br><span class="line">            localStorage()</span><br><span class="line">            virtualRouter()</span><br><span class="line">            securityGroup()</span><br><span class="line">            kvm()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">environment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        env = OneVmBasicEnv.env()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        env.create &#123;</span><br><span class="line">            testStopVm()</span><br><span class="line">            testStartVm()</span><br><span class="line">            testRebootVm()</span><br><span class="line">            testDestroyVm()</span><br><span class="line">            testRecoverVm()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testRecoverVm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VmSpec spec = env.specByName(<span class="string">"vm"</span>)</span><br><span class="line"></span><br><span class="line">        VmInstanceInventory inv = recoverVmInstance &#123;</span><br><span class="line">            uuid = spec.inventory.uuid</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> inv.state == VmInstanceState.Stopped.toString()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// confirm the vm can start after being recovered</span></span><br><span class="line">        testStartVm()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testDestroyVm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VmSpec spec = env.specByName(<span class="string">"vm"</span>)</span><br><span class="line"></span><br><span class="line">        KVMAgentCommands.DestroyVmCmd cmd = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">        env.afterSimulator(KVMConstant.KVM_DESTROY_VM_PATH) &#123; rsp, HttpEntity&lt;String&gt; e -&gt;</span><br><span class="line">            cmd = JSONObjectUtil.toObject(e.body, KVMAgentCommands.DestroyVmCmd.class)</span><br><span class="line">            <span class="keyword">return</span> rsp</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        destroyVmInstance &#123;</span><br><span class="line">            uuid = spec.inventory.uuid</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> cmd != <span class="keyword">null</span></span><br><span class="line">        <span class="keyword">assert</span> cmd.uuid == spec.inventory.uuid</span><br><span class="line">        VmInstanceVO vmvo = dbFindByUuid(cmd.uuid, VmInstanceVO.class)</span><br><span class="line">        <span class="keyword">assert</span> vmvo.state == VmInstanceState.Destroyed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testRebootVm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// reboot = stop + start</span></span><br><span class="line">        VmSpec spec = env.specByName(<span class="string">"vm"</span>)</span><br><span class="line"></span><br><span class="line">        KVMAgentCommands.StartVmCmd startCmd = <span class="keyword">null</span></span><br><span class="line">        KVMAgentCommands.StopVmCmd stopCmd = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">        env.afterSimulator(KVMConstant.KVM_STOP_VM_PATH) &#123; rsp, HttpEntity&lt;String&gt; e -&gt;</span><br><span class="line">            stopCmd = JSONObjectUtil.toObject(e.body, KVMAgentCommands.StopVmCmd.class)</span><br><span class="line">            <span class="keyword">return</span> rsp</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        env.afterSimulator(KVMConstant.KVM_START_VM_PATH) &#123; rsp, HttpEntity&lt;String&gt; e -&gt;</span><br><span class="line">            startCmd = JSONObjectUtil.toObject(e.body, KVMAgentCommands.StartVmCmd.class)</span><br><span class="line">            <span class="keyword">return</span> rsp</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        VmInstanceInventory inv = rebootVmInstance &#123;</span><br><span class="line">            uuid = spec.inventory.uuid</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> startCmd != <span class="keyword">null</span></span><br><span class="line">        <span class="keyword">assert</span> startCmd.vmInstanceUuid == spec.inventory.uuid</span><br><span class="line">        <span class="keyword">assert</span> stopCmd != <span class="keyword">null</span></span><br><span class="line">        <span class="keyword">assert</span> stopCmd.uuid == spec.inventory.uuid</span><br><span class="line">        <span class="keyword">assert</span> inv.state == VmInstanceState.Running.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testStartVm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VmSpec spec = env.specByName(<span class="string">"vm"</span>)</span><br><span class="line"></span><br><span class="line">        KVMAgentCommands.StartVmCmd cmd = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">        env.afterSimulator(KVMConstant.KVM_START_VM_PATH) &#123; rsp, HttpEntity&lt;String&gt; e -&gt;</span><br><span class="line">            cmd = JSONObjectUtil.toObject(e.body, KVMAgentCommands.StartVmCmd.class)</span><br><span class="line">            <span class="keyword">return</span> rsp</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        VmInstanceInventory inv = startVmInstance &#123;</span><br><span class="line">            uuid = spec.inventory.uuid</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> cmd != <span class="keyword">null</span></span><br><span class="line">        <span class="keyword">assert</span> cmd.vmInstanceUuid == spec.inventory.uuid</span><br><span class="line">        <span class="keyword">assert</span> inv.state == VmInstanceState.Running.toString()</span><br><span class="line"></span><br><span class="line">        VmInstanceVO vmvo = dbFindByUuid(cmd.vmInstanceUuid, VmInstanceVO.class)</span><br><span class="line">        <span class="keyword">assert</span> vmvo.state == VmInstanceState.Running</span><br><span class="line">        <span class="keyword">assert</span> cmd.vmInternalId == vmvo.internalId</span><br><span class="line">        <span class="keyword">assert</span> cmd.vmName == vmvo.name</span><br><span class="line">        <span class="keyword">assert</span> cmd.memory == vmvo.memorySize</span><br><span class="line">        <span class="keyword">assert</span> cmd.cpuNum == vmvo.cpuNum</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> test socketNum, cpuOnSocket</span></span><br><span class="line">        <span class="keyword">assert</span> cmd.rootVolume.installPath == vmvo.rootVolumes.installPath</span><br><span class="line">        <span class="keyword">assert</span> cmd.useVirtio</span><br><span class="line">        vmvo.vmNics.each &#123; nic -&gt;</span><br><span class="line">            KVMAgentCommands.NicTO to = cmd.nics.find &#123; nic.mac == it.mac &#125;</span><br><span class="line">            <span class="keyword">assert</span> to != <span class="keyword">null</span>: <span class="string">"unable to find the nic[mac:$&#123;nic.mac&#125;]"</span></span><br><span class="line">            <span class="keyword">assert</span> to.deviceId == nic.deviceId</span><br><span class="line">            <span class="keyword">assert</span> to.useVirtio</span><br><span class="line">            <span class="keyword">assert</span> to.nicInternalName == nic.internalName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testStopVm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VmSpec spec = env.specByName(<span class="string">"vm"</span>)</span><br><span class="line"></span><br><span class="line">        KVMAgentCommands.StopVmCmd cmd = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">        env.afterSimulator(KVMConstant.KVM_STOP_VM_PATH) &#123; rsp, HttpEntity&lt;String&gt; e -&gt;</span><br><span class="line">            cmd = JSONObjectUtil.toObject(e.body, KVMAgentCommands.StopVmCmd.class)</span><br><span class="line">            <span class="keyword">return</span> rsp</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        VmInstanceInventory inv = stopVmInstance &#123;</span><br><span class="line">            uuid = spec.inventory.uuid</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> inv.state == VmInstanceState.Stopped.toString()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> cmd != <span class="keyword">null</span></span><br><span class="line">        <span class="keyword">assert</span> cmd.uuid == spec.inventory.uuid</span><br><span class="line"></span><br><span class="line">        def vmvo = dbFindByUuid(cmd.uuid, VmInstanceVO.class)</span><br><span class="line">        <span class="keyword">assert</span> vmvo.state == VmInstanceState.Stopped</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        env.delete()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ZStack的Integreation Test使用groovy编写，通过JUnit运行。运行如下命令可以执行该case：</p><blockquote><p>cd /root/zstack/test<br>mvn test -Dtest=OneVmBasicLifeCycleCase</p></blockquote><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>从代码中可以看到所有Integration Test都继承SubCase类，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneVmBasicLifeCycleCase</span> <span class="keyword">extends</span> <span class="title">SubCase</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>并实现4个抽象函数：</p><blockquote><p>1.setup：配置用例，主要用于加载运行用例需要用到的ZStack服务和组件<br>2.environment： 构造测试环境，例如创建zone、cluster，添加host等操作<br>3.test：执行具体测试代码<br>4.clean：清理环境 （仅当该case在test suite中运行时执行，后文详述</p></blockquote><p>测试用例运行时，上述4个函数依次执行，任何一个环节出现错误则测试终止退出（case在test suite中运行时例外）。</p><p>一般在setup中，会将依赖的Bean按需加载进来。这在前面提到过；而environment则会构建出一个环境。Grovvy对DSL支持较好，所以整个环境的构建代码可读性极强，本质上每个DSL都对应了一个Spec，而Sepc对应了一个ZStack的SDK创建调用——即XXXAction。而XXXAction则通过HTTP调用ZStack的API接口。</p><p>在平时测试中大家可能直接Build一个环境对数据库进行操作，但是这在ZStack中并不是很好的方案。一个Iaas中的资源依赖及状态变动的关系是错综复杂的，因此调用外部的API来创建资源是一个明智的选择。同时也可以测试SDK和API的行为是否是期待的。</p><h3 id="模拟agent行为-灵活测试"><a href="#模拟agent行为-灵活测试" class="headerlink" title="模拟agent行为-灵活测试"></a>模拟agent行为-灵活测试</h3><p>ZStack Integreation Test最核心功能是通过基于Jetty的模拟器模拟真实环境下物理设备上安装的agent，例如模拟物理机上安装的KVM agent。当测试的场景涉及到后端agent调用时，我们需要捕获这些HTTP请求并进行验证，也可以伪造agent返回测试API逻辑。</p><p>如果看过ZStack的Case，可以看到很多类似的方法：</p><blockquote><ul><li>env.afterSimulator </li><li>env.simulator </li><li>env.message</li></ul></blockquote><p>这几个方法用来hook Message和HTTP Request。由于在ZStack中各个组件的通信都由Message来完成，对于Agent的请求则是统一通过HTTP来完成。这样在TestCase就可以任意模拟任何组件及agent的状态，让Case有极强的实用性——也保证了ManagentMent Node的逻辑健壮。</p><blockquote><p>具体的使用方式可以参考官网zstack测试部分的讲解</p></blockquote><h2 id="与Java-Web应用中MockMVC对比"><a href="#与Java-Web应用中MockMVC对比" class="headerlink" title="与Java Web应用中MockMVC对比"></a>与Java Web应用中MockMVC对比</h2><p>ZStack的SDK本质上是包装了一层HTTP Path，利用通用的协议便于开发者进行开发或测试。而在传统的Java WEB应用中，一般会通过MockMvc进行测试。其本质也是通过调用每个API的Path传参来进行测试。如下VMAgent测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySqlIntegrationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext context;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestCloudBus cloudBus;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Platform platform;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String UTF8 = <span class="string">"UTF-8"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mvc = MockMvcBuilders.webAppContextSetup(<span class="keyword">this</span>.context).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testModifyConfig</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String MY_CONF = <span class="string">"my.conf"</span>;</span><br><span class="line">        <span class="keyword">final</span> String APP_YML_FILE = <span class="string">"application.yml"</span>;</span><br><span class="line"></span><br><span class="line">        URL url = MyConfFileUtils.class.getClassLoader().getResource(APP_YML_FILE);</span><br><span class="line">        Assert.assertNotNull(url);</span><br><span class="line">        Path dirPath = Paths.get(url.toURI()).getParent();</span><br><span class="line">        Path currentPath = Paths.get(dirPath.toString(), MY_CONF);</span><br><span class="line"></span><br><span class="line">        String v = <span class="string">"testInsertAndDelete-str"</span>;</span><br><span class="line">        LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        map.put(MyConfConst.LOG_ERROR.getStringValue(), v);</span><br><span class="line"></span><br><span class="line">        ModifyMyConfDTO dto = <span class="keyword">new</span> ModifyMyConfDTO();</span><br><span class="line">        dto.setParams(map);</span><br><span class="line">        dto.setPath(currentPath.toString());</span><br><span class="line"></span><br><span class="line">        String param = JsonUtils.objectToJson(dto);</span><br><span class="line"></span><br><span class="line">        MvcResult result = mvc.perform(MockMvcRequestBuilders.put(<span class="string">"/mysql/conf"</span>)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .content(param))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andReturn();</span><br><span class="line"></span><br><span class="line">        String content = result.getResponse().getContentAsString();</span><br><span class="line">        Result response = JsonUtils.jsonToResult(content);</span><br><span class="line">        Assert.assertTrue(response.isSuccess());</span><br><span class="line">        Assert.assertNull(response.getData());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] fileContent = MyConfFileUtils.getContent();</span><br><span class="line"></span><br><span class="line">        Assert.assertTrue(<span class="keyword">new</span> String(fileContent, UTF8).contains(MyConfConst.LOG_ERROR.getStringValue()));</span><br><span class="line">        Assert.assertTrue(<span class="keyword">new</span> String(fileContent, UTF8).contains(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStartMySQL</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AtomicBoolean isIntercepterMessage = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        AtomicBoolean ishandleMessage = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        cloudBus.installIntercepter((FrontMessageIntercepter) msg -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> StartMySqlMsg) &#123;</span><br><span class="line">                isIntercepterMessage.set(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        cloudBus.hookMessage(StartMySqlMsg.class, msg -&gt; &#123;</span><br><span class="line">            StartMySqlMsg smsg = (StartMySqlMsg) msg;</span><br><span class="line">            ishandleMessage.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            MsgReply reply = <span class="keyword">new</span> MsgReply(smsg);</span><br><span class="line">            reply.setResult(Result.createBySuccess());</span><br><span class="line">            cloudBus.reply(reply);</span><br><span class="line">            <span class="keyword">return</span> reply;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        MvcResult result = mvc.perform(MockMvcRequestBuilders.post(<span class="string">"/mysql/start"</span>)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andReturn();</span><br><span class="line"></span><br><span class="line">        String content = result.getResponse().getContentAsString();</span><br><span class="line">        Result response = JsonUtils.jsonToResult(content);</span><br><span class="line">        Assert.assertTrue(response.isSuccess());</span><br><span class="line">        Assert.assertTrue(isIntercepterMessage.get());</span><br><span class="line">        Assert.assertTrue(ishandleMessage.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">........</span><br><span class="line">........</span><br></pre></td></tr></table></figure><p>从代码中可以看到MockMvc，发送请求到指定路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MvcResult result = mvc.perform(MockMvcRequestBuilders.post(<span class="string">"/mysql/start"</span>)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andReturn();</span><br></pre></td></tr></table></figure><p>后端接收到消息，可以hook其中的Msg，返回假的值。</p><h2 id="为什么使用自动化测试"><a href="#为什么使用自动化测试" class="headerlink" title="为什么使用自动化测试"></a>为什么使用自动化测试</h2><p>自动化测试好处很明显：</p><blockquote><p>保证软件质量，重复的活交给机器来做，避免繁琐重复的手动测试，节省人力；<br>为重构打下良好的基础：软件内部无论如何重构，对外部请求所返回的结果不应该有所变化；<br>保证核心类库的逻辑不遭受破坏，同时也可以作为使用的“样本”，由于没有业务逻辑的耦合，代码显得更加清楚，便于阅读；<br>…..</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;把简单的事情做得出人意料的精彩&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;zstack是什么？&lt;br&gt;zstack
      
    
    </summary>
    
      <category term="zstack" scheme="http://yoursite.com/categories/zstack/"/>
    
    
      <category term="zstack，自动化测试" scheme="http://yoursite.com/tags/zstack%EF%BC%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Facade设计模式和六大设计原则</title>
    <link href="http://yoursite.com/2018/10/24/facade%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2018/10/24/facade设计模式和六大设计原则/</id>
    <published>2018-10-24T01:00:00.000Z</published>
    <updated>2018-11-27T16:43:56.514Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>生活是具体的</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本周我在开发的时候，在补mysql主备搭建测试的时候，发现部分的代码兼容性不好，agent端代码使用的是springboot来管理的，在实际开发中是跑在VM上的，而测试的代码不能在本地运行，因为有些shell命名需要通过ssh发送到远程虚拟机上执行，而ssh连接这部分代码不太适合实际运行环境和开发环境都能测试这个要求，所以动手重构sshUtils代码。</p><h2 id="Facade设计模式"><a href="#Facade设计模式" class="headerlink" title="Facade设计模式"></a>Facade设计模式</h2><p> Facade设计模式：定义了一个高层、统一的接口，外部与通过这个统一的接口对子系统中的一群接口进行访问。通过创建一个统一的类，用来包装子系统中一个或多个复杂的类，客户端可以通过调用外观类的方法来调用内部子系统中所有方法。<br> <img src="facade.jpg" alt="1"></p><h3 id="使用Facade设计模式原因"><a href="#使用Facade设计模式原因" class="headerlink" title="使用Facade设计模式原因"></a>使用Facade设计模式原因</h3><p>1.实现客户类与子系统类的松耦合<br>2.降低原有系统的复杂度<br>3.提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。 </p><blockquote><p>引入外观角色之后，用户只需要与外观角色交互；<br> 用户与子系统之间的复杂逻辑关系由外观角色来实现</p></blockquote><h3 id="第一次重构"><a href="#第一次重构" class="headerlink" title="第一次重构"></a>第一次重构</h3><p>首先想到的不是通过设计模式来解决，而是直接在sshUtils中修改部分代码，把sshUtils中没有的功能添加进去，并创建一个类，ip地址默认是127.0.0.1，测试的代码就可以动态的修改这个ip，而线上环境就使用默认ip。这样就可以完美的解决ip不同的情况。</p><p>可是我后面遇到了两个问题：<br>第一：sshUtils中放入了业务代码<br>第二：如果是oracle也需要使用这个Utils，怎么办，无法复用。</p><h3 id="工具类和管理类的区别"><a href="#工具类和管理类的区别" class="headerlink" title="工具类和管理类的区别"></a>工具类和管理类的区别</h3><p>工具类：作为系统中通用的工具，不会牵扯到业务代码，也就是说工具类是无状态的<br>管理类：作用某一个场景下管理工具，里面会包含很多的业务代码，也就是说管理类是有状态的</p><h3 id="Facade模式的使用"><a href="#Facade模式的使用" class="headerlink" title="Facade模式的使用"></a>Facade模式的使用</h3><p>通过facade设计模式来解决上述问题，因为都是ssh操作，统一写一个外观模式，可以很好的统筹连接ssh的操作。牵扯到业务的功能代码，可以设计针对某一大业务的Impl。</p><p>facadeSsh最终代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SshFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行shell命令</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cmd     shell cmd</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ShellResult</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JSchException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Result <span class="title">execShellCmd</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> IOException, JSchException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行RemoteHostDTO ssh</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vo  vo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cmd cmd</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JSchException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Result <span class="title">execCmdOnRemote</span><span class="params">(RemoteHostDTO vo, String cmd)</span> <span class="keyword">throws</span> IOException, JSchException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取文件内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remotePath path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JSchException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SftpException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">readFile</span><span class="params">(String remotePath)</span> <span class="keyword">throws</span> JSchException, SftpException, IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到userInfo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> UserInfo</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><p>针对mysql业务的代码，首先想到的是继承SshFacade的实现类来设计，最后通过同事的指点，发现如果使用继承便会违反<code>依赖倒置原则</code>。如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySqlSshFacadeImpl</span> <span class="keyword">extends</span> <span class="title">SshFacadeImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SPEACE = <span class="string">"\t"</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SshInfo info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remotePath path 比如：/opt/exec/my.cnf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map        map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JSchException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SftpException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coverConfigFile</span><span class="params">(String remotePath, LinkedHashMap&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        Session session;</span><br><span class="line">        ChannelSftp sftp;</span><br><span class="line">        InputStream stream;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            session = JSCH.getSession(info.getSshUser(), info.getSshIp(), info.getSshPort());</span><br><span class="line">            session.setPassword(info.getSshPwd());</span><br><span class="line">            UserInfo ui = getUserInfo();</span><br><span class="line">            session.setUserInfo(ui);</span><br><span class="line">            session.connect(<span class="number">30000</span>);</span><br><span class="line">            sftp = (ChannelSftp) session.openChannel(<span class="string">"sftp"</span>);</span><br><span class="line">            sftp.connect();</span><br><span class="line">....................</span><br><span class="line">....................</span><br></pre></td></tr></table></figure><p>这里直接继承SshFacadeImpl，这样会导致高层次模块依赖了低层次模块，<strong>高层模块就是调用端，低层模块就是具体实现类。</strong>通过继承的方式<code>MySqlSshFacadeImpl</code>便无法继承其他的功能模块，而且当SshFacade接口发生改变的时候，对MySQLSshFacade不在适用的时候，便要修改MySQL这部分的代码。如果通过接口的方式，则不会这些这部分的问题。</p><h2 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h2><ul><li><p>单一职责（Single Responsibility），类或者对象最好是只有单一职责，在程序设计中如果发现某个类承担着多种义务，可以考虑进行拆分。</p></li><li><p>开关原则（Open-Close, Open for extension, close for modification），设计要对扩展开放，对修改关闭。换句话说，程序设计应保证平滑的扩展性，尽量避免因为新增同类功能而修改已有实现，这样可以少产出些回归（regression）问题。</p></li><li><p>里氏替换（Liskov Substitution），这是面向对象的基本要素之一，进行继承关系抽象时，凡是可以用父类或者基类的地方，都可以用子类替换。</p></li><li><p>接口隔离（Interface Segregation），我们在进行类和接口设计时，如果在一个接口里定义了太多方法，其子类很可能面临两难，就是只有部分方法对它是有意义的，这就破坏了程序的内聚性。<br>对于这种情况，可以通过拆分成功能单一的多个接口，将行为进行解耦。在未来维护中，如果某个接口设计有变，不会对使用其他接口的子类构成影响。</p></li><li><p>依赖反转（Dependency Inversion），或者<code>称依赖倒置</code>实体应该依赖于抽象而不是实现。也就是说高层次模块，不应该依赖于低层次模块，而是应该基于抽象。实践这一原则是保证产品代码之间适当耦合度的法宝。</p></li><li><p>迪米特法则（Law of Demeter），类间解耦，一个类对自己依赖的类知道的越少越好。自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。</p></li></ul><p><strong>一句话概括:</strong> <code>单一职责原则</code>告诉我们实现类要职责单一；<code>里氏替换原则</code>告诉我们不要破坏继承体系；<code>依赖倒置原则</code>告诉我们要面向接口编程；<code>接口隔离原则</code>告诉我们在设计接口的时候要精简单一；<code>迪米特法则</code>告诉我们要降低耦合。而<code>开闭原则</code>是总纲，他告诉我们要对扩展开放，对修改关闭。</p><blockquote><p>注意：现代语言发展很快，很多时候并不是完全准守前面的原则。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;生活是具体的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本周我在开发的时候，在补mysql主备搭建测试的时候，发现
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，Java" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>IO与NIO</title>
    <link href="http://yoursite.com/2018/10/13/IO%E4%B8%8ENIO/"/>
    <id>http://yoursite.com/2018/10/13/IO与NIO/</id>
    <published>2018-10-13T01:00:00.000Z</published>
    <updated>2018-12-05T08:12:01.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>成功才是成功之母</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。</p><p>首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p><p>java.io 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。</p><p>第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p><p>第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续工作。</p><h2 id="java-NIO组成"><a href="#java-NIO组成" class="headerlink" title="java NIO组成"></a>java NIO组成</h2><p><code>通道</code> 和 <code>缓冲区</code> 是 NIO 中的核心对象，几乎在每一个 I/O 操作中都要使用它们。<br><strong>通道</strong>是对原 I/O 包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 <strong>Buffer</strong> 实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。</p><h3 id="什么是缓冲区"><a href="#什么是缓冲区" class="headerlink" title="什么是缓冲区"></a>什么是缓冲区</h3><p>Buffer 是一个对象， 它包含一些要写入或者刚读出的数据。 <strong>在 NIO 中加入 Buffer 对象，体现了新库与原 I/O 的一个重要区别。在面向流的 I/O 中，您将数据直接写入或者将数据直接读到 Stream 对象中。</strong><br>在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，您都是将它放到缓冲区中。<br>缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 仅仅 是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p><h3 id="缓冲区类型"><a href="#缓冲区类型" class="headerlink" title="缓冲区类型"></a>缓冲区类型</h3><p>最常用的缓冲区类型是 ByteBuffer。一个 ByteBuffer 可以在其底层字节数组上进行 get/set 操作(即字节的获取和设置)。<br>ByteBuffer 不是 NIO 中唯一的缓冲区类型。事实上，对于每一种基本 Java 类型都有一种缓冲区类型：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><h3 id="什么是通道"><a href="#什么是通道" class="headerlink" title="什么是通道"></a>什么是通道</h3><p>Channel是一个对象，可以通过它读取和写入数据。拿 NIO 与原来的 I/O 做个比较，通道就像是流。<br>正如前面提到的，所有数据都通过 Buffer 对象来处理。您永远不会将字节直接写入通道中，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p><p><strong>通道与流的不同之处</strong>在于通道是双向的。而流只是在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)， 而 通道 可以用于读、写或者同时用于读写。因为它们是双向的，所以通道可以比流更好地反映底层操作系统的真实情况。</p><h2 id="NIO中的读写"><a href="#NIO中的读写" class="headerlink" title="NIO中的读写"></a>NIO中的读写</h2><p>读和写是 I/O 的基本过程。从一个通道中读取很简单：只需创建一个缓冲区，然后让通道将数据读到这个缓冲区中。写入也相当简单：创建一个缓冲区，用数据填充它，然后让通道用这些数据来执行写入操作。<br>如下示例：我们以读取一个文件内容为示例，从文件中读文件需要三步：</p><blockquote><p>(1) 从 FileInputStream 获取 Channel<br>(2) 创建 Buffer<br> (3) 将数据从 Channel 读到Buffer 中。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从 FileInputStream 获取通道</span></span><br><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream( <span class="string">"fan.txt"</span> );</span><br><span class="line">FileChannel fc = fin.getChannel();</span><br><span class="line"><span class="comment">//创建缓冲区</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );</span><br><span class="line"><span class="comment">//将数据从通道读到缓冲区</span></span><br><span class="line">fc.read( buffer );</span><br></pre></td></tr></table></figure><p>写入文件过程类似：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从 FileOutputStream 获取通道</span></span><br><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream( <span class="string">"kai.txt"</span> );</span><br><span class="line">FileChannel fc = fout.getChannel();</span><br><span class="line"><span class="comment">//创建缓冲区</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );</span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="comment">//将数据从通道读到缓冲区</span></span><br><span class="line">fc.write( buffer );</span><br></pre></td></tr></table></figure></p><p>上面两个例子是读与写进行分开的，下面介绍读写结合：<br>三个基本操作：首先创建一个 <code>Buffer</code>，然后从源文件中将数据读到这个缓冲区中，然后将缓冲区写入目标文件。这个程序不断重复 ― 读、写、读、写 ― 直到源文件结束。<br>读写结合操作会使用到使用<code>clear()</code> 和 <code>flip()</code> 方法重设缓冲区，使它可以接受读入的数据。<code>flip()</code>方法让缓冲区可以将新读入的数据写入另一个通道。在从输入通道读入缓冲区之前，我们调用<code>clear()</code> 方法。同样，在将缓冲区写入输出通道之前，我们调用<code>flip()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream( <span class="string">"fan.txt"</span> );</span><br><span class="line">FileChannel fcin = fin.getChannel();</span><br><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream( <span class="string">"kai.txt"</span> );</span><br><span class="line">FileChannel fcout = fout.getChannel();</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">     buffer.clear();</span><br><span class="line">     <span class="keyword">int</span> r = fcin.read( buffer );</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span> (r==-<span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     buffer.flip();</span><br><span class="line">     fcout.write( buffer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓冲区详解"><a href="#缓冲区详解" class="headerlink" title="缓冲区详解"></a>缓冲区详解</h2><p><strong>本节将介绍 NIO 中两个重要的缓冲区组件：状态变量和访问方法 (accessor)。</strong><br>状态变量是前一节中提到的”内部统计机制”的关键。每一个读/写操作都会改变缓冲区的状态。通过记录和跟踪这些变化，缓冲区就可能够内部地管理自己的资源。<br>在从通道读取数据时，数据被放入到缓冲区。在有些情况下，可以将这个缓冲区直接写入另一个通道，但是在一般情况下，您还需要查看数据。这是使用 访问方法 get() 来完成的。同样，如果要将原始数据放入缓冲区中，就要使用访问方法 put()。</p><h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p>三个值指定缓冲区在任意时刻的状态：</p><ul><li>position</li><li>limit</li><li>capacity</li></ul><h4 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h4><p>缓冲区实际上就是美化了的数组。在从通道读取时，您将所读取的数据放到底层的数组中。 position 变量跟踪已经写了多少数据。更准确地说，它指定了下一个字节将放到数组的哪一个元素中。因此，如果您从通道中读三个字节到缓冲区中，那么缓冲区的 position 将会设置为3，指向数组中第四个元素。<br>同样，在写入通道时，您是从缓冲区中获取数据。 position 值跟踪从缓冲区中获取了多少数据。更准确地说，它指定下一个字节来自数组的哪一个元素。因此如果从缓冲区写了5个字节到通道中，那么缓冲区的 position 将被设置为5，指向数组的第六个元素。</p><h4 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h4><p>limit 变量表明还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。<br>position 总是小于或者等于 limit。</p><h4 id="Capacity"><a href="#Capacity" class="headerlink" title="Capacity"></a>Capacity</h4><p>缓冲区的 capacity 表明可以储存在缓冲区中的最大数据容量。实际上，它指定了底层数组的大小 ― 或者至少是指定了准许我们使用的底层数组的容量。<br>limit 决不能大于 capacity。</p><h3 id="状态变量的变化"><a href="#状态变量的变化" class="headerlink" title="状态变量的变化"></a>状态变量的变化</h3><p>出于本例子的需要，我们假设这个缓冲区的 总容量 为8个字节。<br>那么一开始的时候，limit和capacity应该在同一位置，都只想数组的尾部，如图：<br><img src="first.jpg" alt="1"><br>position 设置为0。如果我们读一些数据到缓冲区中，那么下一个读取的数据就进入 slot 0 。如果我们从缓冲区写一些数据，从缓冲区读取的下一个字节就来自 slot 0 。 position 设置如下所示：<br><img src="2.jpg" alt="1"><br><strong>第一次读取：</strong><br>现在我们可以开始在新创建的缓冲区上进行读/写操作。首先从输入通道中读一些数据到缓冲区中。第一次读取得到三个字节。它们被放到数组中从 position 开始的位置，这时 position 被设置为 0。读完之后，position 就增加到 3，如下所示：<br><img src="3.jpg" alt="1"><br><strong>第二次读取：</strong><br>在第二次读取时，我们从输入通道读取另外两个字节到缓冲区中。这两个字节储存在由 position 所指定的位置上， position 因而增加 2：<br><img src="4.jpg" alt="1"></p><p><strong>将数据写到输出通道中：</strong><br>在这之前，我们必须调用 flip() 方法。这个方法做两件非常重要的事：</p><blockquote><p>1.它将 limit 设置为当前 position。<br>2.它将 position 设置为 0。</p></blockquote><p>下面是在 flip 之后的缓冲区：<br><img src="5.jpg" alt="1"><br>我们现在可以将数据从缓冲区写入通道了。 position 被设置为 0，这意味着我们得到的下一个字节是第一个字节。 limit 已被设置为原来的 position。</p><p><strong>写入：</strong><br>limit在我们调用 flip() 时被设置为 5，并且 position 不能超过 limit。一次读取五个字节时，这使得 position 增加到 5，并保持 limit 不变，如下所示：<br><img src="6.jpg" alt="1"></p><p><strong>clear：</strong><br>最后一步是调用缓冲区的 clear() 方法。这个方法重设缓冲区以便接收更多的字节。 Clear 做两种非常重要的事情：</p><blockquote><p>1.它将 limit 设置为与 capacity 相同。<br>2.它设置 position 为 0。</p></blockquote><p>下图显示了在调用 clear() 后缓冲区的状态：<br><img src="7.jpg" alt="1"></p><h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><p>到目前为止，我们只是使用缓冲区将数据从一个通道转移到另一个通道。然而，程序经常需要直接处理数据。例如，您可能需要将用户数据保存到磁盘。在这种情况下，您必须将这些数据直接放入缓冲区，然后用通道将缓冲区写入磁盘。<br>或者，您可能想要从磁盘读取用户数据。在这种情况下，您要将数据从通道读到缓冲区中，然后检查缓冲区中的数据。<br>在本节的最后，我们将详细分析如何使用 ByteBuffer 类的 get() 和 put() 方法直接访问缓冲区中的数据。</p><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><p><strong>ByteBuffer 类中有四个 get() 方法：</strong></p><blockquote><p>1.byte get();<br>2.ByteBuffer get( byte dst[] );<br>3.ByteBuffer get( byte dst[], int offset, int length );<br>4.byte get( int index );</p></blockquote><p>第一个方法获取单个字节。第二和第三个方法将一组字节读到一个数组中。第四个方法从缓冲区中的特定位置获取字节。那些返回 ByteBuffer 的方法只是返回调用它们的缓冲区的 <code>this</code> 值。</p><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><p><strong>ByteBuffer 类中有五个 put() 方法：</strong></p><blockquote><p>1.ByteBuffer put( byte b );<br>2.ByteBuffer put( byte src[] );<br>3.ByteBuffer put( byte src[], int offset, int length );<br>4.ByteBuffer put( ByteBuffer src );<br>5.ByteBuffer put( int index, byte b );</p></blockquote><p>第一个方法 写入（put） 单个字节。第二和第三个方法写入来自一个数组的一组字节。第四个方法将数据从一个给定的源 ByteBuffer 写入这个 ByteBuffer。第五个方法将字节写入缓冲区中特定的 位置 。那些返回 ByteBuffer 的方法只是返回调用它们的缓冲区的 <code>this</code>值。</p><p><strong>关于缓存区的更多内容这里就不多介绍了，可以网上搜一些关于缓冲区的内容。</strong></p><h2 id="使用NIO进行网络连接"><a href="#使用NIO进行网络连接" class="headerlink" title="使用NIO进行网络连接"></a>使用NIO进行网络连接</h2><p>以前实现socket服务器方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  serverSocket.getLocalPort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                RequestHandler requestHandler = <span class="keyword">new</span> RequestHandler(socket);</span><br><span class="line">                requestHandler.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        DemoServer server = <span class="keyword">new</span> DemoServer();</span><br><span class="line">        server.start();</span><br><span class="line">        <span class="keyword">try</span> (Socket client = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), server.getPort())) &#123;</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span>                   InputStreamReader(client.getInputStream()));</span><br><span class="line">            bufferedReader.lines().forEach(s -&gt; System.out.println(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 简化实现，不做读取，直接发送字符串</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    RequestHandler(Socket socket) &#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());) &#123;</span><br><span class="line">            out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>在接收到客户端请求之前，服务器端都是阻塞的，如果是单线程的，每次只能处理单个请求，虽然可以通过加入线程池的方式解决，但是连接数不是很多时，这种方式可以工作的很好，但是如果连接数量急剧上升，这种方式就无法很好的工作了。因为线程上下文切换开销会在高并发时变得很明显，这是同步阻塞方式的低扩展性劣势。</strong></p><p><img src="socket.jpg" alt="1"></p><h3 id="为什么使用NIO连网"><a href="#为什么使用NIO连网" class="headerlink" title="为什么使用NIO连网"></a>为什么使用NIO连网</h3><p>关于这点不得不说，NIO的特性之一：<strong>多路复用机制</strong>。<br>首先我们先了解下面几个概念：</p><h4 id="Selectors"><a href="#Selectors" class="headerlink" title="Selectors"></a>Selectors</h4><p>NIO中连网核心对象名为<code>Selector</code>，Selector 就是您注册对各种 I/O 事件的兴趣的地方，而且当那些事件发生时，就是这个对象告诉您所发生的事件。<code>Selector</code>是 NIO 实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在 Selector 上的多个 <code>Channel</code>中，是否有 Channel 处于就绪状态，进而实现了单线程对多 Channel 的高效管理。<br><strong>我们需要做的第一件事就是创建一个 Selector：</strong></p><blockquote><p>Selector selector = Selector.open();</p></blockquote><p>然后，我们将对不同的通道对象调用 register() 方法，以便注册我们对这些对象中发生的 I/O 事件的兴趣。register() 的第一个参数总是这个 Selector。</p><h4 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h4><p>为了接收连接，我们需要一个 <code>ServerSocketChannel</code>。事实上，我们要监听的每一个端口都需要有一个 ServerSocketChannel 。对于每一个端口，我们打开一个 ServerSocketChannel，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">ssc.configureBlocking( <span class="keyword">false</span> );</span><br><span class="line">InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress( ports[i] );</span><br><span class="line">ss.bind( address );</span><br></pre></td></tr></table></figure><p>第一行创建一个新的 ServerSocketChannel ，最后三行将它绑定到给定的端口。第二行将 ServerSocketChannel 设置为 非阻塞的 。我们必须对每一个要使用的套接字通道调用这个方法。</p><h4 id="选择键"><a href="#选择键" class="headerlink" title="选择键"></a>选择键</h4><p>下一步是将新打开的 ServerSocketChannels 注册到 Selector上。为此我们使用 <code>ServerSocketChannel.register()</code> 方法，如下所示：</p><blockquote><p>SelectionKey key = ssc.register( selector, SelectionKey.OP_ACCEPT );</p></blockquote><p>register() 的第一个参数总是这个 Selector。第二个参数是 OP_ACCEPT，这里它指定我们想要监听 accept 事件，也就是在新的连接建立时所发生的事件。这是适用于 ServerSocketChannel 的唯一事件类型。</p><p>请注意对 register() 的调用的返回值。 SelectionKey 代表这个通道在此 Selector 上的这个注册。当某个 Selector 通知您某个传入事件时，它是通过提供对应于该事件的 SelectionKey 来进行的。SelectionKey 还可以用于取消通道的注册。</p><p><strong>下面将进入主循环</strong>。使用 Selectors 的几乎每个程序都像下面这样使用内部循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = selector.select();</span><br><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator it = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">     SelectionKey key = (SelectionKey)it.next();</span><br><span class="line">     <span class="comment">// ... deal with I/O event ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们调用 Selector 的<code>select()</code> 方法。这个方法会阻塞，直到至少有一个已注册的事件发生。当一个或者更多的事件发生时， select() 方法将返回所发生的事件的数量。<br>接下来，我们调用 Selector 的 <code>selectedKeys()</code> 方法，它返回发生了事件的 SelectionKey 对象的一个 集合 。<br>我们通过迭代 SelectionKeys 并依次处理每个 SelectionKey 来处理事件。对于每一个 SelectionKey，您必须确定发生的是什么 I/O 事件，以及这个事件影响哪些 I/O 对象。</p><h4 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Selector selector = Selector.open();</span><br><span class="line">             ServerSocketChannel serverSocket = ServerSocketChannel.open();) &#123;<span class="comment">// 创建 Selector 和 Channel</span></span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(), <span class="number">8888</span>));</span><br><span class="line">            serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 注册到 Selector，并说明关注点</span></span><br><span class="line">            serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                selector.select();<span class="comment">// 阻塞等待就绪的 Channel，这是关键点之一</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                   <span class="comment">// 生产系统中一般会额外进行就绪状态检查</span></span><br><span class="line">                    sayHelloWorld((ServerSocketChannel) key.channel());</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHelloWorld</span><span class="params">(ServerSocketChannel server)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (SocketChannel client = server.accept();) &#123;          client.write(Charset.defaultCharset().encode(<span class="string">"Hello world!"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        NIOServer server = <span class="keyword">new</span> NIOServer();</span><br><span class="line">        server.start();</span><br><span class="line">        <span class="keyword">try</span> (Socket client = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), server.getPort())) &#123;</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span>                   InputStreamReader(client.getInputStream()));</span><br><span class="line">            bufferedReader.lines().forEach(s -&gt; System.out.println(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤总结：</strong></p><blockquote><p>首先，通过 Selector.open() 创建一个 Selector，作为类似调度员的角色。<br>然后，创建一个 ServerSocketChannel，并且向 Selector 注册，通过指定SelectionKey.OP_ACCEPT，告诉调度员，它关注的是新的连接请求。注意，为什么我们要明确配置非阻塞模式呢？这是因为阻塞模式下，注册操作是不允许的，会抛出IllegalBlockingModeException 异常。<br>Selector 阻塞在 select 操作，当有 Channel 发生接入请求，就会被唤醒。</p></blockquote><h2 id="NIO与IO相比有什么优点"><a href="#NIO与IO相比有什么优点" class="headerlink" title="NIO与IO相比有什么优点"></a>NIO与IO相比有什么优点</h2><p>先看张图：<br><img src="selector.jpg" alt="1"></p><p><strong>NIO利用单线程轮询事件的机制</strong>，通过高效地定位就绪的Channel，来决定做什么，仅仅select阶段是阻塞的，可以有效避免大量客户端连接时，频繁切换带来的问题，应用的扩展能力有了非常大的提高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。<br>NIO 与原来的 I/O 有同样的作用和目的，但是它使用不同的方式 块 I/O。正如您将在本教程中学到的，块 I/O 的效率可以比流 I/O 高许多。</p><blockquote><p>NIO还有很多新的功能，比如文件的拷贝，零拷贝的特性等。这些功能放在下篇介绍。</p></blockquote><hr><h2 id="补充-文件拷贝"><a href="#补充-文件拷贝" class="headerlink" title="补充-文件拷贝"></a>补充-文件拷贝</h2><p>Java有多种比较典型的文件拷贝实现方式，比如：</p><blockquote><ol><li>利用java.io类库，比如：FileInputStream读取</li><li>利用java.nio类库提供的transferTo或transferFrom方法实现（零拷贝：zero-copy）</li><li>java标准类库本身已经提供了几种Files.copy的实现</li></ol></blockquote><p>对于Copy的效率，这个其实与操作系统和配置等情况相关，总体上来说，<strong>NIO transferTo/From的方式更快</strong>，因为它更能利用现在操作系统底层机制，避免不必要拷贝和上下文切换。</p><h3 id="拷贝实现机制分析"><a href="#拷贝实现机制分析" class="headerlink" title="拷贝实现机制分析"></a>拷贝实现机制分析</h3><p>先来理解一下，前面实现的不同拷贝方法，本质上有什么明显的区别。</p><p>首先，你需要理解<code>用户态空间（User Space）</code>和<code>内核态空间（Kernel Space）</code>，这是操作系统层面的基本概念，操作系统内核，硬件驱动等运行在<code>内核态空间</code>，具有相对高的特权；而<code>用户态空间</code>，则是给普通应用和服务使用。</p><p>当我们使用输入输出流进行读写时，实际上是进行了多少上下文切换，比如应用读取数据时，先在内核态将数据从磁盘读取到内核缓存，再切换到用户态将数据从内核缓存读取到用户缓存。<br>写入操作也是类似，仅仅是步骤相反，你可以参考下面这张图：<br><img src="user.jpg" alt="user space"><br>所以，这种方式会带来一定的额外开销，可能会降低IO效率。</p><p>而基于NIO transferTo的实现方式，在Linux和Unix上，则会使用到零拷贝技术，数据传输并不需要用户态参与，省去了上下文切换的开销和不必要的内存拷贝，进而可能提高应用拷贝性能。注意，transferTo不仅仅是可以用在文件拷贝中，与其类似的，例如读取磁盘文件，然后进行Socket发送，同样可以享受这种机制带来的性能和扩展性提高。</p><p>transferTo 的传输过程是：<br><img src="kernel.jpg" alt="kernel space"></p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFileByChannel</span><span class="params">(File source, File dest)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">        IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (FileChannel sourceChannel = <span class="keyword">new</span> FileInputStream(source)</span><br><span class="line">            .getChannel();</span><br><span class="line">         FileChannel targetChannel = <span class="keyword">new</span> FileOutputStream(dest).getChannel</span><br><span class="line">                 ();)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> count = sourceChannel.size() ;count&gt;<span class="number">0</span> ;) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> transferred = sourceChannel.transferTo(sourceChannel.position(), </span><br><span class="line">count, targetChannel);     </span><br><span class="line"></span><br><span class="line">sourceChannel.position(sourceChannel.position() + transferred);</span><br><span class="line">            count -= transferred;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;成功才是成功之母&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Java IO 方式有很多种，基于不同的 IO 抽象模
      
    
    </summary>
    
      <category term="NIO" scheme="http://yoursite.com/categories/NIO/"/>
    
    
      <category term="NIO，IO" scheme="http://yoursite.com/tags/NIO%EF%BC%8CIO/"/>
    
  </entry>
  
  <entry>
    <title>Java枚举</title>
    <link href="http://yoursite.com/2018/09/15/java%E6%9E%9A%E4%B8%BE/"/>
    <id>http://yoursite.com/2018/09/15/java枚举/</id>
    <published>2018-09-15T09:33:00.000Z</published>
    <updated>2018-11-13T09:59:47.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>所有的无能好像都来自于自我否定的借口</p></blockquote><p>枚举在开发中用到的地方颇多，今天就来总结一下。</p><h2 id="Enum定义"><a href="#Enum定义" class="headerlink" title="Enum定义"></a>Enum定义</h2><p>Enum是java 1.5引入的，枚举的引入给开发带来很大的便利性。<br>在没有Enum之前，我们定义一些常量时会用如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Constant</span> </span>&#123;</span><br><span class="line">    String CHECK_CODE = <span class="string">"check"</span>;</span><br><span class="line">    String DELETE_CODE = <span class="string">"delete"</span>;</span><br><span class="line">    String FORCE_DELETE_CODE = <span class="string">"forceDelete"</span>;</span><br><span class="line">    String CLEANUP_CODE = <span class="string">"cleanup"</span>;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码我们一般称之为常量接口(constant interface)——这种接口不包含任何方法，它只包含静态的final域，每个域都导出一个常量。<br>接口的定义，是为了通过实现，来表名某个类需要具体实现具体功能的细节，表明客户端对这个类的实例可以实现某些动作，为了其他的目的去定义接口不是接口设计的初衷。<br>常量接口是对接口的一种不良使用。</p><p>还有偶尔会在项目中看到如下风格的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DayDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MONDAY =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TUESDAY=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WEDNESDAY=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THURSDAY=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRIDAY=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SATURDAY=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUNDAY=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的代码一般被叫做int枚举模式。</p><p>类在内部使用某些常量，纯粹是实现细节，实现常量接口，会导致把这样的实现细节泄露到该类的导出API中，因为接口中所有的域都是及方法public的。类实现常量接口，这对于这个类的用户来讲并没有实际的价值。<br>那既然不适合存在全部都是导出常量的常量接口，那么如果需要导出常量，它们应该放在哪里呢？<strong>如果这些常量与某些现有的类或者接口紧密相关，就应该把这些常量添加到这个类或者接口中，注意，这里说添加到接口中并不是指的常量接口</strong>。在Java平台类库中所有的数值包装类都导出MIN_VALUE和MAX_VALUE常量。如果这些常量最好被看作是枚举类型成员，那就应该用枚举类型来导出。否则，应该使用不可实例化的工具类来导出这些常量。</p><p>使用enum定义常量，如下定义周一到周日的常量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举类型，使用关键字enum</span></span><br><span class="line"><span class="keyword">enum</span> Day &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY,</span><br><span class="line">    THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="枚举实现原理"><a href="#枚举实现原理" class="headerlink" title="枚举实现原理"></a>枚举实现原理</h2><p>实际上在使用关键字enum创建枚举类型并编译后，编译器会为我们生成一个相关的类，这个类继承了Java API中的java.lang.Enum类，也就是说通过关键字enum创建枚举类型在编译后事实上也是一个类类型而且该类继承自java.lang.Enum类。<br>看看反编译Day.class文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反编译Day.class</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Day</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//编译器为我们添加的静态的values()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Day[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Day[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum也类的valueOf方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Day <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Day)Enum.valueOf(com/zejian/enumdemo/Day, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//前面定义的7种枚举实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day MONDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day TUESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day WEDNESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day THURSDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day FRIDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SATURDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SUNDAY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Day $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//实例化枚举实例</span></span><br><span class="line">        MONDAY = <span class="keyword">new</span> Day(<span class="string">"MONDAY"</span>, <span class="number">0</span>);</span><br><span class="line">        TUESDAY = <span class="keyword">new</span> Day(<span class="string">"TUESDAY"</span>, <span class="number">1</span>);</span><br><span class="line">        WEDNESDAY = <span class="keyword">new</span> Day(<span class="string">"WEDNESDAY"</span>, <span class="number">2</span>);</span><br><span class="line">        THURSDAY = <span class="keyword">new</span> Day(<span class="string">"THURSDAY"</span>, <span class="number">3</span>);</span><br><span class="line">        FRIDAY = <span class="keyword">new</span> Day(<span class="string">"FRIDAY"</span>, <span class="number">4</span>);</span><br><span class="line">        SATURDAY = <span class="keyword">new</span> Day(<span class="string">"SATURDAY"</span>, <span class="number">5</span>);</span><br><span class="line">        SUNDAY = <span class="keyword">new</span> Day(<span class="string">"SUNDAY"</span>, <span class="number">6</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> Day[] &#123;</span><br><span class="line">            MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从反编译的代码可以看出编译器确实帮助我们<strong>生成了一个Day类(注意该类是final类型的，将无法被继承)而且该类继承自java.lang.Enum类</strong>，该类是一个抽象类(稍后我们会分析该类中的主要方法)，除此之外，编译器还帮助我们生成了7个Day类型的实例对象分别对应枚举中定义的7个日期，这也充分说明了我们前面使用关键字enum定义的Day类型中的每种日期枚举常量也是实实在在的Day实例对象，只不过代表的内容不一样而已。注意编译器还为我们生成了两个静态方法，分别是values()和 valueOf()，稍后会分析它们的用法，到此我们也就明白了，使用关键字enum定义的枚举类型，在编译期后，也将转换成为一个实实在在的类，而在该类中，会存在每个在枚举类型中定义好变量的对应实例对象，如上述的MONDAY枚举类型对应public static final Day MONDAY;，同时编译器会为该类创建两个方法，分别是values()和valueOf()。</p><h2 id="枚举的进阶用法"><a href="#枚举的进阶用法" class="headerlink" title="枚举的进阶用法"></a>枚举的进阶用法</h2><p>重新定义一个日期枚举类，带有desc成员变量描述该日期的对于中文描述，同时定义一个getDesc方法，返回中文描述内容，自定义私有构造函数，在声明枚举实例时传入对应的中文描述，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Day2 &#123;</span><br><span class="line">    MONDAY(<span class="string">"星期一"</span>),</span><br><span class="line">    TUESDAY(<span class="string">"星期二"</span>),</span><br><span class="line">    WEDNESDAY(<span class="string">"星期三"</span>),</span><br><span class="line">    THURSDAY(<span class="string">"星期四"</span>),</span><br><span class="line">    FRIDAY(<span class="string">"星期五"</span>),</span><br><span class="line">    SATURDAY(<span class="string">"星期六"</span>),</span><br><span class="line">    SUNDAY(<span class="string">"星期日"</span>);<span class="comment">//记住要用分号结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//中文描述</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造,防止被外部调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> desc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day2</span><span class="params">(String desc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc=desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义方法,返回描述,跟常规类的定义没区别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上述代码可知，在enum类中确实可以像定义常规类一样声明变量或者成员方法。</p><h2 id="关于StringValue的较佳实践"><a href="#关于StringValue的较佳实践" class="headerlink" title="关于StringValue的较佳实践"></a>关于StringValue的较佳实践</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SourceDiskType &#123;</span><br><span class="line"></span><br><span class="line">    SYSTEM(<span class="string">"system"</span>),</span><br><span class="line">    DATA(<span class="string">"data"</span>),;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String stringValue;</span><br><span class="line"></span><br><span class="line">    SourceDiskType(String stringValue) &#123;</span><br><span class="line">        setStringValue(stringValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStringValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStringValue</span><span class="params">(String stringValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stringValue = stringValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SourceDiskType <span class="title">getEnum</span><span class="params">(String stringValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == stringValue) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (SourceDiskType sourceDiskType : SourceDiskType.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sourceDiskType.getStringValue().equals(stringValue)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sourceDiskType;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是阿里云早期版本SDK中的一段代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;所有的无能好像都来自于自我否定的借口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;枚举在开发中用到的地方颇多，今天就
      
    
    </summary>
    
    
      <category term="Java，Enum" scheme="http://yoursite.com/tags/Java%EF%BC%8CEnum/"/>
    
  </entry>
  
  <entry>
    <title>Spring小记</title>
    <link href="http://yoursite.com/2018/09/09/Spring%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/09/09/Spring小记/</id>
    <published>2018-09-09T01:00:00.000Z</published>
    <updated>2019-01-12T03:25:20.482Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人生而迷茫吗？</p></blockquote><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>学了Spring框架那么久，也没有很好总结过，很长时间不用有马上都忘了，今天来总结一下。无论什么框架，<code>一切皆源于Java最底层的设计</code>。</p><hr><h2 id="为什么使用Spring"><a href="#为什么使用Spring" class="headerlink" title="为什么使用Spring"></a>为什么使用Spring</h2><p>Spring是最近最火的框架，是快速开发项目最不可或缺的。<br>Spring主要两个有功能为我们的业务对象管理提供了非常便捷的方法：</p><blockquote><ul><li>DI（Dependency Injection，依赖注入） </li><li>AOP（Aspect Oriented Programming，面向切面编程）</li></ul></blockquote><h2 id="Java-Bean"><a href="#Java-Bean" class="headerlink" title="Java Bean"></a>Java Bean</h2><p>每一个类实现了Bean的规范才可以由Spring来接管，那么Bean的规范是什么呢？</p><blockquote><ul><li>必须是个公有(public)类 </li><li>有无参构造函数 </li><li>用公共方法暴露内部成员属性(getter,setter)</li></ul></blockquote><p>实现这样规范的类，被称为Java Bean。即是一种可重用的组件。</p><hr><h2 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h2><p>简单来说，一个系统中可能会有成千上万个对象。如果要手工维护它们之间的关系，这是不可想象的。我们可以在Spring的XML文件描述它们之间的关系，由Spring自动来注入它们——比如A类的实例需要B类的实例作为参数set进去。</p><p>以前这种管理对象的方式称为：Inversion of Control, 简称IoC。 但是IoC这个词不能让人更加直观和清晰的理解背后所代表的含义， 于是Martin Flower先生就创造了一个新词 : 依赖注入 (Dependency Injection，简称DI)。</p><p>通过Spring容器管理的对象默认是单例的，基本过程是：</p><blockquote><ol><li>解析xml或通过注解, 获取各种元素</li><li>通过Java反射把各个bean 的实例创建起来。</li><li>通过Java反射调用类的两个方法：set/get，把实例注入进来</li></ol></blockquote><p>其实Spring的处理方式和上面说的非常类似， 当然Spring 处理了更多的细节，例如不仅仅是setter方法注入， 还可以构造函数注入，init 方法， destroy方法等等， 基本思想是一致的。<br><img src="DI.jpg" alt="DI"></p><p><strong>既然对象的创建过程和装配过程都是Spring做的， 那Spring 在这个过程中就可以玩很多把戏了， 比如对你的业务类做点字节码级别的增强， 搞点AOP什么的， 这都不在话下了。</strong></p><h2 id="面向切面编程（AOP）"><a href="#面向切面编程（AOP）" class="headerlink" title="面向切面编程（AOP）"></a>面向切面编程（AOP）</h2><p>在分布式开发中，把不同的模块进行解耦分离，但是分解以后就会发现有些很有趣的东西， 这些东西是通用的，或者是跨越多个模块的：</p><blockquote><p>日志： 对特定的操作输出日志来记录<br>安全：在执行操作之前进行操作检查<br>性能：要统计每个方法的执行时间<br>事务：方法开始之前要开始事务，<br>结束后要提交或者回滚事务<br>等等….</p></blockquote><p>这些可以称为是非功能需求， 但他们是多个业务模块都需要的， 是<code>跨越模块</code>的， 把他们放到什么地方呢？<br>就以日志系统为例。在执行某个操作前后都需要输出日志，如果手工加代码，那简直太可怕了。而且等代码庞大起来，也是非常难维护的一种情况。<br>最简单的办法就是把这些通用模块的<code>接口</code>写好， 让程序员在实现业务模块的时候去调用就可以了。</p><p><strong>也许你会想到通过以下两种设计模式可以暂时解决：</strong></p><blockquote><ol><li>模版方法</li><li>装饰者模式</li></ol></blockquote><h3 id="模版方法"><a href="#模版方法" class="headerlink" title="模版方法"></a>模版方法</h3><p>用设计模式在某些情况下可以部分解决上面的问题，如模版方法伪代码如下：<br><strong>以订单管理和支付管理为例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseCommand</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Logger logger = Logger.getLog(xxx);</span><br><span class="line">        <span class="comment">//记录日志</span></span><br><span class="line">        logger.debug(<span class="string">"xxx"</span>);</span><br><span class="line">        <span class="comment">//权限检查</span></span><br><span class="line">        PerformanceUtil.startTimer(xxx);</span><br><span class="line">        <span class="comment">//开始事务</span></span><br><span class="line">        beginTransaction();</span><br><span class="line">        <span class="comment">//这是一个需要子类实现的抽象方法</span></span><br><span class="line">        doBusiness();</span><br><span class="line">        </span><br><span class="line">        commitTransaction();</span><br><span class="line">        PerformanceUtil.endTimer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doBusiness</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderCommand</span> <span class="keyword">extends</span> <span class="title">BaseCommand</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBusiness</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行订单逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentCommand</span> <span class="keyword">extends</span> <span class="title">BaseCommand</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBusiness</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行支付逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在父类（BaseCommand）中已经把那些“乱七八糟“的非功能代码都写好了， 只是留了一个口子（<code>抽象方法</code>doBusiness()）让子类去实现。</p><p>子类变的清爽， 只需要关注业务逻辑就可以了。调用也很简单，例如：<br>BaseCommand  cmd = …  获得PlaceOrderCommand的实例…<br>cmd.execute();</p><p><strong>缺点：</strong></p><blockquote><ul><li>这样方式的巨大缺陷就是父类会定义一切： 要执行哪些非功能代码， 以什么顺序执行等等 子类只能无条件接受，完全没有反抗余地。</li><li>如果有个子类， 根本不需要事务， 但是它也没有办法把事务代码去掉。</li></ul></blockquote><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>如果利用装饰者模式， 针对上面的问题，可以带来更大的灵活性：如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerDecorate</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    Command cmd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoggerDecorate</span><span class="params">(Command cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cmd = cmd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录日志</span></span><br><span class="line">        logger.debug(xxxx);</span><br><span class="line">        <span class="keyword">this</span>.cmd.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerformanceDecorator</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    Command cmd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PerformanceDecorator</span><span class="params">(Command cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cmd = cmd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PerformanceUtil.startTimer(xxx);</span><br><span class="line">        <span class="keyword">this</span>.cmd.execute();</span><br><span class="line">        PerformanceUtil.endTimer(xxx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderCommand</span> <span class="keyword">extends</span> <span class="title">BaseCommand</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBusiness</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行订单逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentCommand</span> <span class="keyword">extends</span> <span class="title">BaseCommand</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBusiness</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行支付逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺点：</strong></p><blockquote><p>如果仔细思考一下就会发现装饰者模式的不爽之处:<br>(1)  一个处理日志/性能/事务 的类为什么要实现 业务接口（Command）呢?<br>(2) 如果别的业务模块，没有实现Command接口，但是也想利用日志/性能/事务等功能，该怎么办呢？</p></blockquote><p>最好把日志/安全/事务这样的代码和业务代码完全隔离开来，因为他们的关注点和业务代码的关注点完全不同 ，他们之间应该是正交的，他们之间的关系<br>应该是这样的：</p><p><img src="AOP.jpg" alt="AOP"></p><p>如果把这个业务功能看成一层层面包的话， 这些日志/安全/事务 像不像一个个“切面”<code>(Aspect)</code> ？<br>如果我们能让这些“<code>切面</code>“能和业务独立，  并且能够非常灵活的“<code>织入</code>”到业务方法中， 那就实现了<code>面向切面编程</code>(AOP)！</p><h3 id="实现AOP"><a href="#实现AOP" class="headerlink" title="实现AOP"></a>实现AOP</h3><p>在用代码使用AOP之前，我们先了解其中的一些名词概念：</p><h4 id="通知（Advice）"><a href="#通知（Advice）" class="headerlink" title="通知（Advice）"></a>通知（Advice）</h4><p>通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？<br>Spring切面可以应用5种类型的通知：</p><blockquote><ul><li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li><li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li><li>返回通知（After-returning）：在目标方法成功执行之后调用通知；</li><li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li><li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li></ul></blockquote><table><thead><tr><th>注解</th><th>通知</th></tr></thead><tbody><tr><td>@After</td><td>通知方法会在目标方法返回或抛出异常后调用</td></tr><tr><td>@Before</td><td>通知方法会在目标方法调用之前执行</td></tr><tr><td>@AfterReturning</td><td>通知方法会在目标方法返回后调用</td></tr><tr><td>@AfterThrowing</td><td>通知方法会在目标方法抛出异常后调用</td></tr><tr><td>@Around</td><td>通知方法会将目标方法封装起来</td></tr></tbody></table><h4 id="连接点（Join-point）"><a href="#连接点（Join-point）" class="headerlink" title="连接点（Join point）"></a>连接点（Join point）</h4><p>连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。(<code>被拦截到的点</code>，因为Spring只支持<code>方法类型</code>的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器)</p><h4 id="切点（Pointcut）"><a href="#切点（Pointcut）" class="headerlink" title="切点（Pointcut）"></a>切点（Pointcut）</h4><p>如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处” 。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。（对连接点进行<code>拦截</code>的定义）。</p><h4 id="切面（Aspect）"><a href="#切面（Aspect）" class="headerlink" title="切面（Aspect）"></a>切面（Aspect）</h4><p>通知+切点=切面</p><h4 id="引入（Introduction）"><a href="#引入（Introduction）" class="headerlink" title="引入（Introduction）"></a>引入（Introduction）</h4><p>引入允许我们向现有的类添加新方法或属性</p><h4 id="织入（Weaving）"><a href="#织入（Weaving）" class="headerlink" title="织入（Weaving）"></a>织入（Weaving）</h4><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：</p><blockquote><ul><li><strong>编译期：</strong>切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li><strong>类加载期：</strong>切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。</li><li><strong>运行期：</strong>切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个<code>代理对象</code>。<strong>Spring AOP就是以这种方式织入切面的。</strong></li></ul></blockquote><p><strong>Spring对AOP的支持:</strong></p><blockquote><p>1.基于代理的经典Spring AOP；<br>2.纯POJO切面（4.x版本需要XML配置）；<br>3.@AspectJ注解驱动的切面；<br>4.注入式AspectJ切面（适用于Spring各版本）。</p></blockquote><p>前三种都是Spring AOP实现的变体，Spring AOP构建在<code>动态代理</code>基础之上，因此，Spring对AOP的支持局限于方法拦截。也就是说，AspectJ才是王道。</p><p><strong>XML中声明切面</strong></p><table><thead><tr><th>AOP配置元素</th><th>用途</th></tr></thead><tbody><tr><td><code>&lt;aop:advisor&gt;</code></td><td>定义AOP通知器</td></tr><tr><td><code>&lt;aop:after&gt;</code></td><td>定义AOP后置通知（不管被通知的方法是否执行成功）</td></tr><tr><td><code>&lt;aop:after-returning&gt;</code></td><td>定义AOP返回通知</td></tr><tr><td><code>&lt;aop:after-throwing&gt;</code></td><td>定义AOP异常通知</td></tr><tr><td><code>&lt;aop:around&gt;</code></td><td>定义AOP环绕通知</td></tr><tr><td><code>&lt;aop:aspect&gt;</code></td><td>定义一个切面</td></tr><tr><td><code>&lt;aop:aspectj-autoproxy&gt;</code></td><td>启用@AspectJ注解驱动的切面</td></tr><tr><td><code>&lt;aop:before&gt;</code></td><td>定义一个AOP前置通知</td></tr><tr><td><code>&lt;aop:config&gt;</code></td><td><code>顶层的AOP配置元素。大多数的&lt;aop:*&gt;元素必须包含在&lt;aop:config&gt;元素内</code></td></tr><tr><td><code>&lt;aop:declare-parents&gt;</code></td><td>以透明的方式为被通知的对象引入额外的接口</td></tr><tr><td><code>&lt;aop:pointcut&gt;</code></td><td>定义一个切点</td></tr></tbody></table><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">Performance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来写一个切点表达式，这个表达式能够设置当perform()方法执行时触发通知的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">execution(* concert.Performance.perform(..))</span><br><span class="line"><span class="comment">//execution：在方法执行时触发</span></span><br><span class="line"><span class="comment">//*：返回任意类型</span></span><br><span class="line"><span class="comment">//concert.Performance：方法所属类</span></span><br><span class="line"><span class="comment">//perform：方法名</span></span><br><span class="line"><span class="comment">//(..)：使用任意参数</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Silencing cell phones"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taskSeats</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Talking seats"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefund</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过XML将无注解的Audience声明为切面:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">  &lt;aop:aspect ref=<span class="string">"audience"</span>&gt;</span><br><span class="line">    &lt;aop:before</span><br><span class="line">      pointcut =<span class="string">"execution(** concert.Performance.perform(..))"</span></span><br><span class="line">      method=<span class="string">"sillenceCellPhones"</span>/&gt;</span><br><span class="line">    &lt;aop:before</span><br><span class="line">      pointcut =<span class="string">"execution(** concert.Performance.perform(..))"</span></span><br><span class="line">      method=<span class="string">"taskSeats"</span>/&gt;</span><br><span class="line">    &lt;aop:after-returning</span><br><span class="line">      pointcut =<span class="string">"execution(** concert.Performance.perform(..))"</span></span><br><span class="line">      method=<span class="string">"applause"</span>/&gt;</span><br><span class="line">    &lt;aop:After-throwing</span><br><span class="line">        pointcut =<span class="string">"execution(** concert.Performance.perform(..))"</span></span><br><span class="line">        method=<span class="string">"demanRefund"</span>/&gt;</span><br><span class="line">  &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><h2 id="关于Spring-Bean"><a href="#关于Spring-Bean" class="headerlink" title="关于Spring Bean"></a>关于Spring Bean</h2><p>Spring的ioc容器功能非常强大，负责Spring的Bean的创建和管理等功能。而Spring 的bean是整个Spring应用中很重要的一部分，了解Spring Bean的生命周期对我们了解整个spring框架会有很大的帮助。<br>BeanFactory和ApplicationContext是Spring两种很重要的容器,前者提供了最基本的依赖注入的支持，而后者在继承前者的基础进行了功能的拓展，例如增加了事件传播，资源访问和国际化的消息访问等功能。</p><h3 id="Bean的声明周期"><a href="#Bean的声明周期" class="headerlink" title="Bean的声明周期"></a>Bean的声明周期</h3><p>首先看下生命周期图：<br><img src="bean.jpg" alt="bean"></p><p>再谈生命周期之前有一点需要先明确：</p><blockquote><p>Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p></blockquote><p>如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。我们对图进行详细描述：</p><blockquote><ol><li>Spring对bean进行实例化； </li><li>Spring将值和bean的引用注入到bean对应的属性中；</li><li>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</li><li>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</li><li>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</li><li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</li><li>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用init-method声明了初始化方法，该方法也会被调用；</li><li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</li><li>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</li><li>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</li></ol></blockquote><h3 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><p>Spring定义了多种Bean作用域，可以基于这些作用域创建bean，包括：</p><blockquote><ul><li>单例（Singleton）：在整个应用中，只创建bean的一个实例。</li><li>原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。</li><li>会话（Session）：在Web应用中，为每个会话创建一个bean实例。</li><li>请求（Rquest）：在Web应用中，为每个请求创建一个bean实例。</li></ul></blockquote><p>在默认情况下，Spring应用上下文中所有bean都是作为以<code>单例（singleton）</code>的形式创建的。也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。</p><p>在<code>大多数</code>情况下，<code>单例bean</code>是很理想的方案。初始化和垃圾回收对象实例所带来的成本只留给一些小规模任务，在这些任务中，让对象保持无状态并且在应用中反复重用这些对象可能并不合理。</p><p>有时候，可能会发现，你所使用的类是<code>易变的</code>（mutable），它们会保持一些状态，因此<code>重用</code>是不安全的。在这种情况下，将class声明为单例的bean就不是什么好主意了，因为对象会被<code>污染</code>，稍后重用的时候会出现意想不到的问题。</p><h3 id="声明Bean"><a href="#声明Bean" class="headerlink" title="声明Bean"></a>声明Bean</h3><p>以下是声明Bean的注解：</p><blockquote><ul><li>@Component 组件，没有明确的角色</li><li>@Service 在业务逻辑层使用</li><li>@Repository 在数据访问层使用</li><li>@Controller 在展现层使用(MVC -&gt; Spring MVC)使用</li></ul></blockquote><p>在这里，可以指定bean的id名：<code>Component(&quot;yourBeanName&quot;)</code><br>同时，Spring支持将<code>@Named</code>作为<code>@Component</code>注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，它们是可以<code>互相替换</code>的。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Spring-AOP之Around增强处理"><a href="#Spring-AOP之Around增强处理" class="headerlink" title="Spring AOP之Around增强处理"></a>Spring AOP之Around增强处理</h3><p>@Around注解用于修饰Around增强处理，Around增强处理是功能比较强大的增强处理，它近似于Before增强处理和AfterReturing增强处理的总结，Around增强处理既可在执行目标方法之前增强动作，也可在执行目标方法之后织入增强的执行。与Before增强处理、AfterReturning增强处理不同的是，<strong>Around增强处理可以决定目标方法在什么时候执行，如何执行，甚至可以完全阻止目标方法的执行。</strong></p><p>当定义一个Around增强处理方法时，该方法的 ==第一个形参必须是ProceedJoinPoint类型==（至少含有一个形参），在增强处理方法体内，<strong>调用ProceedingJoinPoint参数的procedd()方法才会执行目标方法</strong>——这就是Around增强处理可以完全控制方法的执行时机、如何执行的关键；如果程序没有调用ProceedingJoinPoint参数的proceed()方法，则目标方法不会被执行。下面定义一个Around增强处理。</p><p>AspectJ使用org.aspectj.lang.JoinPoint接口表示目标类连接点对象，如果是环绕增强时，使用org.aspectj.lang.ProceedingJoinPoint表示连接点对象，该类是JoinPoint的子接口。任何一个增强方法都可以通过将第一个入参声明为JoinPoint访问到连接点上下文的信息。我们先来了解一下这两个接口的主要方法：</p><p>1)JoinPoint</p><blockquote><ul><li>java.lang.Object[] getArgs()：获取连接点方法运行时的入参列表；</li><li>Signature getSignature() ：获取连接点的方法签名对象；</li><li>java.lang.Object getTarget() ：获取连接点所在的目标对象；</li><li>java.lang.Object getThis() ：获取代理对象本身；</li></ul></blockquote><p>2)ProceedingJoinPoint</p><blockquote><p>ProceedingJoinPoint继承JoinPoint子接口，它新增了两个用于执行连接点方法的方法：</p><ul><li>java.lang.Object proceed() throws java.lang.Throwable：通过反射执行目标对象的连接点处的方法；</li><li>java.lang.Object proceed(java.lang.Object[] args) throws java.lang.Throwable：通过反射执行目标对象连接点处的方法，不过使用新的入参替换原来的入参。</li></ul></blockquote><hr><p>SpringAOP的概念：</p><blockquote><ul><li>切面（Aspect）：切面用于组织多个Advice，Advice放在切面中定义。 </li><li>连接点（Joinpoint）：程序执行过程中明确的点，如方法的调用，或者异常的抛出。在Spring AOP中，连接点总是方法的调用。 </li><li>增强处理（Advice）：AOP框架在特定的切入点执行的增强处理。处理有“around”、“before”和“after”等类型。 </li><li>切入点（Pointcut）：可以插入增强处理的连接点。</li></ul></blockquote><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">@interface</span> MethodLog &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是什么意思</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="keyword">module</span>() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>  type() <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）@Target({ElementType.METHOD,ElementType.TYPE}) ：</p><p>用于描述注解的使用范围（即：被描述的注解可以用在什么地方），其取值有：</p><blockquote><ul><li>CONSTRUCTOR： 用于描述构造器。</li><li>FIELD： 用于描述域。 </li><li>LOCAL_VARIABLE： 用于描述局部变量。 </li><li>METHOD： 用于描述方法。 </li><li>PACKAGE： 用于描述包。 </li><li>PARAMETER： 用于描述参数。 </li><li>TYPE： 用于描述类或接口（甚至 enum ）。</li></ul></blockquote><p>2）@Retention(RetentionPolicy.RUNTIME)：</p><p>用于描述注解的生命周期（即：被描述的注解在什么范围内有效），其取值有：</p><blockquote><ul><li>SOURCE： 在源文件中有效（即源文件保留）。 </li><li>CLASS： 在 class 文件中有效（即 class 保留）。 </li><li>RUNTIME： 在运行时有效（即运行时保留）。</li></ul></blockquote><p>3）@Documented 在默认的情况下javadoc命令不会将我们的annotation生成再doc中去的，所以使用该标记就是告诉jdk让它也将annotation生成到doc中去</p><h3 id="Sring-AOP-失效，自我调用"><a href="#Sring-AOP-失效，自我调用" class="headerlink" title="Sring AOP 失效，自我调用"></a>Sring AOP 失效，自我调用</h3><p>在使用AOP进行拦截的时候发现有些方法有时候能输出拦截的日志有时候不输出拦截的日志。发现在单独调用这些方法的时候是有日志输出，在被同一个类中的方法调用的时候没有日志输出。</p><p>这里先说一下AOP拦截不到自我调用方法的原因：假设我们有一个类是ServiceA，这个类中有一个A方法，A方法中又调用了B方法。当我们使用AOP进行拦截的时候，首先会创建一个ServiceA的代理类，其实在我们的系统中是存在两个ServiceA的对象的，一个是目标ServiceA对象，一个是生成的代理ServiceA对象，如果在代理类的A方法中调用代理类的B方法，这个时候AOP拦截是可以生效的，但是如果在代理类的A方法中调用目标类的B方法，这个时候AOP拦截是不生效的，大多数情况下我们都是在代理类的A方法中直接调用目标类的B方法。</p><h3 id="示例如下："><a href="#示例如下：" class="headerlink" title="示例如下："></a>示例如下：</h3><p><strong>自定义注解</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MethodLog &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">module</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span>  <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Bean类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspectModel</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">    <span class="comment">//逻辑标识id，用来标志同一个链,id一样的为同一次任务的不同方法</span></span><br><span class="line">    <span class="keyword">private</span> String flagId;</span><br><span class="line">    <span class="comment">//表示这个记录是做什么子目标，二级子目标，三级子目标，等等</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="keyword">module</span>;</span><br><span class="line">    <span class="comment">//状态0正常，1不正常</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">    <span class="comment">//备注</span></span><br><span class="line">    <span class="keyword">private</span> String remark;</span><br><span class="line">    <span class="comment">//异常原因</span></span><br><span class="line">    <span class="keyword">private</span> String exception;</span><br><span class="line">    <span class="comment">//耗时</span></span><br><span class="line">    <span class="keyword">private</span> String consumeTime;</span><br><span class="line">    <span class="comment">//类名</span></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="comment">//入参</span></span><br><span class="line">    <span class="keyword">private</span> String inParameters;</span><br><span class="line">    <span class="comment">//出参</span></span><br><span class="line">    <span class="keyword">private</span> String outParameters;</span><br><span class="line">    <span class="comment">//方法名</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="comment">//时间</span></span><br><span class="line">    <span class="keyword">private</span> String time;</span><br></pre></td></tr></table></figure><p><strong>使用Spring AOP技术，定义切点和切面，使用@Around环绕通知：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspectAdvice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(LogAspectAdvice.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NamedThreadLocal&lt;String&gt; flagId = <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"flag"</span>);</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.wwwarehouse.ccp..*(..))&amp;&amp;@annotation(MethodLog)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LogAspectModel logAspectModel = <span class="keyword">new</span> LogAspectModel();</span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtil.hasNull(flagId.get())) &#123;</span><br><span class="line">            <span class="comment">//线程绑定变量（该数据只有当前请求的线程可见）</span></span><br><span class="line">            flagId.set(beginTime + UUID.randomUUID().toString().replaceAll(<span class="string">"-"</span>, <span class="string">""</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = getMethodLog(point);</span><br><span class="line">        <span class="comment">//入参</span></span><br><span class="line">        logAspectModel.setInParameters(map.get(<span class="string">"param"</span>));</span><br><span class="line">        logAspectModel.setModule(map.get(<span class="string">"module"</span>));</span><br><span class="line">        <span class="comment">//方法名</span></span><br><span class="line">        logAspectModel.setMethodName(map.get(<span class="string">"methodName"</span>));</span><br><span class="line">        <span class="comment">//类名</span></span><br><span class="line">        logAspectModel.setClassName(point.getTarget().getClass().toString());</span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object = point.proceed();</span><br><span class="line">            logAspectModel.setStatus(<span class="string">"1"</span>);</span><br><span class="line">            logAspectModel.setRemark(<span class="string">"成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logAspectModel.setStatus(<span class="string">"0"</span>);</span><br><span class="line">            logAspectModel.setRemark(<span class="string">"失败"</span>);</span><br><span class="line">            logAspectModel.setException(getExceptionTrace(e));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束时间</span></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> time = endTime - beginTime;</span><br><span class="line">        logAspectModel.setConsumeTime(String.valueOf(time));</span><br><span class="line">        logAspectModel.setTime(DateUtil.toDateTimeString(<span class="keyword">new</span> Date()));</span><br><span class="line">        logAspectModel.setFlagId(flagId.get());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtil.isEmpty(object)) &#123;</span><br><span class="line">            String simpleName = object.getClass().getSimpleName();</span><br><span class="line">            logAspectModel.setOutParameters(<span class="string">"["</span> + simpleName + <span class="string">" : "</span> + JSON.toJSONString(object) + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//日志打印</span></span><br><span class="line">        generateLog(logAspectModel);</span><br><span class="line">        <span class="keyword">if</span> (atomicInteger.decrementAndGet() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flagId.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateLog</span><span class="params">(LogAspectModel logAspectModel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Objects.equals(logAspectModel.getStatus(), <span class="string">"0"</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"AOP日志:&#123;&#125;"</span>, logAspectModel.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">"AOP日志:&#123;&#125;"</span>, logAspectModel.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取日志注解标注信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">getMethodLog</span><span class="params">(ProceedingJoinPoint joinPoint)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Class targetClass = joinPoint.getTarget().getClass();</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        map.put(<span class="string">"methodName"</span>, methodName);</span><br><span class="line"></span><br><span class="line">        Method[] method = targetClass.getMethods();</span><br><span class="line">        <span class="comment">//获取参数值</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"["</span>);</span><br><span class="line">        <span class="keyword">for</span> (Method m : method) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!m.getName().equals(methodName)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">                    sb.append(arg.getClass().getSimpleName());</span><br><span class="line">                    sb.append(<span class="string">":"</span>);</span><br><span class="line">                    sb.append(JSON.toJSONString(arg));</span><br><span class="line">                    <span class="keyword">if</span> (++i &lt; args.length) &#123;</span><br><span class="line">                        sb.append(<span class="string">","</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">"]"</span>);</span><br><span class="line">            map.put(<span class="string">"param"</span>, sb.toString());</span><br><span class="line">            MethodLog methodCache = m.getAnnotation(MethodLog.class);</span><br><span class="line">            <span class="keyword">if</span> (methodCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">                map.put(<span class="string">"module"</span>, methodCache.<span class="keyword">module</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取异常信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getExceptionTrace</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        StringWriter sw = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        PrintWriter pw = <span class="keyword">new</span> PrintWriter(sw);</span><br><span class="line">        e.printStackTrace(pw);</span><br><span class="line">        pw.flush();</span><br><span class="line">        pw.close();</span><br><span class="line">        <span class="keyword">return</span> sw.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>测试Demo代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoAOPImpl</span> <span class="keyword">implements</span> <span class="title">DemoAOP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(DemoAOPImpl.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    DemoAOPImpl demoAOP;</span><br><span class="line">    <span class="keyword">public</span> String flagId = <span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MethodLog</span>(<span class="keyword">module</span> = <span class="string">"ll"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">handle</span><span class="params">(List&lt;String&gt; list, String s)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        ((DemoAOPImpl)AopContext.currentProxy()).demo(list.get(0),"ffff");</span></span><br><span class="line">        demo(list.get(<span class="number">0</span>), <span class="string">"ffff"</span>);   <span class="comment">//直接调用的时候，这个方法AOP失效</span></span><br><span class="line">        logger.info(<span class="string">"======================"</span>+list.get(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@MethodLog</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">demo</span><span class="params">(String b, String ff)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"b==="</span> + b);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试：</strong><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">DemoAOP</span> demoAOP;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    public void handle() &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">String</span>&gt; list = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"hahha"</span>);</span><br><span class="line"></span><br><span class="line">       demoAOP.handle(list,<span class="string">"fan"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>结果：</strong></p><p><strong>测试发现只生成了handle方法的日志demo方法AOP失效。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">handle方法日志结果：</span><br><span class="line">com.wwwarehouse.ccp.aop.LogAspectAdvice.generateLog(LogAspectAdvice.java:<span class="number">90</span>) - AOP日志:LogAspectModel&#123; flagId=<span class="string">'154726241777110862bb3174049af8b320c818b635a07'</span>, status=<span class="string">'1'</span>, remark=<span class="string">'成功'</span>, exception=<span class="string">'null'</span>, className=<span class="string">'class com.wwwarehouse.ccp.aop.DemoAOPImpl'</span>, methodName=<span class="string">'handle'</span>, inParameter=<span class="string">'[ArrayList:["hahha"],String:"fan"]'</span>, outParameter=<span class="string">'[Integer : 2]'</span>, consumeTime(ms)=<span class="string">'1426'</span>, <span class="keyword">module</span>=<span class="string">'ll'</span>, finishTime=<span class="string">'2019-01-12 11:06:59'</span>&#125;</span><br></pre></td></tr></table></figure><p>测试中发现无论demo方法是否加注解@MethodLog，demo方法都不能生成AOP日志，而handle方法却没有影响。</p><p><strong>总结就是：自调用的第二个方法AOP总是失效的。</strong></p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p><strong>上面例子中，在handle()方法里面直接调用demo(……)方法，这里还隐含一个关键字，那就是this，实际上这里调用是这样的：this.demo(),this是当前对象。而调用handle()是的对象是被代理的，在代理对象中执行增强后，通过invoke，用实际DemoAOPImpl对象来调用handle()方法执行业务逻辑。在业务逻辑内又调用了demo(……)方法，调用的对象是当前对象，当前对象是DemoAOPImpl，问题就出在这里，因为要想用执行demo()方法的增强，必须用代理对象执行，但是此时却直接用DemoAOPImpl对象调用，绕过了代理对象增强的部分，也就是说代理增强部分失效。在同一个类中使用@Transaction,@Async并不能实现事务和异步，道理就是这样的。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用Spring框架中，对于源码的分析还是过少，在以后的工作中要学习Spring的代码设计。增强自己对架构的理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;人生而迷茫吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;学了Spring框架那么久，也没有很好总结过，
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>怕</title>
    <link href="http://yoursite.com/2018/08/31/%E6%80%95/"/>
    <id>http://yoursite.com/2018/08/31/怕/</id>
    <published>2018-08-31T01:00:00.000Z</published>
    <updated>2018-09-19T15:40:36.899Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>抬起头，又底下</p></blockquote><p>当我遇到自己的理想和行为不一致的时候，我就会审视自己的内心，拷问自己的灵魂，你是否还记的那些理想，是否还记得曾经的誓言。</p><p>当我胆小怕事的时候，我总是问自己，你到底在害怕什么？</p><blockquote><p>你和我一样背负着与众不同的秘密在活着。你的眼睛告诉我，仇恨和恐惧，那是什么样的经历造就的！而后再用杀人来掩盖这种感受吗！你敢不敢问自己，到底要去哪里！背负着恐惧寻找的终点，非要是末路吗！你能听到吗！你还能听到吗！你还有勇气直面你的恐惧吗！</p></blockquote><p>每个人的发展都是首先从单维度开始的，如果一开始对单维度的技能没有达到极致，就暂时不要进行多维度的发展，不但不能起到快速进步的地步，还会影响到原来单维度的发展。</p><hr><p>环境的改变自己才会在这个环境中学的更好。可以说环境是最影响进步的一个助力，在符合的环境中学习才会让你学有所用所得。</p><hr><p>每个人都会鄙视自己，因为鄙视自己，所以才会想要进步，想要努力。不满足源于内心无尽的鄙视。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;抬起头，又底下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当我遇到自己的理想和行为不一致的时候，我就会审视自己的内心，拷问自己的灵魂，你是否还记的那些理想，是否还记得曾经的誓言。&lt;/p&gt;
&lt;p&gt;当我胆小怕事的时候，我总是问自己，你到底在害怕什么？&lt;
      
    
    </summary>
    
      <category term="所思" scheme="http://yoursite.com/categories/%E6%89%80%E6%80%9D/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JMM和volatile与synchronized</title>
    <link href="http://yoursite.com/2018/08/26/JMM%E5%92%8Cvolatile%E4%B8%8Esynchronized/"/>
    <id>http://yoursite.com/2018/08/26/JMM和volatile与synchronized/</id>
    <published>2018-08-26T04:00:00.000Z</published>
    <updated>2019-01-21T07:14:27.561Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>好的习惯可以影响人一生</p></blockquote><hr><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在一开始的学习java的时候，一直认为<code>JMM（Java Memory Model）</code>和<code>Java内存区域</code>是一个东西。后面深入学习后，<code>Java内存区域</code>是JVM在运行程序时会把其自动管理的内存划分为以上几个区域，每个区域都有的用途以及创建销毁的时机。<code>JMM</code>则是本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p><hr><h1 id="JMM-Java-Memory-Model"><a href="#JMM-Java-Memory-Model" class="headerlink" title="JMM(Java Memory Model)"></a>JMM(Java Memory Model)</h1><p>Java内存区域就不在过多的介绍，有兴趣可以看我以前写的关于深入理解JVM的内容。<br>在执行程序时JVM运行程序的实体是<code>线程</code>，而每个线程创建时JVM都会为其创建一个<code>工作内存</code>(有些地方称为<code>栈空间</code>)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在<code>主内存</code>，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，<strong>首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存</strong>，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:<br><img src="JMM.jpg" alt="1"><br>JMM与Java内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，<strong>JMM是围绕原子性，有序性、可见性展开的</strong>。这也是我们在并发操作，或者使用多线程执行的时候围绕这三个原则来保证数据的同步。</p><p>对于一个实例对象中的成员方法而言，如果<code>方法中</code>包含本地变量是<code>基本数据类型</code>（boolean,byte,short,char,int,long,float,double），将直接存储在工作内存的<code>帧栈</code>结构中，但倘若<code>本地变量是引用类型</code>，那么该变量的<code>引用</code>会存储在功能内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。但对于<code>实例对象的成员变量</code>，不管它是<code>基本数据类型</code>或者<code>包装类型</code>(Integer、Double等)还是<code>引用类型</code>，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存，</p><p>总结来说一句话：<strong>方法中的局部变量是基本类型就直接操作个线程的栈中，引用变量值存在主内存中。而对象成员变量都存放在主内存中。</strong></p><h2 id="为什么需要JMM，它试图解决什么问题"><a href="#为什么需要JMM，它试图解决什么问题" class="headerlink" title="为什么需要JMM，它试图解决什么问题"></a>为什么需要JMM，它试图解决什么问题</h2><p>Java 是最早尝试提供内存模型的语言，这是简化多线程编程、保证程序可移植性的一个飞跃。早期类似 C、C++ 等语言，并不存在内存模型的概念（C++ 11 中也引入了标准内存模型），其行为依赖于处理器本身的内存一致性模型，但不同的处理器可能差异很大，所以一段 C++ 程序在处理器 A 上运行正常，并不能保证其在处理器 B 上也是一致的。</p><p>即使如此，最初的 Java 语言规范仍然是存在着缺陷的，当时的目标是，希望 Java 程序可以充分利用现代硬件的计算能力，同时保持“书写一次，到处执行”的能力。</p><p>但是，显然问题的复杂度被低估了，随着 Java 被运行在越来越多的平台上，人们发现，过于泛泛的内存模型定义，存在很多模棱两可之处，对 synchronized 或 volatile 等，类似指令重排序时的行为，并没有提供清晰规范。这里说的指令重排序，既可以是编译器优化行为，也可能是源自于现代处理器的乱序执行等。</p><p>换句话说：</p><blockquote><ul><li><p>既不能保证一些多线程程序的正确性，例如最著名的就是双检锁（Double-Checked Locking，DCL）的失效问题，双检锁可能导致未完整初始化的对象被访问，理论上这叫并发编程中的安全发布（Safe Publication）失败。</p></li><li><p>也不能保证同一段程序在不同的处理器架构上表现一致，例如有的处理器支持缓存一致性，有的不支持，各自都有自己的内存排序模型。</p></li></ul></blockquote><p>所以，Java 迫切需要一个完善的 <code>JMM</code>，能够让普通 Java 开发者和编译器、JVM 工程师，能够清晰地达成共识。换句话说，可以<code>相对简单并准确地判断出，多线程程序什么样的执行序列是符合规范的</code>。</p><hr><h1 id="volatile和synchronized"><a href="#volatile和synchronized" class="headerlink" title="volatile和synchronized"></a>volatile和synchronized</h1><p>volatile在并发编程中很常见，但也容易被滥用，现在我们就进一步分析volatile关键字的语义。volatile是Java虚拟机提供的轻量级的同步机制。volatile关键字有如下两个作用</p><blockquote><ul><li>保证被volatile修饰的共享变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总数可以被其他线程立即得知。</li><li>禁止指令重排序优化。</li></ul></blockquote><h2 id="volatile和synchronized特点"><a href="#volatile和synchronized特点" class="headerlink" title="volatile和synchronized特点"></a>volatile和synchronized特点</h2><p>首先需要理解线程安全的两个方面：<strong>执行控制和内存可见</strong>。<br><code>执行控制</code>的目的是控制代码执行（顺序）及是否可以并发执行。<br><code>内存可见</code>控制的是线程执行结果在内存中对其它线程的可见性。根据Java内存模型的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完成后再把结果从线程本地刷到主存。</p><p>synchronized关键字解决的是<code>执行控制</code>的问题，它会阻止其它线程获取当前对象的监控锁，这样就使得当前对象中被synchronized关键字保护的代码块无法被其它线程访问，也就无法并发执行。更重要的是，synchronized还会创建一个<code>内存屏障</code>，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得先获得这个锁的线程的所有操作，都happens-before于随后获得这个锁的线程的操作。</p><p>volatile关键字解决的是<code>内存可见性</code>的问题，会使得所有对volatile变量的读写都会直接刷到主存，即保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序没有要求的需求。<br>使用volatile关键字仅能实现对原始变量(如boolen、 short 、int 、long等)操作的原子性，但需要特别注意， volatile不能保证复合操作的原子性，即使只是i++，实际上也是由多个原子操作组成：read i; inc; write i，假如多个线程同时执行i++，volatile只能保证他们操作的i是同一块内存，但依然可能出现写入脏数据的情况。<br>在Java 5提供了原子数据类型atomic wrapper classes，对它们的increase之类的操作都是原子操作，不需要使用sychronized关键字。<br>对于volatile关键字，当且仅当满足以下所有条件时可使用：</p><blockquote><ol><li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li><li>该变量没有包含在具有其他变量的不变式中。</li></ol></blockquote><h2 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h2><blockquote><p>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。<br>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的<br>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性<br>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。<br>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p></blockquote><hr><h1 id="volatile和Atomic"><a href="#volatile和Atomic" class="headerlink" title="volatile和Atomic"></a>volatile和Atomic</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="锁（lock）的代价"><a href="#锁（lock）的代价" class="headerlink" title="锁（lock）的代价"></a>锁（lock）的代价</h3><p>锁是用来做并发最简单的方式，当然其代价也是最高的。<strong>内核态的锁的时候需要操作系统进行一次上下文切换，加锁、释放锁会导致比较多的上下文切换和调度延时，等待锁的线程会被挂起直至锁释放</strong>。<strong>在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。</strong> 操作系统对多线程的锁进行判断就像两姐妹在为一个玩具在争吵，然后操作系统就是能决定他们谁能拿到玩具的父母，这是很慢的。用户态的锁虽然避免了这些问题，但是其实它们只是在没有真实的竞争时才有效。</p><p>Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有守护变量的锁，都采用独占的方式来访问这些变量，如果出现多个线程同时访问锁，那第一些线线程将被挂起，当线程恢复执行时，必须等待其它线程执行完他们的时间片以后才能被调度执行，<strong>在挂起和恢复执行过程中存在着很大的开销。锁还存在着其它一些缺点，当一个线程正在等待锁时，它不能做任何事。如果一个线程在持有锁的情况下被延迟执行，那么所有需要这个锁的线程都无法执行下去。</strong> 如果被阻塞的线程优先级高，而持有锁的线程优先级低，将会导致优先级反转(Priority Inversion)。</p><p><strong>与锁相比，volatile变量是一和更轻量级的同步机制，因为在使用这些变量时不会发生上下文切换和线程调度等操作，但是volatile变量也存在一些局限：不能用于构建原子的复合操作，因此当一个变量依赖旧值时就不能使用volatile变量。</strong></p><h3 id="volatile使用准则"><a href="#volatile使用准则" class="headerlink" title="volatile使用准则"></a>volatile使用准则</h3><p>volatile的使用是非常容易出错的，在介绍volatile之前先说两个准则，只要我们的程序能遵循它，咱就可以放心使用volatile变量来实现线程安全。</p><blockquote><ul><li>对变量的写操作不依赖于当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li></ul></blockquote><p>是不是有些头大，其实就是volatile修饰的变量独立于程序的任何状态，包括自己当前的状态。<strong>只有在其状态完全独立于程序其他状态时才可使用volatile变量。</strong></p><blockquote><p>注意：重申一下使用volatile变量的正确条件 –<br><strong>volatile变量必须真正独立于其他变量和其以前的值。还有并发专家也同时告诫我们：尽量远离volatile变量，除非你真正的理解其涵义和使用场景。</strong></p></blockquote><p><strong>不要将volatile用在getAndOperate场合，仅仅set或者get的场景是适合volatile的</strong></p><p>例如你让一个volatile的integer自增（i++），<strong>其实要分成3步：1）读取volatile变量值到local； 2）增加变量的值；3）把local的值写回</strong>，让其它的线程可见。这3步的jvm指令为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov    <span class="number">0xc</span>(%r10),%r8d ; Load</span><br><span class="line">inc    %r8d           ; Increment</span><br><span class="line">mov    %r8d,<span class="number">0xc</span>(%r10) ; Store</span><br><span class="line">lock addl $<span class="number">0x0</span>,(%rsp) ; StoreLoad Barrier</span><br></pre></td></tr></table></figure><p>注意最后一步是内存屏障。</p><h3 id="什么是内存屏障（Memory-Barrier）？"><a href="#什么是内存屏障（Memory-Barrier）？" class="headerlink" title="什么是内存屏障（Memory Barrier）？"></a>什么是内存屏障（Memory Barrier）？</h3><p><strong>内存屏障（memory barrier）是一个CPU指令</strong>。基本上，它是这样一条指令：</p><blockquote><ul><li>a) 确保一些特定操作执行的顺序；</li><li>b) 影响一些数据的可见性(可能是某些指令执行后的结果)。</li></ul></blockquote><p>编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。</p><p><strong>内存屏障（memory barrier）和volatile什么关系</strong>？上面的虚拟机指令里面有提到，如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：</p><blockquote><p>1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。<br>2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。</p></blockquote><h3 id="volatile为什么没有原子性"><a href="#volatile为什么没有原子性" class="headerlink" title="volatile为什么没有原子性?"></a>volatile为什么没有原子性?</h3><p>明白了内存屏障（memory barrier）这个CPU指令，回到前面的JVM指令：从Load到store到内存屏障，一共4步，其中最后一步jvm让这个最新的变量的值在所有线程可见，也就是最后一步让所有的CPU内核都获得了最新的值，<strong>但中间的几步（从Load到Store）是不安全的，中间如果其他的CPU修改了值将会丢失。所以volatile无法保证在内存屏障前的操作，有可能会发生修改</strong>。下面的测试代码可以实际测试voaltile的自增没有原子性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span> _longVal = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopVolatile</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> (val &lt; <span class="number">10000000L</span>) &#123;</span><br><span class="line">               _longVal++;</span><br><span class="line">               val++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopVolatile2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> (val &lt; <span class="number">10000000L</span>) &#123;</span><br><span class="line">               _longVal++;</span><br><span class="line">               val++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">testVolatile</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopVolatile());</span><br><span class="line">       t1.start();</span><br><span class="line">        </span><br><span class="line">       Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopVolatile2());</span><br><span class="line">       t2.start();</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"final val is: "</span> + _longVal);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="为什么AtomicXXX具有原子性和可见性？"><a href="#为什么AtomicXXX具有原子性和可见性？" class="headerlink" title="为什么AtomicXXX具有原子性和可见性？"></a>为什么AtomicXXX具有原子性和可见性？</h3><p>那就不得不提CAS（比较并交换）算法。 其实AtomicLong的源码里也用到了volatile，但只是用来读取或写入，见源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicInteger with the given initial value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicInteger with initial value &#123;<span class="doctag">@code</span> 0&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其CAS虚拟机指令为：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov    <span class="number">0</span>xc(<span class="built_in">%r</span>11),<span class="built_in">%eax</span>       <span class="comment">; Load</span></span><br><span class="line">mov    <span class="built_in">%eax</span>,<span class="built_in">%r</span>8d            </span><br><span class="line">inc    <span class="built_in">%r</span>8d                 <span class="comment">; Increment</span></span><br><span class="line"><span class="keyword">lock</span> cmpxchg <span class="built_in">%r</span>8d,<span class="number">0</span>xc(<span class="built_in">%r</span>11) <span class="comment">; Compare and exchange</span></span><br></pre></td></tr></table></figure><p>因为CAS是基于乐观锁的，也就是说当写入的时候，如果寄存器旧值已经不等于现值，说明有其他CPU在修改，那就继续尝试。所以这就保证了操作的原子性。</p><p><strong>那CAS是什么？为什么能够保证操作的原子性？为什么比volatile更好？</strong></p><hr><h2 id="CAS无锁算法"><a href="#CAS无锁算法" class="headerlink" title="CAS无锁算法"></a>CAS无锁算法</h2><p><strong>要实现无锁（lock-free）的非阻塞算法有多种实现方法，其中CAS（比较与交换，Compare and swap）是一种有名的无锁算法</strong>。CAS, CPU指令，在大多数处理器架构，包括IA32、Space中采用的都是CAS指令，CAS的语义是“我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少”，CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p><p><strong>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做</strong>。CAS无锁算法的C实现如下：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> compare_and_swap (<span class="keyword">int</span>* <span class="keyword">reg</span>, <span class="keyword">int</span> oldval, <span class="keyword">int</span> newval) </span><br><span class="line">&#123;</span><br><span class="line">  ATOMIC();</span><br><span class="line">  <span class="keyword">int</span> old_reg_val = *<span class="keyword">reg</span>;</span><br><span class="line">  <span class="keyword">if</span> (old_reg_val == oldval) </span><br><span class="line">     *<span class="keyword">reg</span> = newval;</span><br><span class="line">  END_ATOMIC();</span><br><span class="line">  <span class="keyword">return</span> old_reg_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CAS（乐观锁算法）的假设前提"><a href="#CAS（乐观锁算法）的假设前提" class="headerlink" title="CAS（乐观锁算法）的假设前提"></a>CAS（乐观锁算法）的假设前提</h3><p>CAS比较与交换的伪代码可以表示为：</p><p>do{<br>       备份旧数据；<br>       基于旧数据构造新数据；<br>}while(!CAS( 内存地址，备份的旧数据，新数据 ))  </p><p><img src="CAS.jpg" alt="CAS"></p><p>（上图的解释：CPU去更新一个值，但如果想改的值不再是原来的值，操作就失败，因为很明显，有其它操作先改变了这个值。）</p><p>就是指当两者进行比较时，<strong>如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作</strong>。容易看出 CAS 操作是基于共享数据不会被修改的假设，采用了类似于数据库的 commit-retry 的模式。当同步冲突出现的机会很少时，这种假设能带来较大的性能提升。</p><h3 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h3><p>CAS并不是完全没有缺陷的，其中一个就是著名的ABA问题，这是通常只在 lock-free 算法下暴露的问题。</p><p><strong>CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</strong></p><blockquote><p>比如说<strong>一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功</strong>，但是不代表这个过程就是没有问题的。</p><p>比如如果链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。因此前面提到的原子操作<code>AtomicStampedReference/AtomicMarkableReference</code>就很有用了。这允许一对变化的元素进行原子操作。</p></blockquote><p>在运用CAS做Lock-Free操作中有一个经典的ABA问题：</p><p>线程1准备用CAS将变量的值由A替换为B，在此之前，线程2将变量的值由A替换为C，又由C替换为A，然后线程1执行CAS时发现变量的值仍然为A，所以CAS成功。但实际上这时的现场已经和最初不同了，尽管CAS成功，但可能存在潜藏的问题，例如下面的例子：</p><p><img src="ABA-1.png" alt="ABA"></p><p>现有一个用单向链表实现的堆栈，栈顶为A，这时线程T1已经知道A.next为B，然后希望用CAS将栈顶替换为B：</p><p>head.compareAndSet(A,B);</p><p>在T1执行上面这条指令之前，线程T2介入，将A、B出栈，再pushD、C、A，此时堆栈结构如下图，而对象B此时处于游离状态：</p><p><img src="ABA-2.png" alt="ABA"></p><p>此时轮到线程T1执行CAS操作，检测发现栈顶仍为A，所以CAS成功，栈顶变为B，但实际上B.next为null，所以此时的情况变为：</p><p><img src="ABA-3.png" alt="ABA"></p><p>其中堆栈中只有B一个元素，C和D组成的链表不再存在于堆栈中，平白无故就把C、D丢掉了。</p><p>以上就是由于ABA问题带来的隐患，各种乐观锁的实现中通常都会用版本戳version来对记录或对象标记，避免并发操作带来的问题.</p><h3 id="高并发环境下优化锁或无锁（lock-free）的设计思路"><a href="#高并发环境下优化锁或无锁（lock-free）的设计思路" class="headerlink" title="高并发环境下优化锁或无锁（lock-free）的设计思路"></a>高并发环境下优化锁或无锁（lock-free）的设计思路</h3><p>服务端编程的3大性能杀手：<strong>1、大量线程导致的线程切换开销。2、锁(锁的代价：内核态上下文切换，大量缓存的数据会失效，挂起和恢复线程消耗大量资源，阻塞线程，CPU利用率不高)。3、非必要的内存拷贝</strong>。在高并发下,对于纯内存操作来说,单线程是要比多线程快的, 可以比较一下多线程程序在压力测试下cpu的sy和ni百分比。</p><p>高并发环境下要实现高吞吐量和线程安全，<strong>两个思路：一个是用优化的锁实现，一个是lock-free的无锁结构</strong>。但非阻塞算法要比基于锁的算法复杂得多。开发非阻塞算法是相当专业的训练，而且要证明算法的正确也极为困难，不仅和具体的目标机器平台和编译器相关，而且需要复杂的技巧和严格的测试。虽然Lock-Free编程非常困难，但是它通常可以带来比基于锁编程更高的吞吐量。所以Lock-Free编程是大有前途的技术。它在线程中止、优先级倒置以及信号安全等方面都有着良好的表现。</p><blockquote><ul><li>优化锁实现的例子：Java中的<code>ConcurrentHashMap</code>，设计巧妙，用桶粒度的锁和锁分离机制，避免了put和get中对整个map的锁定，尤其在get中，只对一个HashEntry做锁定操作，性能提升是显而易见的（详细分析见：<a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/" target="_blank" rel="noopener">《探索 ConcurrentHashMap 高并发性的实现机制》</a> ）。</li><li>Lock-free无锁的例子：CAS（CPU的<code>Compare-And-Swap</code>指令）的利用和LMAX的disruptor无锁消息队列数据结构等。</li></ul></blockquote><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>volatile无法保证原则性。可以使用并发包提供的Atomic* 。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;好的习惯可以影响人一生&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在一开始的学习java的时候，一直认为
      
    
    </summary>
    
      <category term="线程" scheme="http://yoursite.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JMM，volatile，synchronized" scheme="http://yoursite.com/tags/JMM%EF%BC%8Cvolatile%EF%BC%8Csynchronized/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://yoursite.com/2018/08/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/08/19/线程池/</id>
    <published>2018-08-19T01:00:00.000Z</published>
    <updated>2018-11-21T11:13:04.237Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最好是更好的敌人</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>多线程的软件设计可以最大限度地发挥现代多核处理器的计算能力，提高生产系列的吞吐量和性能。但是，线程过多的话，不但不能达到提高性能的目的，还会是性能严重下降，因为过多的线程是CPU忙于进行线程之间的<code>切换</code>，而没有时间执行其他的任务。</p><p><strong>为了避免系统频繁地创建和销毁线程，我们可以让创建的线程进行复用。</strong>如果有同学有过数据库开发的经验，对数据库连接池这个概念应该不会陌生。为了避免每次数据库查询都重新建立和销毁数据库连接，我们可以使用数据库连接池维护一些数据库连接，使其长期保持在一个激活的状态。当系统需要使用数据库时，并不是创建一个新的连接，而是从连接池中获得一个可用的连接即可。反之，当需要关闭连接时，并不真的把连接关闭，而是将这个连接“还”给连接池即可。</p><p>为了方便我们使用线程池，jdk提供了一套Executor框架，如下图所示：<br><img src="线程池.jpg" alt="1"></p><p>以上成员均在java.util.concurrent包中，是JDK并发包的核心类。其中ThreadPoolExecutor表示一个线程池。Executors类则扮演线程池工厂角色，通过Executors可以取得一个具有特定功能的线程池。从UML图中亦可知，ThreadPoolExecutor实现了Executor接口，因此通过这个接口，任何Runnable对象都可以被ThreadPoolExecutor线程池调度。</p><p>Java提供了ExecutorService的两种实现：</p><blockquote><ul><li>ThraedPoolExecutor:标准线程池</li><li>ScheduledThreadPoolExecutor:支持延时任务的线程池</li><li>ForkJoinPool:类似于ThraedPoolExecutor，但是使用work-stealing模式，其会为线程池中的每个线程创建一个队列，从而使用work-stealing（任务窃取）算法使得线程可以从其他线程队列里窃取任务来执行。即如果自己的任务处理完成了，则可以去忙碌的工作线程那里去窃取任务执行。</li></ul></blockquote><p>Executor框架提供了各种类型的线程池，主要有以下工厂方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br></pre></td></tr></table></figure><p><strong>Executors 目前提供了 5 种不同的线程池创建配置：</strong></p><blockquote><ul><li><p>newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。</p></li><li><p>newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。</p></li><li><p>newSingleThreadExecutor()，它的特点在于工作线程数目被限制为1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</p></li><li><p>newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)，创建的是个ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。</p></li><li><p>newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。</p></li></ul></blockquote><h2 id="线程池的内部实现"><a href="#线程池的内部实现" class="headerlink" title="线程池的内部实现"></a>线程池的内部实现</h2><p>无论是newFixedThreadPool()、newSingleThreadExecutor()还是newCacheThreadPool方法，虽然看起来创建的线程具有完全不同的功能特点，但其内部均使用了ThreadPoolExecutor实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,  <span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由以上线程池的实现可以看到，它们都只是ThreadPoolExecutor类的封装。我们看下ThreadPoolExecutor最重要的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            //指定了线程池中的线程数量</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">            //指定了线程池中的最大线程数量</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">            //当前线程池数量超过corePoolSize时，多余的空闲线程的存活时间，即多次时间内会被销毁。</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">            //keepAliveTime的单位</span></span></span><br><span class="line"><span class="function"><span class="params">            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            //任务队列，被提交但尚未被执行的任务。</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            //线程工厂，用于创建线程，一般用默认的即可</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            //拒绝策略，当任务太多来不及处理，如何拒绝任务。</span></span></span><br><span class="line"><span class="function"><span class="params">            RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><h2 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h2><p>workQueue指提交但未执行的任务队列，它是一个BlockingQueue接口的对象，仅用于存放Runnable对象，根据队列功能分类，在ThreadPoolExecutor的构造函数中可使用以下几种BlockingQueue。</p><ol><li>直接提交的队列：</li></ol><p>该功能由synchronousQueue对象提供，synchronousQueue对象是一个特殊的BlockingQueue。synchronousQueue没有容量，每一个插入操作都要等待一个响应的删除操作，反之每一个删除操作都要等待对应的插入操作。如果使用synchronousQueue，提交的任务不会被真实的保存，而总是将新任务提交给线程执行，如果没有空闲线程，则尝试创建线程，如果线程数量已经达到了最大值，则执行拒绝策略，因此，使用synchronousQueue队列，通常要设置很大的maximumPoolSize值，否则很容易执行拒绝策略。</p><ol start="2"><li>有界的任务队列：</li></ol><p>有界任务队列可以使用ArrayBlockingQueue实现。ArrayBlockingQueue构造函数必须带有一个容量参数，表示队列的最大容量。<br>当使用有界任务队列时，若有新任务需要执行时，如果线程池的实际线程数量小于corePoolSize，则会优先创建线程。若大于corePoolSize，则会将新任务加入等待队列。若等待队列已满，无法加入，则在总线程数不大于maximumPoolSize的前提下，创建新的线程执行任务。若大于maximumPoolSize，则执行拒绝策略。可见有界队列仅当在任务队列装满后，才可能将线程数量提升到corePoolSize以上，换言之，除非系统非常繁忙，否则确保核心线程数维持在corePoolSize。</p><ol start="3"><li>无界的任务队列：</li></ol><p>无界队列可以通过LinkedBlockingQueue类实现。与有界队列相比，除非系统资源耗尽，无界队列的任务队列不存在任务入队失败的情况。若有新任务需要执行时，如果线程池的实际线程数量小于corePoolSize，则会优先创建线程执行。但当系统的线程数量达到corePoolSize后就不再创建了，这里和有界任务队列是有明显区别的。若后续还有新任务加入，而又没有空闲线程资源，则任务直接进入队列等待。若任务创建和处理的速度差异很大，无界队列会保持快速增长，知道耗尽系统内存。</p><ol start="4"><li>优先任务队列：</li></ol><p>带有优先级别的队列，它通过PriorityBlokingQueue实现，可以控制任务执行的优先顺序。它是一个特殊的无界队列。无论是ArrayBlockingQueue还是LinkedBlockingQueue实现的队列，都是按照先进先出的算法处理任务，而PriorityBlokingQueue根据任务自身优先级顺序先后执行，在确保系统性能同时，也能很好的质量保证（总是确保高优先级的任务优先执行）。</p><h2 id="自定义线程创建：ThreadFactory"><a href="#自定义线程创建：ThreadFactory" class="headerlink" title="自定义线程创建：ThreadFactory"></a>自定义线程创建：ThreadFactory</h2><p>ThreadFactory是一个接口，它只有一个方法，用来创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br></pre></td></tr></table></figure><p>当线程池需要新建线程时，就会调用这个方法。</p><p>自定义线程池可以帮我们做不少事情。我们可以跟踪线程池在何时创建了多少线程，也可以自定义线程的名称、组以及优先级等信息，甚至可以任性地将所有的线程设置为守护线程。总之，使用自定义线程可以让我们更加自由地设置池中所有的线程的状态。下面的案例使用自定义ThreadFactory，一方面记录了线程的创建，另一方面将所有的线程都设置为守护线程，这样，当主线程退出后，将会强制销毁线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadFactoryExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" coming..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a )</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyTask myTask = <span class="keyword">new</span> MyTask();</span><br><span class="line">        ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>)</span><br><span class="line">                , <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">                        t.setName(<span class="string">"T "</span> + t.getId() + <span class="string">"_"</span> +System.currentTimeMillis());</span><br><span class="line">                        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                        System.out.println(<span class="string">"Create a Thread Name is : "</span>+t.getName());</span><br><span class="line">                        <span class="keyword">return</span> t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            es.submit(myTask);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h2><p>ThreadPoolExecutor是可扩展的，它提供了几个“钩子”方法可以在子类化中改写：beforeExecute、afterExecute和terminated，这些方法可以用于扩展ThreadPoolExecutor的行为。</p><p>在执行任务的线程中将调用beforeExecute和afterExecute等方法，在这些方法中还可以添加日志、计时、监视或统计信息收集的功能。无论任务是从run中正常返回，还是抛出一个异常而返回，afterExecute都会被调用。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这里比较粗糙的研究了一下线程池的一些基本的概念和功能。并发的路上还有很多路要走。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最好是更好的敌人&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;多线程的软件设计可以最大限度地发挥现代多核处理器的计算
      
    
    </summary>
    
      <category term="线程" scheme="http://yoursite.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://yoursite.com/2018/08/13/%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/13/线程/</id>
    <published>2018-08-13T01:00:00.000Z</published>
    <updated>2018-11-20T03:19:48.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>深感自己的能力的不足，此处仅仅是对知识的记录和总结，许多地方都是借鉴他人的语句</p></blockquote><hr><h2 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h2><p><strong>想要了解线程，必须首先知道进程，并知道他与线程的区别是什么？</strong></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong>进程</strong></h3><p>通常，我们把一个程序的执行称为一个进程。反过来讲，进程用于描述程序的执行过程。因此，程序和进程是一对概念，它们分別描述了一个程序的静态和动态特征：除此之外，进程还操作系统进行资源分配的一个基本单位。</p><h4 id="进程的衍生"><a href="#进程的衍生" class="headerlink" title="进程的衍生"></a><strong>进程的衍生</strong></h4><p>进程使用<code>fork</code>（）系统调用来创建。父进程调用<code>fork</code>创建子进程。每个子进程都是源自它的父进程的一个副本，它会获得父进程的数据段、堆和栈的副本，并与父进程共享代码段。每一份副本都是独立的，子进程对属于它的副本的修改对其父进程和兄弟进程（同父进程）都是不可见的，反之亦然。全盘复制父进程的数据是一种相当低效的做法。 Linux操作系统内核使用写时复制（Copy on Write,常简称为COW，<strong>也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</strong>)等技术来提高进程创建的效率。当然，刚创建的子进程也可以通过系统调用exec把一个新的程序加载到自己的内存中，而原先在内存中的数据段、堆、栈以及代码段就会被替换掉，在这之后，子进程执行的就会是那个刚刚加载进来的新程序（意思就是当传入的参数或者变量不同的时候，子进程就相当于在做自己的事情）。</p><p><strong>父进程被如果优先于子进程结束，那么子进程就会被原来父进程的父进程“收养”（也就是子进程的爷爷）。</strong></p><p>为了管理进程，内核必须对每个进程的数据和行为进行详细的记录，包括进程的优先级、状态、虚拟地址范围以及各种访问权限等等。更具体地说，这些信息都会被记在每个进程的进程描述符中。进程描述符并不是一个简单的符号，而是一个非常复杂的数据结构。保存在进程描述符中的进程ID (常称为PID )是进程在操作系统中的唯一标识，其中<strong>进程ID为1的进程就是之前提到的内核启动进程</strong>。进程id是一个非负整数且总是顺序的编号，新创建的进程ID总是前一个进程ID递增的结果。此外，进程ID也可以重复使用。当进程ID达到其最大限值时，内核会从头开始查找闲置的进程ID并使用M先找到的那一个作为新进程的ID。另外，进程描述符中还会包含当前进程的父进程的ID (常称为PPID )。</p><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><p>进程通信叫做IPC(Inter-Process Communication)，Linux中通信的方式大致可分成三种：</p><ol><li>基于通信的IPC</li><li>基于信号的IPC</li><li>基于同步的IPC</li></ol><p><strong>通信IPC</strong></p><ul><li>以数据为传送手段的IPC</li></ul><blockquote><p>管道(pipe)：用于传输字节流<br>消息队列(message queue)：用来传输结构化的对象</p></blockquote><ul><li>以共享内存为手段的IPC</li></ul><blockquote><p>共享内存区（share memory)：最快的IPC方法</p></blockquote><p> <strong>信号IPC</strong></p><blockquote><p>操作系统的信号（signal）机制：唯一一种异步IPC方法。通过kill -l查看。</p></blockquote><p><strong>同步IPC</strong></p><blockquote><p>信号量（semaphore）</p></blockquote><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程可以视为进程中的控制流。一个进程至少包含一个线程，因为其他至少会有一个控制流持续运行。因而，<strong>一个进程的第一个线程会随着这个进程的启动而创建</strong>，这个线程被称为该进程的主线程。当然，一个进程可以包含多个线程。这些线程都是由当前线程中已经存在的线程创建出来的，创建的方法就是系统调用（pthread_create）。<strong>拥有多个线程的进程可以并发执行多个任务，并且即时某个或某些任务被阻塞，也不会影响其他任务执行，这可以大大改善程序的响应时间和吞吐量</strong>。另一方面，线程不可能独立于进程存在。它的生命周期不可能逾越所属进程的生命周期。</p><p>一个进程中的所有线程都拥有自己线程栈，并以此存储自己的私有数据。这些线程的线程栈都包含在其所属进程的虚拟内存地址中。不过要注意，一个进程中的很多资源都会被其中的所有线程共享，这些被线程共享的资源包含当前进程所持有文件描述符，等等。正因为如此，同一个进程的多个线程运行的一定是同一个程序，只不过具体的控制流程的执行函数可能有所不同。在同一个进程的多个线程之间共享数据也是一件非常轻松和自然的事情。另外，创建一个新线程，也不会像创建一个新进程那样耗时费力，因为在其所属进程的虚拟内存地址中存储的代码、数据和资源都不需要被复制。</p><p>和进程一样，每个线程都有自己的ID（由内核分配），叫做线程ID或者TID。但是在操作系统范围内不唯一，在所属进程的范围内唯一。</p><h3 id="多线程的三大特性"><a href="#多线程的三大特性" class="headerlink" title="多线程的三大特性"></a>多线程的三大特性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个人操作一旦开始，就不会被其他的线程干扰。</p><h4 id="可见性（Visibility）"><a href="#可见性（Visibility）" class="headerlink" title="可见性（Visibility）"></a>可见性（Visibility）</h4><p>可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。显然，对于串行程序来说，可见性问题是不存在的。因为你在任何一个操作步骤中修改了某个变量，那么在后续的步骤中，读取这个变量的值，一定是修改后的新值。</p><h4 id="有序性（Ordering）"><a href="#有序性（Ordering）" class="headerlink" title="有序性（Ordering）"></a>有序性（Ordering）</h4><p>有序性问题是三个问题中最难理解的。对于一个线程的执行代码而言，我们总是习惯地认为代码的执行是从先往后，依次执行。这么理解也不是说完全错误，因为就一个线程内而言，确实会表现成这样。但是，在并发时，程序的执行可能就会出现乱序。给人直观的感觉就是：写在前面的代码，会在后面执行。然而有序性的问题的原因因为是程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。</p><h3 id="哪些指令不能重排——Happen-Before规则"><a href="#哪些指令不能重排——Happen-Before规则" class="headerlink" title="哪些指令不能重排——Happen-Before规则"></a>哪些指令不能重排——Happen-Before规则</h3><blockquote><p>1.程序顺序原则：一个线程内保证语义的串行性<br>2.volatile规则：volatile变量的写，先发生与读，这保证了volatile变量的可见性。一般用volatile修饰的都是经常修改的对象。<br>3.锁规则：解锁（unlock）必然发生在随后的加锁（lock）前<br>4.传递性：A先于B，B先于C，那么A必然先于C<br>5.线程的start（）方法先于它的每一个动作<br>6.线程的所有操作先于线程的终结（Thread.join()）<br>7.线程的中断（interrupt()）先于被中断线程的代码<br>8.对象的构造函数执行、结束先于finalize()方法</p></blockquote><hr><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><h3 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h3><p>在线程的生命周期中，它要经过<strong>新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态</strong>。尤其是当线程启动以后，它不可能一直”霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换</p><p><img src="./attachments/1535250738191.drawio.html" alt="Diagram"></p><p><img src="生命周期.jpg" alt="生命周期"></p><ol><li>新建状态，当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值</li><li>就绪状态，当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行</li><li>运行状态，如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态</li><li>阻塞状态，当处于运行状态的线程失去所占用资源之后，便进入阻塞状态</li><li>死亡状态，线程终止</li></ol><h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>线程可以通过多种方式来终结同一个进程中的其他线程。其他一种方式就是调用系统调用pthread_cancel，其作用是取消掉给定线程ID代表的那个线程。更确切地讲，它会向目标线程发送一个请求，要求它立刻终止执行。但是该函数只是发送请求并即可返回。但是，该函数只是发送请求并立刻返回，而不会等待目标线程对该请求做出响应。至于目标线程什么时候对此做出线程、怎么样的响应，则取决与另外的因素（比如线程目标的取消状态及类型）。在默认情况下，目标线程总是会接受线程取消请求，不过等到时机成熟（执行到某个取消点）的时候，目标线程才会响应线程的取消请求。</p><h3 id="连接已终止的线程"><a href="#连接已终止的线程" class="headerlink" title="连接已终止的线程"></a>连接已终止的线程</h3><p>此操作由系统调用pthread_join来执行，该函数会一直等待与给定的线程ID对应的那个线程终止，并把线程执行的pthread_create函数的返回值告知调用线程。如果目标线程已经处于终止状态，那么该函数会立即返回。这就像是把调用线程放置在了目标线程的后面，当目标线程把线程控制权交出时，调用线程会接过流程控制权并继续执行pthread_join函数调用之后的代码。这也把这一操作称为连接的缘由之一。实际上，如果一个线程可被连接，那么在它终止之前就必须连接，否则就会变成一个僵尸线程。僵尸线程不但会导致系统资源浪费，还会无意义减少其进程的可创建线程数量。</p><h3 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h3><p>将一个线程分离后那么它将变得不可连接。而在默认情况下，一个线程总是可以被连接的。分离操作的另一个作用是让操作系统内核在目标线程终止时自行进行清理和销毁工作。注意，分离操作是不可逆的。也就是说，我们无法使一个不可连接的线程变回可连接的状态。不过，对于一个已处于分离状态的线程，执行终止操作仍然会起作用。分离操作由系统调用pthread_detach来执行，它接受一个代表了线程ID的参数值。</p><blockquote><p>一个线程对自身也可以进行两种控制：<strong>终止和分离</strong>。线程终止自身的方式有很多种。在线程执行的start函数中执行return语句，会使该线程随着start函数的结束而终止。需要注意的是，如果在主线程中执行了return语句，那么当前进程中的所有线程都会终止。另外，在任意线程中调用系统调用exit也会达到这种效果。还有一种终止自身的方式就是显示调用pthread_exit。而分离pthread_detach函数则是传入自己的TID。</p></blockquote><hr><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>主线程在其所属进程启动时创建。其他线程可以通过别的线程用pthread_create来创建——要传入新线程将要执行的函数以及传入该函数的参数值。在创建成功的时候，该函数会返回线程的TID。</p><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><p>线程创建的方式有三种，在我至今使用的经历中从来没有使用到过第三种方法：所以今天只介绍两种，第一种是继承<code>Thread</code>类，第二种是实现<code>Runnable</code>接口。两种方法的优缺点就和继承和接口优缺点有关了，其实底层都是一样的。<br>具体的代码这里不再进行详述，基本上都是见过的。</p><hr><h2 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h2><p>在多个线程之间交换线程是非常简单和自然的事，而在多个进程之间只能通过一些额外的手段（比如管道、消息队列、信号量和共享内存区）传递数据。显然，使用这些额外手段会增加开发成本。不过，<strong>线程间交换数据虽然简单但却由于可能发生竞态条件而不得不使用一些同步工具（比如互斥量和条件变量）加以保护</strong>。这些与业务逻辑无关的代码会增加程序的复杂度，尤其在使用不当的情况下还会引起灾难。</p><blockquote><p>互斥量可以理解为我们常见的锁。而条件变量所做的就是保证线程间共享的数据状态改变时通知到其他因此而被阻塞的线程。条件变量总是与互斥量组合使用。当线程成功锁定互斥量并访问到共享数据时，共享数据的状态并不一定满足它的要求。</p></blockquote><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>使用synchronize的可以加载方法，代码块，类上，以此实现多线同步。</p><ol><li>同步代码块：<br>即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">代码如： </span><br><span class="line"><span class="keyword">synchronized</span>(object)&#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注：同步是一种高开销的操作，因此应该尽量减少同步的内容。 </span><br><span class="line">通常没有必要同步整个方法，使用<span class="keyword">synchronized</span>代码块同步关键代码即可。</span><br></pre></td></tr></table></figure><ol start="2"><li>同步方法<br>即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码如： </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类</p><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>使用volatile修饰共享变量可以实现线程同步。<strong>其中的原理与synchronized区别会在JMM文章中讲到。</strong><br>a.volatile关键字为域变量的访问提供了一种免锁机制，<br>b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，<br>c.因此每次使用该域就要重新计算，而不是使用寄存器中的值<br>d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量</p><h4 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h4><p>什么是重入呢？它是表示当一个线程试图获取一个它已经获取的锁时，这个获取动作就自动成功，这是对锁获取粒度的一个概念，也就是锁持有的是以线程为单位而不是基于调用次数。<br>再入锁可以设置公平性(fairness)，我们可以创建重入锁时选择是否是公平的。<br>ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。<br>ReentrantLock相比synchronize，因为可以像普通对象一样使用，所以可以利用其提供的各种便利方法，进行精细的同步操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> account = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">//需要声明这个锁</span></span><br><span class="line">            <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> account;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里不再需要synchronized </span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    account += money;</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        ｝</span><br></pre></td></tr></table></figure><p>ReenreantLock类的常用方法有：</p><blockquote><p> ReentrantLock() : 创建一个ReentrantLock实例<br> lock() : 获得锁<br> unlock() : 释放锁</p></blockquote><p>从性能的角度，synchronize早起的实现比较低效，对比ReentrantLock大多数场景性能都相差较大，但是在java6 中对其进行了非常多的改进，在高竞争情况下ReentrantLock仍然有一定优势。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>与互斥锁不同，条件变量是用来等待而不是用来上锁的。<strong>条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用</strong>。条件变量分为两部分:<code>条件和变量</code>。条件本身是由互斥量保护的。线程在改变条件状态前先要锁住互斥量。条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。条件的检测是在<code>互斥锁</code>的保护下进行的。如果一个条件为假，一个线程自动阻塞，并释放等待状态改变的<code>互斥锁</code>。如果另一个线程改变了条件，它发信号给关联的条件变量，唤醒一个或多个等待它的线程，重新获得<code>互斥锁</code>，重新评价条件。<strong>如果两进程共享可读写的内存，条件变量可以被用来实现这两进程间的线程同步。</strong></p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，<br>副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。<br>ThreadLocal 类的常用方法</p><blockquote><p>ThreadLocal() : 创建一个线程本地变量  get() : 返回此线程局部变量的当前线程副本中的值<br>initialValue() : 返回此线程局部变量的当前线程的”初始值”<br>set(T value) :将此线程局部变量的当前线程副本中的值设置为value</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">           <span class="comment">//使用ThreadLocal类管理共享变量account</span></span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; account = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">               account.set(account.get()+money);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAccount</span><span class="params">()</span></span>&#123;</span><br><span class="line">               <span class="keyword">return</span> account.get();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>ThreadLocal下面单独讲</strong></p><hr><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>一句话概括：Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。所以ThreadLocal的应用场合，最适合的是按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。</p><p>数据隔离的秘诀其实是这样的，Thread有个TheadLocalMap类型的属性，叫做threadLocals，该属性用来保存该线程本地变量。这样每个线程都有自己的数据，就做到了不同线程间数据的隔离，保证了数据安全。</p><p>具体看这篇博客：<br><a href="https://blog.csdn.net/lufeng20/article/details/24314381" target="_blank" rel="noopener">https://blog.csdn.net/lufeng20/article/details/24314381</a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>并发（Concurrency）和并行（Parallelism）</strong></p><blockquote><p>并发和并行往往被人所混淆。它们都可以表示两个或多个任务一起执行，但是偏重点有些不同。并发偏重于多个任务交替执行，而多个任务有可能还是串行。而并行则是真正意义上的“同时执行”。</p><p>严格来说，<strong>并行的多个任务是真实的同时执行</strong>，<strong>而对并发来说，这个过程这是交替的，一会儿运行任务A一会儿执行任务B，系统会不停地在两者间切换</strong>。但对于外部观察者来说，即使多个任务之间是串行并发的，也会造成多任务间是并行执行的错觉。</p></blockquote><p><strong>临界区</strong></p><blockquote><p>临界区(criticalsection)用来表示一种公共资源或者共享数据，可以被多个线程使用。但是每一次，只有一个线程可以使它，一旦临界区资源被占用，其他线程要想使用资源，就必须等待，即串行化访问或执行。</p></blockquote><p><strong>死锁（DeadLock）、饥饿（Starvation）和活锁（Livelock）</strong></p><blockquote><p>死锁、饥饿和活锁都属于多线程的活跃性问题，如果发生上述情况，那么相关线程可能就不再活跃，也就是说它可能很难继续往下执行了。<br>死锁应该是最糟糕的一种情况了，虽然别的情况也没有好到哪儿去。</p><ul><li>死锁：多个线程互相等待多方释放资源而一直没有执行。</li><li>饥饿：一个或多个线程因为种种原因无法获取所得的需要资源，导致一直无法执行。导致的原因往往是当前线程优先级不高导致没有资源，或某线程一直占着关键资源不放。</li><li>活锁：多个线程都释放资源给别的线程使用，导致没有线程拿到资源而正常执行。</li></ul></blockquote><p><strong>阻塞和非阻塞</strong></p><blockquote><p>描述的是用户线程调用内核 I/O 操作的方式：</p><ul><li>阻塞（Blocking）是指 I/O 操作需要彻底完成后才返回到用户空间；</li><li>非阻塞（Non-Blocking）是指 I/O 操作被调用后立即返回给用户一个状态值，无需等到 I/O 操作彻底完成。</li></ul><p>一个 I/O 操作其实分成了两个步骤：</p><ol><li>发起 I/O 请求</li><li>实际的 I/O 操作。</li></ol><p><strong>阻塞 I/O 和非阻塞 I/O 的区别在于第一步，发起 I/O 请求是否会被阻塞</strong>。如果阻塞直到完成那么就是传统的阻塞 I/O，如果不阻塞，那么就是非阻塞 I/O 。 <strong>同步 I/O 和异步 I/O 的区别就在于第二个步骤是否阻塞</strong>，如果实际的 I/O 读写阻塞请求进程，那么就是同步 I/O 。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;深感自己的能力的不足，此处仅仅是对知识的记录和总结，许多地方都是借鉴他人的语句&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="线程" scheme="http://yoursite.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务--原子性</title>
    <link href="http://yoursite.com/2018/08/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1-%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    <id>http://yoursite.com/2018/08/12/数据库事务-原子性/</id>
    <published>2018-08-12T01:00:00.000Z</published>
    <updated>2018-08-12T16:17:15.188Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据库看似简单，却是个十分复杂的东西</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>ACID：</strong> 指数据库事务正确执行的四个基本要素的缩写。包含：<strong>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</strong>。一个支持事务（Transaction）的数据库，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。 </p><p><strong>如果没有没有正确执行便会出现以下问题：</strong><br>1，脏读（dirtyRead）<br>脏读是指的一个事物正在访问数据，并且对数据进行了修改，而且这种修改还没有提交到数据库中，这时，另一个事物也访问这个数据<br>，然后使用了这个数据。因为这个数据还没有提交数据，那么另外一个事物读到的这个数据就是脏数据。</p><p>2，不可重复读<br>不可重复读，就是在同一事务中，两次读取同一数据（同一主键），得到内容不同。不可重复读和脏读的区别是，不可重复读读取到的都是已经提交的数据，而不是脏数据。</p><p>3，虚读(幻读)<br>幻读指的是，同一事务中，用同样的操作读取两次，得到的记录数不相同。幻读和不可重复读都是读取到了另一条已经提交的事物，这一点和脏读不同。<br>看似幻读和不可重复读都是一样的，但是区别在于不可重复读针对的是同一个主键的数据。而幻读针对的是一批数据两次读取中，有新增或者减少。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>了解了数据库的四大特性，那么今天就来讲讲数据库特性之一 —–<strong>原子性</strong><br>首先：原子性一说大家都明白，那你能说说在<strong>执行的操作过程中，如果还没做完系统就崩溃了，或者断电了，你怎么办啊？ 你怎么保证原子性？如果我还没做完，系统就崩溃了，那系统重启以后我就得做恢复操作？</strong></p><p>下面我们就来讲讲这个问题的答案。<br>首先以<strong>旺财有200块钱， 小强有50 块钱，现在旺财要给小强转账，假设转100块</strong>为例。如果按照事务完整进行则会有一下四步：<br>(1)  开始事务 T1 （假设T1是个事务的内部编号）<br>(2)  旺财余额 = 旺财余额 -100<br>(3)  小强余额 = 小强余额 + 100<br>(4)  提交事务 T1<br>我们知道所有的计算操作都是在内存中进行的，这个时候被计算的数据首先放入缓冲区中：如下图<br><img src="原子性.jpg" alt="原子"><br>因为硬盘的速度太慢，所以不会经常性的操作硬盘，而是把数据放入到缓冲区中，然后一次性保存到硬盘中。</p><h2 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h2><p>这里先假定数据缓冲区能和硬盘的数据文件同步。<br>问题：旺财在给小强转账， 第二步执行完了，旺财的余额变成了100块 （200-100）， 假设已经写入了硬盘文件， 现在断电了， 小强的余额有没有加上，系统的钱白白消失了100块， 数据已经不一致了，  你怎么办？<br>而这个叫做Undo的日志文件，就是为了解决这个问题的。<br><strong>分析：</strong><br>按照上面的情况，会在日志文件中记录下事务开始之前他俩账号余额：</p><blockquote><p>[事务T1,  旺财原有余额 ， 200]<br>   [事务T1, 小强原有余额， 50 ] </p></blockquote><p>如果事务执行到一半，就断电了，那数据库重启以后我就根据undo的日志文件来恢复。</p><p><strong>问题：恢复数据的时候， 那你怎么才能知道一个事务没有完成呢？</strong></p><blockquote><p>[开始事务 T1]<br>   [事务T1, 旺财原有余额，200]<br>    [事务T1, 小强原有余额，50]<br>    [提交事务 T1]</p></blockquote><p>Undo日志文件中不仅仅只有余额， 事务的开始和结束也会记录，如果我在日志文件中看到了<strong>提交事务 T1</strong>, 或者 <strong>回滚事务 T1</strong>, 我就知道这个事务已经结束，不用再去理会它了， 更不用去恢复。 如果我只看到 <strong>开始事务 T1</strong>, 而找不到提交或回滚，那我就得恢复。比如下面这个：</p><blockquote><p>[开始事务 T1]<br>   [事务T1, 旺财原有余额，200]<br>   [事务T1, 小强原有余额，50]</p></blockquote><p>如果已经恢复了，就在日志文件中加上一行 <strong>回滚事务 T1</strong> ， 这样下一次恢复我就不用再考虑T1这个事务了。</p><p><strong>问题：那我们应该什么时候记录Undo日志呢？什么时候把Undo日志写入文件呢？</strong></p><p>把日志记录也放到了内存的Undo日志缓冲区，伺机写入硬盘。<br><img src="日志.jpg" alt="日志"></p><p>我们来看看下面的分析：</p><ol><li>如果系统在第4步和第5步之间崩溃，旺财的余额写入了硬盘，但是小强的还没写入， 那Undo日志看起来是这样的：</li></ol><blockquote><p>[开始事务 T1]<br>   [事务T1, 旺财原有余额，200]</p></blockquote><p>由于找不到事务结束的日志， 你会进行恢复操作， 把旺财的原有余额给恢复了。</p><ol start="2"><li>如果是在第7步和第8步之间系统崩溃，旺财和小强的最新余额都写入了硬盘，但是没有提交事务， 那Undo日志看起来是这样的：</li></ol><blockquote><p>[开始事务 T1]<br>  [事务T1, 旺财原有余额，200]<br>  [事务T1, 小强原有余额，50]</p></blockquote><p>由于没有事务结束的日志，你也需要进行恢复，把旺财和小强的原有余额恢复成200和50 ”</p><ol start="3"><li>如果是在第8步和第9步之间系统崩溃， 旺财和小强的最新余额都写入了硬盘， 也提交了事务， 但是提交事务的操作没有写入Undo 日志， 所以Undo日志还是这样：</li></ol><blockquote><p>[开始事务 T1]<br>   [事务T1, 旺财原有余额，200]<br>   [事务T1, 小强原有余额，50]</p></blockquote><p>由于没有事务结束的日志，你还得需要进行恢复，把旺财和小强的原有余额恢复成200和50。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这里面是有规律的，如果实现了这个规律便可以解决所有的问题：</p><ol><li><p>在你把最新余额写入硬盘之前， <strong>一定要先把相关的Undo日志记录写入硬盘</strong>。 例如 <strong>[事务T1, 旺财原有余额，200]</strong> 一定要在旺财的新余额=100写入硬盘之前写入。</p></li><li><p><strong>[提交事务 T1]</strong> 这样的<strong>Undo日志记录一定要在所有的新余额写入硬盘之后再写入</strong>。  有了这两条的保证，我就可以高枕无忧了！， 比如说，换个操作次序也没有问题：<br><img src="日志2.jpg" alt="日志"></p></li></ol><h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665514001&amp;idx=1&amp;sn=17b72c3e69db6c4277e3045c699b7b6b&amp;chksm=80d67c52b7a1f5446020826841869221873f4578524181384592839d19c4810dc68807117e13&amp;mpshare=1&amp;scene=1&amp;srcid=0311ddHdl0tOCk3XkUy6l8lA#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665514001&amp;idx=1&amp;sn=17b72c3e69db6c4277e3045c699b7b6b&amp;chksm=80d67c52b7a1f5446020826841869221873f4578524181384592839d19c4810dc68807117e13&amp;mpshare=1&amp;scene=1&amp;srcid=0311ddHdl0tOCk3XkUy6l8lA#rd</a></p><blockquote><p>我所向往的不过是如此简单而已</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;数据库看似简单，却是个十分复杂的东西&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;ACID：&lt;/st
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库，事务" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>策略模式和观察者模式</title>
    <link href="http://yoursite.com/2018/07/31/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/07/31/策略模式和观察者模式/</id>
    <published>2018-07-31T14:09:00.000Z</published>
    <updated>2018-08-12T14:07:44.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>哪里会有人喜欢孤独，不过是不喜欢失望罢了。</p></blockquote><p>在学习Zstack时候看到了系统中多处使用策略模式和观察者模式，学习发现这两种模式在开发中经常用到，故在此记录下来。</p><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</strong><br>策略模式是一种对象行为型模式。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以<strong>根据环境或者条件的不同选择不同的策略来完成该项任务</strong>。</li><li>在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。</li><li>在软件系统中，<strong>有许多算法可以实现某一功能</strong>，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。</li></ol><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="策略模式.jpg" alt="策略"><br>对照类图可以看到，<strong>策略模式</strong>与模版方法模式的区别仅仅是多了一个单独的<strong>封装类Context</strong>，它与模版方法模式的区别在于：在模版方法模式中，调用算法的主体在抽象的父类中，而在策略模式中，调用算法的主体则是封装到了封装类Context中，<strong>抽象策略Strategy一般是一个接口，目的只是为了定义规范</strong>，里面一般不包含逻辑。其实，这只是通用实现，而在实际编程中，因为各个具体策略实现类之间难免存在一些相同的逻辑，为了避免重复的代码，我们常常使用抽象类来担任Strategy的角色，在里面封装公共的代码。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><ol><li>创建一个接口</li></ol><p><strong>Strategy.java</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">   public int doOperation(int num1, int num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>创建实现接口的实体类</li></ol><p><strong>OperationAdd.java</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class OperationAdd implements Strategy&#123;</span><br><span class="line">   @Override</span><br><span class="line">   public int doOperation(int num1, int num2) &#123;</span><br><span class="line">      return num1 + num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>创建 Context 类</li></ol><p><strong>Context.java</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">   private Strategy strategy;</span><br><span class="line"> </span><br><span class="line">   public Context(Strategy strategy)&#123;</span><br><span class="line">      this.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public int executeStrategy(int num1, int num2)&#123;</span><br><span class="line">      return strategy.doOperation(num1, num2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出：创建Context时，传入不同的Strategy的子类会执行不同的功能方法。使用到java<strong>父类的引用指向子类对象</strong>。</p><h2 id="优缺点和注意事项"><a href="#优缺点和注意事项" class="headerlink" title="优缺点和注意事项"></a>优缺点和注意事项</h2><p>优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。<br>缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。</p><h2 id="Zstack中的体现"><a href="#Zstack中的体现" class="headerlink" title="Zstack中的体现"></a>Zstack中的体现</h2><p><img src="zstack中体现.jpg" alt="策略"><br>Zstack中充斥着大量的回调函数，如上图所示。CloudBusCallBack是一个接口，通过在方法中实现匿名类重写接口中定义的方法，方法中的功能可以根据上层类要实现的功能去灵活的定义。 这种方式就和传入一个子类对象一样，不过这个子类对象没有名字。因为Zstack所有功能的模块都是通过异步通信的，对策略模式了解可以有效的加深对整个Zstack的了解。</p><hr><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。<br><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p><h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ol><blockquote><p>注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p></blockquote><h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2><p>创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。<br><img src="观察者.jpg" alt="观察"></p><h2 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h2><p>观察者模式，我理解的就是<strong>观察者订阅被观察者的状态，当被观察者状态改变的时候会通知所有订阅的观察者的过程。</strong></p><ol><li>创建观察者接口</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Observer &#123;    </span><br><span class="line">    public abstract void update(String msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>观察者的实现类</li></ol><p>第一个观察者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class F_Observer extends Observer &#123;</span><br><span class="line">    public void update(String msg) &#123;</span><br><span class="line">        System.out.println(F_Observer.class.getName() + &quot; : &quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二个观察者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">S_Observer</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">void</span> update(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">        System.out.println(S_Observer.class.getName() + <span class="string">" : "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三个观察者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">T_Observer</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">void</span> update(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">        System.out.println(T_Observer.class.getName() + <span class="string">" : "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>被观察者</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;        </span><br><span class="line">    private List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();    <span class="comment">//状态改变    </span></span><br><span class="line">    public <span class="keyword">void</span> setMsg(<span class="built_in">String</span> msg) &#123;        </span><br><span class="line">        notifyAll(msg);    </span><br><span class="line">    &#125;   </span><br><span class="line">     <span class="comment">//订阅    </span></span><br><span class="line">    public <span class="keyword">void</span> addAttach(Observer observer) &#123;        </span><br><span class="line">        observers.add(observer);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//通知所有订阅的观察者    </span></span><br><span class="line">    private <span class="keyword">void</span> notifyAll(<span class="built_in">String</span> msg) &#123;        </span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;            </span><br><span class="line">            observer.update(msg);        </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>运行</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;    </span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;        </span><br><span class="line">        F_Observer fObserver = <span class="keyword">new</span> F_Observer();        </span><br><span class="line">        S_Observer sObserver = <span class="keyword">new</span> S_Observer();        </span><br><span class="line">        T_Observer tObserver = <span class="keyword">new</span> T_Observer();                </span><br><span class="line">        Subject subject = <span class="keyword">new</span> Subject();        </span><br><span class="line">        subject.addAttach(fObserver);        </span><br><span class="line">        subject.addAttach(sObserver);        </span><br><span class="line">        subject.addAttach(tObserver);                </span><br><span class="line">        subject.setMsg(<span class="string">"msg change"</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>从上面的代码中可以看出，当被观察者的行为改变的时候就可以通知观察者，观察者可以依据不同的变现做出不同的反应，<strong>我猜想：</strong>MQ有一种模式是消息订阅模式，其中必用到观察者模式，不过MQ使用的必然是异步的方式。</p><h2 id="Zstack中的体现-1"><a href="#Zstack中的体现-1" class="headerlink" title="Zstack中的体现"></a>Zstack中的体现</h2><p><strong>观察者模式</strong>在Zstack中的体现就要和<strong>Zstack的三驾马车（后面会讲到）</strong>联系到一起了。三驾马车分别对应着三层：<strong>应用层，业务层和领域层。</strong><br><strong>应用层（可以被调用的API）</strong>：就是界面定义的一些功能。<br><strong>业务层（一个Impl）</strong>：一个服务的入口，对功能的分发，不会处理底层很具体功能。<br><strong>领域层（base）</strong>：这层主要是一些行为的逻辑，对某一个功能具体的操作。</p><blockquote><p>我们知道各个层之间是需要<strong>通信</strong>的，那么层与层之间只能是单向的。上层可以直接使用或操作下层元素，方法是通过调用下层元素的公共接口，保持对下层元素的引用（至少是暂时的），以及采用常规的交互手段。而如果下层元素需要与上层元素通信，则需要采用另一种<strong>通信机制</strong>——比如<strong>回调或者Observers模式</strong>（在ZStack中即是ExtensionPoint）。</p></blockquote><p>这里以PrimaryStorageBase为例：在PrimaryStorageBase中，其中handle APIAttachPrimaryStorageToClusterMsg的地方会做事件发送：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extpEmitter.preAttach(self, msg.getClusterUuid());</span><br></pre></td></tr></table></figure><p>其会发送向：<br><img src="connectHook.jpg" alt="connect"><br>在抽象等级上，PrimaryStorageBase是比图中的这些Base高的。而<strong>这类具象Base可以使Message返回Success或者Fail使高层Base做出不同的决策</strong>。这里是通过回调函数的形式来对上层的Base进行通知的。具体对象的Base执行失败或者成功会回调上层的fail或者success，这样上层就知道下面的方法是否执行成功。因为系统中都是通过异步的方式来实现的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;哪里会有人喜欢孤独，不过是不喜欢失望罢了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在学习Zstack时候看到了
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，Java" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>1688开放平台对接</title>
    <link href="http://yoursite.com/2018/06/19/1688%E5%AF%B9%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/06/19/1688对接/</id>
    <published>2018-06-19T09:33:00.000Z</published>
    <updated>2018-06-27T13:16:24.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>什么是1688开放平台（ <a href="https://open.1688.com" target="_blank" rel="noopener">https://open.1688.com</a>  ）？</p><blockquote><p>依托B2B海量用户资源以及强大的平台优势，是为阿里巴巴商家提供基础服务的重要开放途径，帮助商家提升经营能力、拓宽生意渠道、提高办公效率。从今年开始，阿里巴巴开放平台将向合作伙伴和广大第三方开发者逐步开放会员、公司库、类目、产品、交易、咨讯等一系列接口。为合作伙伴提供快捷的提交通路，多入口最优展现的同时，共享商机，互利双赢。</p></blockquote><hr><h3 id="对接过程"><a href="#对接过程" class="headerlink" title="对接过程"></a>对接过程</h3><p>以下演示是以对接1688采购订单为例。</p><h4 id="1-注册开发者"><a href="#1-注册开发者" class="headerlink" title="1 注册开发者"></a>1 注册开发者</h4><p>如果想使用1688开放平台，必须首先要注册成为开发者，需要同时具备以下两个条件：</p><ol><li>具备一个阿里巴巴中国站帐号；</li><li>必须绑定了通过个人实名（公司企业）认证的支付宝帐号；个人开发者必须绑定通过个人实名认证的支付宝账号，企业开发者必须绑定通过商家认证的支付宝账号；</li></ol><p>开发者身份绑定的支付宝账户用于产品分成结算的收款账户。因此为了确认您的身份和安全考虑，必须通过支付宝认证。</p><h4 id="2-获取证书"><a href="#2-获取证书" class="headerlink" title="2 获取证书"></a>2 获取证书</h4><p>一、什么是应用证书：<br>证书指的是开发者在阿里巴巴开放平台创建应用是默认给开发者的应用开发证书。想要调用1688开放平台上的API必须申请证书。证书包含四个内容：</p><p><strong>证书编号：App Key</strong></p><p><strong>证书密钥：App Secret</strong></p><p>接口权限：开发者可以调用的API权限，包含基础开放与增值包</p><p>证书流量：应用可以调用API的流量限制</p><p>也就是“权限+流量+appkey+app secret=证书”，每个应用都有对应的应用开发证书，在应用创建时开发者获得证书。<br>二、什么是App Key？</p><p>App Key是应用的唯一标识，阿里巴巴开放平台通过App Key来鉴别应用的身份。<br>三、什么是App Secret？</p><p>AppSecret是阿里巴巴开放平台给应用分配的密钥，开发者需要妥善保存这个密钥，这个密钥用来保证应用来源的可靠性，防止被伪造。</p><h5 id="获取证书过程"><a href="#获取证书过程" class="headerlink" title="获取证书过程"></a>获取证书过程</h5><blockquote><p><a href="https://open.1688.com/developer/serviceType.htm?spm=a260s.8209130.sidebar.2.4fbb55edhIdo07#/?_k=l6b00o" target="_blank" rel="noopener">https://open.1688.com/developer/serviceType.htm?spm=a260s.8209130.sidebar.2.4fbb55edhIdo07#/?_k=l6b00o</a></p></blockquote><p>1.<strong>创建应用</strong>：根据自己公司的业务需求可以选择不同的应用类型，如下图所示：</p><p><img src="创建应用.jpg" alt="1688"><br>选择采购对接<br><img src="采购对接.jpg" alt="1688"><br>企业对接面向的是从1688网站上采购的数据信息拉取到公司自己的管理软件中进行统一的管理。点击<strong>采购对接</strong>后填写必要的一些信息提交申请就可以了。<br>在填写信息的时候，<strong>应用类目</strong>选择企业采购，大企业采购一般是通过不了的；<strong>授权用户数</strong>可以选择<strong>单用户授权</strong>也可以选择<strong>多用户授权</strong>，他们其中的区别放到下面讲。<br><img src="信息填写.jpg" alt="1688"></p><p>提交成功后便可在<strong>应用列表</strong>中看到申请到的对接应用。可以点击查看，就会看到应用详情，里面便包括了App Key和App Secret。如下图：<br><img src="查看应用详情.jpg" alt="1688"></p><p>2.<strong>申请解决方案</strong>：即针对你申请到的账户需要申请调用对应API的权限</p><p><strong>申请解决方案</strong>一般在48小时之内会反馈方案是否给予通过。所以开发的时候如果急于上线，需要提前申请。通过的解决方案便可以使用。<br><img src="申请解决方案.jpg" alt="1688"></p><p>3.<strong>测试账号</strong></p><p>当你在解决方案列表看到已经通过的账号，下一步就需要在线测试账号的可用性。<br>在API文档中点击<strong>API TOOLS 在线测试工具</strong>，输入App Key和App Secret便可以测试账号是否可用。<br><img src="测试.jpg" alt="1688"></p><p>4.<strong>下载jar包进行开发</strong></p><p><img src="sdk下载.jpg" alt="1688"></p><p>5.<strong>编程</strong></p><p>具体代码请看我的github上的项目，里面有完整的授权流程代码，地址：<a href="https://github.com/Foutlook/Docking-1688-Interface" target="_blank" rel="noopener">多用户授权下调用1688接口API授权流程</a>。</p><h4 id="3-关于单用户授权和多用户授权的说明"><a href="#3-关于单用户授权和多用户授权的说明" class="headerlink" title="3 关于单用户授权和多用户授权的说明"></a>3 关于单用户授权和多用户授权的说明</h4><p>我们首先看一下官方给的不同授权方式的定义：<br><img src="授权.jpg" alt="1688"></p><blockquote><p><strong>单用户授权和多用户授权</strong>的区别是：<br>1.单用户授权在调用API的时候不需要传access_token，而多用户授权需要传access_token ,不然的话无法调用1688的API。<br>2.单用户授权在申请上线的时候一个公司只能有一个账户，而多用户授权在上线的时候可以有多个账户。<br>3.多用户授权可以关联其他的账户，通过一个账户拉去多个账户的信息。</p></blockquote><p>虽然多用户授权有很多的好处，不过它开发起来要比单用户授权麻烦很多，主要是处理access_token 的问题。<br>首先我们先看看多用户授权下access_token 的授权流程，也就是获取access_token 的流程（<a href="https://open.1688.com/api/sysAuth.htm?spm=a260s.8208024.0.0.9f0e55edLOgOy1&amp;ns=cn.alibaba.open" target="_blank" rel="noopener">官网授权解释地址</a>）：</p><p><img src="流程.jpg" alt="1688"><br>首先通过code即<strong>临时令牌</strong>得到<strong>access_token</strong>，第一次授权后会得到<strong>refresh_token</strong>，等下次access_token过期的时候就可以通过refresh_token来得到。授权的流程图如下所示：<br><img src="授权流程.jpg" alt="1688"></p><p>具体代码请看我的github，地址：<a href="https://github.com/Foutlook/Docking-1688-Interface" target="_blank" rel="noopener">多用户授权下调用1688接口API授权流程</a>。</p><hr><p><strong>END</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;什么是1688开放平台（ &lt;a href=&quot;https://open.1688.com&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
    
      <category term="1688,1688开放平台,阿里巴巴" scheme="http://yoursite.com/tags/1688-1688%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"/>
    
  </entry>
  
  <entry>
    <title>初次提交代码总结</title>
    <link href="http://yoursite.com/2018/05/26/%E5%88%9D%E6%AC%A1%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/05/26/初次提交代码总结/</id>
    <published>2018-05-26T01:00:00.000Z</published>
    <updated>2018-11-14T13:40:55.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>自己空白的还有很多，记录一下本周所感所想</p></blockquote><p>本周算是经历了第一次的merge request，虽然是在我师傅写好的代码下填补一些小功能，不过感觉学到的东西还是挺多的。无论是对开发中的细节，还是良好习惯的培养都让我受益颇多。</p><hr><h2 id="从前"><a href="#从前" class="headerlink" title="从前"></a>从前</h2><p>前面的一个月基本上都是在学习zstack的基本知识，架构还有里面的实现原理。这次也是我真正去读别人的代码，跟着别人代码的思想去理解整个结构，去添加一些需求。可以说这周的开发过程也是对我一次深刻的提醒。<br>意识到其实在以前学习zstack的时候许多重要的点并没有深刻的去理解，以前的心态就是能看懂就行，不需要问原因和原理，所以遇到一些不是特别清晰的并没有过于的深刻探究其中主要原理。像Inner Msg在zstack中处理的过程，CloudBus怎么处理去拦截和收集这些消息的，FlowChain的调用过程，回调实现的方式，一些类的继承实现有的时候居然不知道为什么。以前在学校的时候就接触过回调函数这方面的知识点，也从未认真看过。这次要不是我师傅的指点，我恐怕陷得很深。</p><hr><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>本周主要是对审计模块一些简单功能的添加，实现用户自定义operation name，并且添加一些基本的测试。这两个功能前前后后花了一周的时间。接到需求的第一天，我大概浏览了各个问题的要求，然后开始添加自己的代码，在做的过程中，我发现我面临许多的问题，我对问题并不是很理解。比如添加用户自定义operation name，我理解的就是把某一个属性写到配置文件中，加载新来而已。还有添加inner  msg的case，我以为Inner Msg实现审计模块会有人帮我写好。一切都源于对问题的不清晰然后就开始干，第一天就踩了不少的坑。辛亏我师父救场，问我有哪些不懂的问题，不然我还在按照自己的思路在写。还有后面看代码十分的不认真，有一个问题是set集合的泛型问题，在创建HashSet集合的时候，泛型放在前面和后面有着不同的意义。<br>其实开始的我以为这部分功能最多三天就搞完了，最终还是在我师父帮助下，五天勉勉强强的完成。我总结这次主要原因如下：</p><ol><li>zstack部分功能理解不深入</li><li>没有搞清楚需求是怎么样的就急于入手</li><li>不善于提问，总认为自己可以解决，思维逻辑混乱</li><li>过于浮躁，不认真</li></ol><hr><h2 id="以后"><a href="#以后" class="headerlink" title="以后"></a>以后</h2><p>踩坑真的是能让人进步的过程，如果不真的接触代码，真的很少能够意识到那么多的问题。<br><strong>现阶段我不足的部分：</strong></p><ol><li>回调方面的部分，我总是感觉有些地方不是特别理解，但是又说不上来。</li><li>FlowChain部分也是有点模糊</li><li>… 等待发现</li></ol><p>也许这几部分也要通过写代码的方式来锻炼，来理解。后面的工作我会尽力去做。不能解决的问题，我会尽量的问我的师傅，不会自己再闷头苦想（虽然自己是应届生，不过遇到弱智的问题，感觉还是挺丢人的）。</p><p>后面再写一段代码，我会把我学到的zstack知识尽量做一个总结，写几篇博客，把zstack的原理自己总结一下。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>跟着QB团队学到不少的东西，有着中国第一的PM孙总，zstack的高级开发者和精通Java的我师傅，python和java都精通的伟嘉，打得过PM的高级开发工程师强哥，受益匪浅。比在上海那三个月的实习学到的多得多。不过感觉赶上他们的步伐还是好难。这段时间也听到了很多陌生的词，像比特币，区域块，股票方面的知识还有他们对中国经济和政府投资的分析。我有的时候真的明天为什么有些人可以赚那么多钱了。<br>很感谢我师傅的指导，很有耐心，知道我缺什么，然后认真提出方法来解决。还有我师傅认真起来真的很吓人。<br>最后：</p><blockquote><p>不要把不会当成一个负担，不会就问。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;自己空白的还有很多，记录一下本周所感所想&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本周算是经历了第一次的merg
      
    
    </summary>
    
      <category term="所思" scheme="http://yoursite.com/categories/%E6%89%80%E6%80%9D/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Foutin</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-12T13:54:10.005Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Foutlook</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>策略模式和观察者模式</title>
    <link href="http://yoursite.com/2018/08/12/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/12/策略模式和观察者模式/</id>
    <published>2018-08-12T14:09:00.000Z</published>
    <updated>2018-08-12T13:54:10.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>哪里会有人喜欢孤独，不过是不喜欢失望罢了。</p></blockquote><p>在学习Zstack时候看到了系统中多处使用策略模式和观察者模式，学习发现这两种模式在开发中经常用到，故在此记录下来。</p><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</strong><br>策略模式是一种对象行为型模式。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以<strong>根据环境或者条件的不同选择不同的策略来完成该项任务</strong>。</li><li>在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。</li><li>在软件系统中，<strong>有许多算法可以实现某一功能</strong>，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。</li></ol><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="策略模式.jpg" alt="策略"><br>对照类图可以看到，<strong>策略模式</strong>与模版方法模式的区别仅仅是多了一个单独的<strong>封装类Context</strong>，它与模版方法模式的区别在于：在模版方法模式中，调用算法的主体在抽象的父类中，而在策略模式中，调用算法的主体则是封装到了封装类Context中，<strong>抽象策略Strategy一般是一个接口，目的只是为了定义规范</strong>，里面一般不包含逻辑。其实，这只是通用实现，而在实际编程中，因为各个具体策略实现类之间难免存在一些相同的逻辑，为了避免重复的代码，我们常常使用抽象类来担任Strategy的角色，在里面封装公共的代码。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><ol><li>创建一个接口</li></ol><p><strong>Strategy.java</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">   public int doOperation(int num1, int num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>创建实现接口的实体类</li></ol><p><strong>OperationAdd.java</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class OperationAdd implements Strategy&#123;</span><br><span class="line">   @Override</span><br><span class="line">   public int doOperation(int num1, int num2) &#123;</span><br><span class="line">      return num1 + num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>创建 Context 类</li></ol><p><strong>Context.java</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">   private Strategy strategy;</span><br><span class="line"> </span><br><span class="line">   public Context(Strategy strategy)&#123;</span><br><span class="line">      this.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public int executeStrategy(int num1, int num2)&#123;</span><br><span class="line">      return strategy.doOperation(num1, num2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出：创建Context时，传入不同的Strategy的子类会执行不同的功能方法。使用到java<strong>父类的引用指向子类对象</strong>。</p><h2 id="优缺点和注意事项"><a href="#优缺点和注意事项" class="headerlink" title="优缺点和注意事项"></a>优缺点和注意事项</h2><p>优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。<br>缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。</p><h2 id="Zstack中的体现"><a href="#Zstack中的体现" class="headerlink" title="Zstack中的体现"></a>Zstack中的体现</h2><p><img src="zstack中体现.jpg" alt="策略"><br>Zstack中充斥着大量的回调函数，如上图所示。CloudBusCallBack是一个接口，通过在方法中实现匿名类重写接口中定义的方法，方法中的功能可以根据上层类要实现的功能去灵活的定义。 这种方式就和传入一个子类对象一样，不过这个子类对象没有名字。因为Zstack所有功能的模块都是通过异步通信的，对策略模式了解可以有效的加深对整个Zstack的了解。</p><hr><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。<br><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p><h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ol><blockquote><p>注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p></blockquote><h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2><p>创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。<br><img src="观察者.jpg" alt="观察"></p><h2 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h2><p>观察者模式，我理解的就是<strong>观察者订阅被观察者的状态，当被观察者状态改变的时候会通知所有订阅的观察者的过程。</strong></p><ol><li>创建观察者接口</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Observer &#123;    </span><br><span class="line">    public abstract void update(String msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>观察者的实现类</li></ol><p>第一个观察者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class F_Observer extends Observer &#123;</span><br><span class="line">    public void update(String msg) &#123;</span><br><span class="line">        System.out.println(F_Observer.class.getName() + &quot; : &quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二个观察者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">S_Observer</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">void</span> update(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">        System.out.println(S_Observer.class.getName() + <span class="string">" : "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三个观察者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">T_Observer</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">void</span> update(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">        System.out.println(T_Observer.class.getName() + <span class="string">" : "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>被观察者</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;        </span><br><span class="line">    private List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();    <span class="comment">//状态改变    </span></span><br><span class="line">    public <span class="keyword">void</span> setMsg(<span class="built_in">String</span> msg) &#123;        </span><br><span class="line">        notifyAll(msg);    </span><br><span class="line">    &#125;   </span><br><span class="line">     <span class="comment">//订阅    </span></span><br><span class="line">    public <span class="keyword">void</span> addAttach(Observer observer) &#123;        </span><br><span class="line">        observers.add(observer);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//通知所有订阅的观察者    </span></span><br><span class="line">    private <span class="keyword">void</span> notifyAll(<span class="built_in">String</span> msg) &#123;        </span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;            </span><br><span class="line">            observer.update(msg);        </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>运行</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;    </span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;        </span><br><span class="line">        F_Observer fObserver = <span class="keyword">new</span> F_Observer();        </span><br><span class="line">        S_Observer sObserver = <span class="keyword">new</span> S_Observer();        </span><br><span class="line">        T_Observer tObserver = <span class="keyword">new</span> T_Observer();                </span><br><span class="line">        Subject subject = <span class="keyword">new</span> Subject();        </span><br><span class="line">        subject.addAttach(fObserver);        </span><br><span class="line">        subject.addAttach(sObserver);        </span><br><span class="line">        subject.addAttach(tObserver);                </span><br><span class="line">        subject.setMsg(<span class="string">"msg change"</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>从上面的代码中可以看出，当被观察者的行为改变的时候就可以通知观察者，观察者可以依据不同的变现做出不同的反应，<strong>我猜想：</strong>MQ有一种模式是消息订阅模式，其中必用到观察者模式，不过MQ使用的必然是异步的方式。</p><h2 id="Zstack中的体现-1"><a href="#Zstack中的体现-1" class="headerlink" title="Zstack中的体现"></a>Zstack中的体现</h2><p><strong>观察者模式</strong>在Zstack中的体现就要和<strong>Zstack的三驾马车（后面会讲到）</strong>联系到一起了。三驾马车分别对应着三层：<strong>应用层，业务层和领域层。</strong><br><strong>应用层（可以被调用的API）</strong>：就是界面定义的一些功能。<br><strong>业务层（一个Impl）</strong>：一个服务的入口，对功能的分发，不会处理底层很具体功能。<br><strong>领域层（base）</strong>：这层主要是一些行为的逻辑，对某一个功能具体的操作。</p><blockquote><p>我们知道各个层之间是需要<strong>通信</strong>的，那么层与层之间只能是单向的。上层可以直接使用或操作下层元素，方法是通过调用下层元素的公共接口，保持对下层元素的引用（至少是暂时的），以及采用常规的交互手段。而如果下层元素需要与上层元素通信，则需要采用另一种<strong>通信机制</strong>——比如<strong>回调或者Observers模式</strong>（在ZStack中即是ExtensionPoint）。</p></blockquote><p>这里以PrimaryStorageBase为例：在PrimaryStorageBase中，其中handle APIAttachPrimaryStorageToClusterMsg的地方会做事件发送：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extpEmitter.preAttach(self, msg.getClusterUuid());</span><br></pre></td></tr></table></figure><p>其会发送向：<br><img src="connectHook.jpg" alt="connect"><br>在抽象等级上，PrimaryStorageBase是比图中的这些Base高的。而<strong>这类具象Base可以使Message返回Success或者Fail使高层Base做出不同的决策</strong>。这里是通过回调函数的形式来对上层的Base进行通知的。具体对象的Base执行失败或者成功会回调上层的fail或者success，这样上层就知道下面的方法是否执行成功。因为系统中都是通过异步的方式来实现的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;哪里会有人喜欢孤独，不过是不喜欢失望罢了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在学习Zstack时候看到了
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，Java" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://yoursite.com/2018/08/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/08/12/线程池/</id>
    <published>2018-08-12T01:00:00.000Z</published>
    <updated>2018-08-12T11:07:42.446Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="线程池" scheme="http://yoursite.com/categories/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务的原理</title>
    <link href="http://yoursite.com/2018/08/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/08/12/数据库事务的原理/</id>
    <published>2018-08-12T01:00:00.000Z</published>
    <updated>2018-08-12T11:14:45.928Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据库看似简单，却是个十分复杂的东西</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>ACID：</strong> 指数据库事务正确执行的四个基本要素的缩写。包含：<strong>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</strong>。一个支持事务（Transaction）的数据库，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;数据库看似简单，却是个十分复杂的东西&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;ACID：&lt;/st
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库，事务" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>始</title>
    <link href="http://yoursite.com/2018/08/12/%E5%A7%8B/"/>
    <id>http://yoursite.com/2018/08/12/始/</id>
    <published>2018-08-12T01:00:00.000Z</published>
    <updated>2018-08-12T08:52:11.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>想成功，想有钱，想养她，想梦有所成</p></blockquote><h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><p>转眼间18年已经过去一半多了，自己正式毕业也有将近两个月的时间。从学校到社会感受颇多。<br>大学的生活真的很舒服，无忧无虑，除了上课，想妹子，也就是想想自己进入社会的自己和五年后的自己。大学中自己得到的比自己所期望的少很多。不过还是很感谢大学的生活，谢谢你让我认识自己，学会去思考，让我进入社会没有那么多的不适应，还有认识了她。</p><h3 id="amp-amp-大一"><a href="#amp-amp-大一" class="headerlink" title="&amp;&amp;大一"></a>&amp;&amp;大一</h3><p>四年的大学最幸福的莫过于大一。有着对大学的憧憬，所以进入大学的时候是带着敬畏之心的，对大学中所有的东西都十分感兴趣，无论社团还是公益的组织都参加了，虽然最后一次都没有去过。大一是我游戏最厉害的一年，开始进入大学我并没有那么自律，想到什么就开始干，我内心是一个很豪放的人，当时特别想体验大学生活的无忧无虑，想玩个痛快。不过辛亏我身边有几个爱学习的人，在大一就很幸运的进入了北斗之心实验室（大二的时候退出），是我编程之路的开始。说来也挺可笑的，当时实验室考试我考个倒数第几名，和我一起去的谢亮亮和我分数一样，最后面试我进入了实验室，还是上天照顾我吧，给了我那么好的运气。大一也是我初见她的时候，当时的情景记忆忧心，忘不掉。</p><h3 id="amp-amp-大二"><a href="#amp-amp-大二" class="headerlink" title="&amp;&amp;大二"></a>&amp;&amp;大二</h3><p>大二开始学习java。给你们讲个笑话，我是先学的Android后学的java，不过最后放弃了Android，这也是我退出北斗实验室的原因。让一个什么都不知道的老师管理实验室是一个致命的错误。大二这一年我没有很印象最深的事，我大二的记忆不知道很多都想不起来了。也许是选择性遗忘吧。我只知道我大二这一年过的很迷茫，很心痛。</p><h3 id="amp-amp-大三"><a href="#amp-amp-大三" class="headerlink" title="&amp;&amp;大三"></a>&amp;&amp;大三</h3><p>开始Web开发。当时迷茫的我突然意识到Android已经落伍了，毅然的转向了后端开发之路。期间因为我班里的同学成了另一个安全实验室的管理员，就给我在实验室找了个位置学习。大三唯一让我不会忘记的就是她回到了我的身边，是下学期的四月份，当时那个激动呀，自从这件事后，我慢慢又看到了希望，知道我想要干什么了。虽然当时自己特别的菜，充满对毕业的忧虑，不过当时她回来真的给我打个一针强心剂，让我在颓废的边缘，一下有坚强了起来。</p><h3 id="amp-amp-大四"><a href="#amp-amp-大四" class="headerlink" title="&amp;&amp;大四"></a>&amp;&amp;大四</h3><p>大三快要结束的时候，我咨询了好多学长是培训还是直接实习。都让我去实习，可是当时真的是虚呀，java都用不熟。最后硬着头皮去了一家很一般的公司培训去了，除了java基础，后面的知识讲的真的垃圾。最后开始了自学之路。回到学校进入学校合作的公司进行实习，在里面并没有学到很多东西，不过时间挺充裕的学了很多分布式的东西。当学校放我们离校的时候，我开始去上海实习。在去上海之前，我知道自己是有多菜，这样去不会找到很好的工作，我怎么在她面前证明自己，怎么照顾好她。所以我守着一个项目十四天没有出过大门。整整做了十四天。看了十四天的视频和做了十四天的项目。境界提升了不少。大四，她考研，我工作。</p><h2 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h2><p><strong>拿到毕业证后从上海的那件公司离职</strong>，来到杭州。为什么来杭州呢，一方面离她更近，另一方面我对上海没有好感，再者我想看看杭州是个什么样子。杭州人少，环境也不错，挺适合居住的，也许她想再这住的话，我就可能在这买房了。<br>现在已经在这个公司将近一个月了，这一个月学到了很多东西（知识请看博客）。其实来到这个公司我还是依靠的运气，经过了四面，不知道怎么的就进来，我自认为本人掌握回答的并不是特别的好。很感谢面试我的人，让我有机会进入这么好的公司。<br>开发的路上遇到很多困难，所有的东西都是新的。和以前接触的东西都不是一个水平线上的。感受到公司牛人真的多。进入公司这段时间被虐的不行不行的，感觉自己真的是个菜逼，不过公司对新人特别的照顾，我们部门主管说过这样一句话：“<strong>不要骂比自己年龄小的新人菜，因为几十年后他骂你你连还嘴的机会都没有</strong>”。很是赞同！<br>一开始我认为师傅是个毕业很久，很厉害的人，自从看了他的博客，我才改变观点，他才毕业两年，何止厉害，简直是非常厉害。看着他的经历，真的羡慕。我更应该改变姿态，虚心向他学习。还有感谢我们组维嘉这多时间给我帮助。<br>这段时间也让我意识到，思考和解决问题的重要行。也知道一个好的PM应该有的特性。<br>在这里我立一个flag，三个月转正答辩必过。</p><h2 id="她"><a href="#她" class="headerlink" title="她"></a>她</h2><p>她是我最能影响到我的人。她是我最思念的人。她是我最不肯定放弃的人。我的一切都是因她改变的，无论是学习还是生活，她就是我动力的根源。没有她也许我不会有这么努力。<strong>以前我都是听人说，努力是为了自己，我却不认同。</strong> 我认为有个你值得努力的人才是最重要的，没有你努力成功后分享的人，都是扯蛋。别人眼中的我是个什么样子，我无所谓，只要她认为是好的，就已经足够了。父母是亲情，她是爱情。<br>现在她过的并不是特别的好，银行就是个坑。我只希望她能坚强起来，不过总想着回家这件事，越想会越想家。<br>她是一个特别女孩子，特别聪明，但有时候又傻得可爱。我不希望她总是觉得欠我的，我所有做的都是我心甘情愿的，虽然有时候也想让她回“抱”一下，所以希望她大胆的做她自己喜欢的事。<br>从到杭州入职以来，我就想去看她，她总是不让我去，她嫌麻烦。不过她说的没错，两天休息时间，每天上班那么累，我去了还要陪着我，两个人都休息不好。过去三周周六周日我天天浑浑噩噩的，做梦想她，吃饭想她。有时候想的脑袋疼，可是我真的控制不住自己。我自认为我是个情感丰富的人和专一，我想认真对待的人绝对不会含糊。不过她过的也不好，她本来就是很恋家的人，三周时间她都一直闷闷不乐，而且自己一个人在那个鬼地方，无助。我自已想逗她开心，不过感觉每次都适得其反，我承认自己不会安慰人。<br>这周她告诉我她想通了，我很是开心，我不用那么担心她了，也能感受到她不像以前那么忧心忡忡了。我想成为她的家人，能够在她痛苦的时候抱着我安心哭泣的人。每次和她聊天我都很幸福，心里住着一个人是一种充实。<br><strong>最后：谢谢大学认识了你，也谢谢能让我走进你的心里。你若不弃，我便不离。</strong></p><blockquote><p>我人生最大的缺点就是缺点你！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;想成功，想有钱，想养她，想梦有所成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2018&quot;&gt;&lt;a href=&quot;#2018&quot; class=&quot;headerlink&quot; title=&quot;2018&quot;&gt;&lt;/a&gt;2018&lt;/h2&gt;&lt;p&gt;转眼间18年已经过去
      
    
    </summary>
    
      <category term="所思所想" scheme="http://yoursite.com/categories/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/"/>
    
    
      <category term="所思所想" scheme="http://yoursite.com/tags/%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>1688开放平台对接</title>
    <link href="http://yoursite.com/2018/06/19/1688%E5%AF%B9%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/06/19/1688对接/</id>
    <published>2018-06-19T09:33:00.000Z</published>
    <updated>2018-06-27T13:16:24.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>什么是1688开放平台（ <a href="https://open.1688.com" target="_blank" rel="noopener">https://open.1688.com</a>  ）？</p><blockquote><p>依托B2B海量用户资源以及强大的平台优势，是为阿里巴巴商家提供基础服务的重要开放途径，帮助商家提升经营能力、拓宽生意渠道、提高办公效率。从今年开始，阿里巴巴开放平台将向合作伙伴和广大第三方开发者逐步开放会员、公司库、类目、产品、交易、咨讯等一系列接口。为合作伙伴提供快捷的提交通路，多入口最优展现的同时，共享商机，互利双赢。</p></blockquote><hr><h3 id="对接过程"><a href="#对接过程" class="headerlink" title="对接过程"></a>对接过程</h3><p>以下演示是以对接1688采购订单为例。</p><h4 id="1-注册开发者"><a href="#1-注册开发者" class="headerlink" title="1 注册开发者"></a>1 注册开发者</h4><p>如果想使用1688开放平台，必须首先要注册成为开发者，需要同时具备以下两个条件：</p><ol><li>具备一个阿里巴巴中国站帐号；</li><li>必须绑定了通过个人实名（公司企业）认证的支付宝帐号；个人开发者必须绑定通过个人实名认证的支付宝账号，企业开发者必须绑定通过商家认证的支付宝账号；</li></ol><p>开发者身份绑定的支付宝账户用于产品分成结算的收款账户。因此为了确认您的身份和安全考虑，必须通过支付宝认证。</p><h4 id="2-获取证书"><a href="#2-获取证书" class="headerlink" title="2 获取证书"></a>2 获取证书</h4><p>一、什么是应用证书：<br>证书指的是开发者在阿里巴巴开放平台创建应用是默认给开发者的应用开发证书。想要调用1688开放平台上的API必须申请证书。证书包含四个内容：</p><p><strong>证书编号：App Key</strong></p><p><strong>证书密钥：App Secret</strong></p><p>接口权限：开发者可以调用的API权限，包含基础开放与增值包</p><p>证书流量：应用可以调用API的流量限制</p><p>也就是“权限+流量+appkey+app secret=证书”，每个应用都有对应的应用开发证书，在应用创建时开发者获得证书。<br>二、什么是App Key？</p><p>App Key是应用的唯一标识，阿里巴巴开放平台通过App Key来鉴别应用的身份。<br>三、什么是App Secret？</p><p>AppSecret是阿里巴巴开放平台给应用分配的密钥，开发者需要妥善保存这个密钥，这个密钥用来保证应用来源的可靠性，防止被伪造。</p><h5 id="获取证书过程"><a href="#获取证书过程" class="headerlink" title="获取证书过程"></a>获取证书过程</h5><blockquote><p><a href="https://open.1688.com/developer/serviceType.htm?spm=a260s.8209130.sidebar.2.4fbb55edhIdo07#/?_k=l6b00o" target="_blank" rel="noopener">https://open.1688.com/developer/serviceType.htm?spm=a260s.8209130.sidebar.2.4fbb55edhIdo07#/?_k=l6b00o</a></p></blockquote><p>1.<strong>创建应用</strong>：根据自己公司的业务需求可以选择不同的应用类型，如下图所示：</p><p><img src="创建应用.jpg" alt="1688"><br>选择采购对接<br><img src="采购对接.jpg" alt="1688"><br>企业对接面向的是从1688网站上采购的数据信息拉取到公司自己的管理软件中进行统一的管理。点击<strong>采购对接</strong>后填写必要的一些信息提交申请就可以了。<br>在填写信息的时候，<strong>应用类目</strong>选择企业采购，大企业采购一般是通过不了的；<strong>授权用户数</strong>可以选择<strong>单用户授权</strong>也可以选择<strong>多用户授权</strong>，他们其中的区别放到下面讲。<br><img src="信息填写.jpg" alt="1688"></p><p>提交成功后便可在<strong>应用列表</strong>中看到申请到的对接应用。可以点击查看，就会看到应用详情，里面便包括了App Key和App Secret。如下图：<br><img src="查看应用详情.jpg" alt="1688"></p><p>2.<strong>申请解决方案</strong>：即针对你申请到的账户需要申请调用对应API的权限</p><p><strong>申请解决方案</strong>一般在48小时之内会反馈方案是否给予通过。所以开发的时候如果急于上线，需要提前申请。通过的解决方案便可以使用。<br><img src="申请解决方案.jpg" alt="1688"></p><p>3.<strong>测试账号</strong></p><p>当你在解决方案列表看到已经通过的账号，下一步就需要在线测试账号的可用性。<br>在API文档中点击<strong>API TOOLS 在线测试工具</strong>，输入App Key和App Secret便可以测试账号是否可用。<br><img src="测试.jpg" alt="1688"></p><p>4.<strong>下载jar包进行开发</strong></p><p><img src="sdk下载.jpg" alt="1688"></p><p>5.<strong>编程</strong></p><p>具体代码请看我的github上的项目，里面有完整的授权流程代码，地址：<a href="https://github.com/Foutlook/Docking-1688-Interface" target="_blank" rel="noopener">多用户授权下调用1688接口API授权流程</a>。</p><h4 id="3-关于单用户授权和多用户授权的说明"><a href="#3-关于单用户授权和多用户授权的说明" class="headerlink" title="3 关于单用户授权和多用户授权的说明"></a>3 关于单用户授权和多用户授权的说明</h4><p>我们首先看一下官方给的不同授权方式的定义：<br><img src="授权.jpg" alt="1688"></p><blockquote><p><strong>单用户授权和多用户授权</strong>的区别是：<br>1.单用户授权在调用API的时候不需要传access_token，而多用户授权需要传access_token ,不然的话无法调用1688的API。<br>2.单用户授权在申请上线的时候一个公司只能有一个账户，而多用户授权在上线的时候可以有多个账户。<br>3.多用户授权可以关联其他的账户，通过一个账户拉去多个账户的信息。</p></blockquote><p>虽然多用户授权有很多的好处，不过它开发起来要比单用户授权麻烦很多，主要是处理access_token 的问题。<br>首先我们先看看多用户授权下access_token 的授权流程，也就是获取access_token 的流程（<a href="https://open.1688.com/api/sysAuth.htm?spm=a260s.8208024.0.0.9f0e55edLOgOy1&amp;ns=cn.alibaba.open" target="_blank" rel="noopener">官网授权解释地址</a>）：</p><p><img src="流程.jpg" alt="1688"><br>首先通过code即<strong>临时令牌</strong>得到<strong>access_token</strong>，第一次授权后会得到<strong>refresh_token</strong>，等下次access_token过期的时候就可以通过refresh_token来得到。授权的流程图如下所示：<br><img src="授权流程.jpg" alt="1688"></p><p>具体代码请看我的github，地址：<a href="https://github.com/Foutlook/Docking-1688-Interface" target="_blank" rel="noopener">多用户授权下调用1688接口API授权流程</a>。</p><hr><p><strong>END</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;什么是1688开放平台（ &lt;a href=&quot;https://open.1688.com&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
    
      <category term="1688,1688开放平台,阿里巴巴" scheme="http://yoursite.com/tags/1688-1688%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"/>
    
  </entry>
  
  <entry>
    <title>jdk动态代理</title>
    <link href="http://yoursite.com/2018/01/20/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2018/01/20/jdk动态代理/</id>
    <published>2018-01-20T09:33:00.000Z</published>
    <updated>2018-06-26T11:52:00.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h3><p>代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。<strong>代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理</strong>。<br>为了保持行为的一致性，<strong>代理类和委托类</strong>通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。</p><hr><h3 id="动态代理类"><a href="#动态代理类" class="headerlink" title="动态代理类"></a>动态代理类</h3><p>Java动态代理类位于<strong>java.lang.reflect</strong>包下，一般主要涉及到以下两个类：<br>(1) Interface InvocationHandler：该接口中仅定义了一个方法</p><ul><li>publicobject invoke(Object obj,Method method, Object[] args)</li><li>在实际使用时，第一个参数obj一般是<strong>指代理类</strong>，method是被代理的方法，args为该方法的参数数组，这个抽象方法在代理类中动态实现。</li></ul><p>(2) Proxy：该类即为动态代理类，其中主要包含以下内容：    </p><ul><li>protected Proxy(InvocationHandler h)：构造函数，用于给内部的h赋值。</li><li>static InvocationHandler getInvocationHandler(Object proxy) :返回指定代理实例的调用处理程序</li><li>static Class&lt;?&gt; getProxyClass (ClassLoaderloader, Class[] interfaces)：返回代理类的 java.lang.Class 对象，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。</li><li>static boolean isProxyClass(Class&lt;?&gt; cl) //当且仅当指定的类通过 getProxyClass 方法或 newProxyInstance 方法动态生成为代理类时，返回 true。 </li><li><p>static Object newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h):/返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。</p><p><strong>所谓DynamicProxy是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些interface。你当然可以把该class的实例当作这些interface中的任何一个来用。当然，这个DynamicProxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。</strong><br>在使用动态代理类时，我们必须<strong>实现InvocationHandler接口</strong>，通过这种方式，被代理的对象(RealPerson)可以在运行时动态改变，需要控制的接口(Person接口)可以在运行时改变，控制的方式(DynamicSubject类)也可以动态改变，从而实现了非常灵活的动态代理关系。</p></li></ul><hr><h3 id="动态代理的步骤"><a href="#动态代理的步骤" class="headerlink" title="动态代理的步骤"></a>动态代理的步骤</h3><p>1.创建一个实现接口InvocationHandler的类，它必须实现invoke方法<br>2.创建被代理的类以及接口<br>3.通过Proxy的静态方法<br>newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)创建一个代理<br>4.通过代理调用方法</p><hr><h3 id="动态代理的实现"><a href="#动态代理的实现" class="headerlink" title="动态代理的实现"></a>动态代理的实现</h3><p>1：创建动态代理的接口</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.Proxy_one;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态代理接口</span></span><br><span class="line">public interface Person &#123;</span><br><span class="line">String SayHello(String name);</span><br><span class="line">String SayGoodBye();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2：创建需要代理的对象</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.Proxy_one;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际对象</span></span><br><span class="line">public class RealPerson implements Person &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String SayHello(String name) &#123;</span><br><span class="line">return "Hello "+name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String SayGoodBye() &#123;</span><br><span class="line">return "Bye";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3：实现InvocationHandler类，重写invoke方法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.Proxy_one;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用处理类实现类</span></span><br><span class="line"><span class="comment">//每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象</span></span><br><span class="line">public class InvocationHandlerImpl implements InvocationHandler &#123;</span><br><span class="line"><span class="comment">//我们要代理的真是对象</span></span><br><span class="line">private Person person;</span><br><span class="line">public InvocationHandlerImpl(Person person) &#123;</span><br><span class="line">this.person = person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法负责集中处理动态代理类上的所有方法调用</span></span><br><span class="line"><span class="comment"> * 调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"><span class="comment">//在代理真实对象方法前可以添加自己的操作</span></span><br><span class="line">System.out.println("在调用方法之前，我正在走路！");</span><br><span class="line">System.out.println("Method:"+method);</span><br><span class="line"><span class="comment">/*当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler</span></span><br><span class="line"><span class="comment"> *对象的invoke方法进行调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object returnValue = method.invoke(person, args);</span><br><span class="line"><span class="comment">//调用真实的代理对象的方法后，我们可以添加自己的方法</span></span><br><span class="line">System.out.println("调用之后，我继续向前走！");</span><br><span class="line"></span><br><span class="line">return returnValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4：测试jdk动态代理</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.Proxy_one;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class DynamicProxyTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"><span class="comment">//代理的真实对象</span></span><br><span class="line">Person realperson = new RealPerson();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能</span></span><br><span class="line"><span class="comment">         * 实现方法调用从代理类到委托类的分派转发</span></span><br><span class="line"><span class="comment">         * 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.</span></span><br><span class="line"><span class="comment">         * 即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">InvocationHandler ih = new InvocationHandlerImpl(realperson);</span><br><span class="line">Person proxy = (Person) Proxy.newProxyInstance(realperson.getClass().getClassLoader(),</span><br><span class="line">realperson.getClass().getInterfaces(), ih);</span><br><span class="line">System.out.println("动态代理对象的类型："+proxy.getClass().getName());</span><br><span class="line">String hello = proxy.SayHello("樊兴凯");</span><br><span class="line">System.out.println(hello);</span><br><span class="line">String bye = proxy.SayGoodBye();</span><br><span class="line">System.out.println(bye);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5：输出结果</p><blockquote><p>动态代理对象的类型：com.sun.proxy.$Proxy0<br>在调用方法之前，我正在走路！<br>Method:public abstract java.lang.String com.fan.Proxy_one.Person.SayHello(java.lang.String)<br>调用之后，我继续向前走！<br>Hello 张三<br>在调用方法之前，我正在走路！<br>Method:public abstract java.lang.String com.fan.Proxy_one.Person.SayGoodBye()<br>调用之后，我继续向前走！<br>Bye</p></blockquote><hr><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>使用匿名内部类的方式来实现 InvocationHandlerImpl</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.Proxy_two;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class DynamicProxyTest2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Person person = new RealPerson();</span><br><span class="line">Person proxy = (Person)Proxy.newProxyInstance(person.getClass().getClassLoader(), person.getClass().getInterfaces(),</span><br><span class="line">new InvocationHandler() &#123;</span><br><span class="line"><span class="comment">//使用匿名内部类的方式</span></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"><span class="comment">//在方法调用前，添加自己的动作</span></span><br><span class="line">System.out.println("打招呼之前-");</span><br><span class="line">System.out.println("Method:"+method);</span><br><span class="line">Object obj = method.invoke(person, args);</span><br><span class="line">System.out.println("打招呼之后----");</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println("动态代理对象的类型："+proxy.getClass().getName());</span><br><span class="line">String hello = proxy.SayHello("张三");</span><br><span class="line">System.out.println(hello);</span><br><span class="line">String goodbye = proxy.SayGoodBye();</span><br><span class="line">System.out.println(goodbye);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><blockquote><p>动态代理对象的类型：com.sun.proxy.$Proxy0<br>打招呼之前-<br>Method:public abstract java.lang.String com.fan.Proxy_two.Person.SayHello(java.lang.String)<br>打招呼之后—-<br>Hello 张三<br>打招呼之前-<br>Method:public abstract java.lang.String com.fan.Proxy_two.Person.SayGoodBye()<br>打招呼之后—-<br>Bye</p></blockquote><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>一个典型的动态代理创建对象过程可分为以下四个步骤：<br>1、通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = new InvocationHandlerImpl(…);<br>2、通过为Proxy类指定ClassLoader对象和一组interface创建动态代理类<br>Class clazz = Proxy.getProxyClass(classLoader,new Class[]{…});<br>3、通过反射机制获取动态代理类的构造函数，其参数类型是调用处理器接口类型<br>Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});<br>4、通过构造函数创建代理类实例，此时需将调用处理器对象作为参数被传入<br>Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler));<br>为了简化对象创建过程，Proxy类中的newInstance方法封装了2~4，只需两步即可完成代理对象的创建。<br>生成的RealPerson继承Proxy类实现Person接口，实现的Person的方法实际调用处理器的invoke方法，而invoke方法利用反射调用的是被代理对象的的方法（Object result=method.invoke(proxied,args)）</strong></p><hr><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>Proxy已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。<br>Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。有很多条理由，人们可以否定对 class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。如果只从方法的声明以及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。但是，不完美并不等于不伟大，伟大是一种本质，Java动态代理就是佐例。<br><strong>jdk给目标类提供动态要求目标类必须实现接口，当一个目标类不实现接口时，jdk是无法为其提供动态代理的。cglib 却能给这样的类提供动态代理。</strong>cglib在接下来的时间里将会介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;动态代理&quot;&gt;&lt;a href=&quot;#动态代理&quot; class=&quot;headerlink&quot; title=&quot;动态代理&quot;&gt;&lt;/a&gt;动态代理&lt;/h2&gt;&lt;h3 id=&quot;什么是代理&quot;&gt;&lt;a href=&quot;#什么是代理&quot; class=&quot;headerlink&quot; title=&quot;什么是代理&quot;&gt;
      
    
    </summary>
    
    
      <category term="java,动态代理" scheme="http://yoursite.com/tags/java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse中git的使用</title>
    <link href="http://yoursite.com/2018/01/16/Egit%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/01/16/Egit的使用/</id>
    <published>2018-01-16T09:33:00.000Z</published>
    <updated>2018-06-26T11:51:57.068Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>git在eclipse中的配置和远程仓库中关联，这里不再累述，如果有问题可以参考下面博客：这里有详细的说明。</strong></p><blockquote><p><a href="http://blog.csdn.net/hhhccckkk/article/details/10458159" target="_blank" rel="noopener">http://blog.csdn.net/hhhccckkk/article/details/10458159</a></p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>下面主要是我在使用中遇到的问题：rejected - non-fast-forward<br><img src="rejected.jpg" alt="git"><br>我在网上查找原因的时候，并没有一个很完整的文档，总结的都是挺乱的。故我对使用方式给予详细总结，以帮助更多的人。</p><hr><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p><strong>出现此问题的原因主要是：</strong></p><blockquote><p>我们平时使用eclipse开发的时候，主要是用git的commit和push，如果你的github库没有初始化，第一次push是可以正确提交的，但是当你已经push过一次后，会遇到无法提交到master分支（因为master分支是在服务器已经初始化好了，在服务器上已经存在了一个master分支，你在本地初始化的master分支和服务器的有冲突，并不是一个分支，就会提示rejected - non-fast-forward），如果你此时非要想提交到主分支，必须先要把服务器的初始化的git主分支pull到本地。只有这样才能正确的提交。</p></blockquote><hr><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><strong>1，点window—preference–team—git–configuration————-Repository Settings，Repository选择你的项目的本地仓库，然后点右边的open，</strong>视图如下：</p><p><img src="configuration2.jpg" alt="git"></p><p>open后会看到如下的config信息<br><img src="config.jpg" alt="git"></p><p><strong>2，然后在上面的基础上填上如下信息</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">   remote = origin</span><br><span class="line">   merge = refs/heads/master</span><br><span class="line"></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">   url = git@github<span class="selector-class">.com</span>:xxxx/xx                    -----&gt;你自己的仓库ssh的url</span><br><span class="line">   fetch = +refs/heads<span class="comment">/*:refs/remotes/origin/*</span></span><br><span class="line"><span class="comment">   push = refs/heads/master:refs/heads/master</span></span><br></pre></td></tr></table></figure><p><img src="gitRepositories.jpg" alt="git"></p><p><strong>3，配置好后选择项目Team–&gt; pull ，会看到项目会变成如下效果：</strong></p><p><img src="pull.jpg" alt="git"></p><p>查看本地仓库目录：<br><img src="readme.jpg" alt="git"></p><p><strong>4，push本地项目到远程仓库</strong></p><p><img src="destination.jpg" alt="git"></p><p>过程和第一次push的过程相同，填写信息然后push就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;git在eclipse中的配置和远程仓库中关联，这里不再累述，如果有问题可以参考下面博客：这里有详细的说明。&lt;/strong
      
    
    </summary>
    
    
      <category term="eclipse,git,github" scheme="http://yoursite.com/tags/eclipse-git-github/"/>
    
  </entry>
  
  <entry>
    <title>装饰者模式</title>
    <link href="http://yoursite.com/2017/12/30/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/12/30/装饰者模式/</id>
    <published>2017-12-30T09:33:00.000Z</published>
    <updated>2018-06-26T11:51:58.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设置模式之装饰者模式"><a href="#设置模式之装饰者模式" class="headerlink" title="设置模式之装饰者模式"></a>设置模式之装饰者模式</h2><p><strong>装饰者模式(Decorator)是一种结构式模式。动态地给一个对象添加一些额外的职责。就增加功能来说，装饰者模式相比生成子类更为灵活。同时还可以让这些装饰类互相装饰。</strong><br> <img src="装饰者模式.jpg" alt="设计模式"></p><hr><h3 id="1-装饰者设计模式的步骤："><a href="#1-装饰者设计模式的步骤：" class="headerlink" title="1: 装饰者设计模式的步骤："></a>1: 装饰者设计模式的步骤：</h3><p>a.在装饰类的内部维护一个被装饰类的引用。<br>b.让装饰类有一个共同的父类或者是父接口</p><hr><h3 id="2-具体过程："><a href="#2-具体过程：" class="headerlink" title="2:具体过程："></a>2:具体过程：</h3><p>Component : 定义一个对象接口，可以给这些对象动态地添加职责。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line">public interface Component &#123;</span><br><span class="line">void operation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteComponent:实现Component定义的接口</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Component定义的接口</span></span><br><span class="line">public class ConcreteComponent implements Component &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void operation() &#123;</span><br><span class="line">System.out.println("初始化");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Decorator : 装饰抽象类，继承了 Component， 从外类来扩展 Component 类的功能，但对于 Component 来说，是无需知道 Decorator 的存在的。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line">public class Decorator implements Component &#123;</span><br><span class="line"><span class="comment">//维护一个Component对象，和Component形成聚合关系</span></span><br><span class="line">private Component component;</span><br><span class="line">public Decorator(Component component) &#123;</span><br><span class="line">this.component = component;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用要修饰对象的原方法</span></span><br><span class="line">@Override</span><br><span class="line">public void operation() &#123;</span><br><span class="line">component.operation();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteDecoratorA : 具体的装饰对象，起到给 Component 添加职责A的功能。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line">public class ConcreteDecoretorA extends Decorator &#123;</span><br><span class="line"></span><br><span class="line">public ConcreteDecoretorA(Component component) &#123;</span><br><span class="line">super(component);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void operation()&#123;</span><br><span class="line">super.operation();</span><br><span class="line">System.out.println("添加属性：性属性1");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteDecoratorB : 具体的装饰对象，起到给 Component 添加职责B的功能。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line">public class ConcreteDecoratorB extends Decorator &#123;</span><br><span class="line"></span><br><span class="line">public ConcreteDecoratorB(Component component) &#123;</span><br><span class="line">super(component);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void operation() &#123;</span><br><span class="line">super.operation();</span><br><span class="line">System.out.println("添加行为");</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line">public class DecoratorPattern &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Component component = new ConcreteComponent();</span><br><span class="line">component.operation();</span><br><span class="line">System.out.println("++++++++++++++++++++++");</span><br><span class="line"></span><br><span class="line">Decorator decoratorA = new  ConcreteDecoretorA(component);</span><br><span class="line">decoratorA.operation();     //通过super向上级层层调用</span><br><span class="line">System.out.println("++++++++++++++++++++++");</span><br><span class="line">Decorator decoratorB = new ConcreteDecoratorB(decoratorA);</span><br><span class="line">decoratorB.operation();//B调用A的 --A调用父类的，父类调用接口的实现类operation方法</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><blockquote><p>初始化<br>++++++++++++++++++<br>初始化<br>添加属性：性属性1<br>++++++++++++++++++<br>初始化<br>添加属性：性属性1<br>添加行为</p></blockquote><hr><h3 id="3-装饰者模式的应用场景"><a href="#3-装饰者模式的应用场景" class="headerlink" title="3:装饰者模式的应用场景"></a>3:装饰者模式的应用场景</h3><p>a.需要动态的、透明的为一个对象添加职责，即不影响其他对象。<br>b.需要动态的给一个对象添加功能，这些功能可以再动态的撤销。<br>c.需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。<br>d.当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</p><hr><h3 id="4-要点："><a href="#4-要点：" class="headerlink" title="4:要点："></a>4:要点：</h3><ul><li>装饰者和被装饰对象有相同的超类型。</li><li>可以用一个或多个装饰者包装一个对象。</li><li>装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的。</li><li>对象可以在任何时候被装饰，所以可以在运行时动态的，不限量的用你喜欢的装饰者来装饰对象。</li><li>装饰模式中使用继承的关键是想达到装饰者和被装饰对象的类型匹配，而不是获得其行为。</li><li>装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。在实际项目中可以根据需要为装饰者添加新的行为，做到“半透明”装饰者。</li></ul><hr><h3 id="5-继承实现的增强类和修饰模式实现的增强类有和区别？"><a href="#5-继承实现的增强类和修饰模式实现的增强类有和区别？" class="headerlink" title="5:继承实现的增强类和修饰模式实现的增强类有和区别？"></a>5:继承实现的增强类和修饰模式实现的增强类有和区别？</h3><blockquote><p>继承实现的增强类： 优点：代码结构清晰，而且实现简单.<br>缺点：对于每一个的需要增强的类都要创建具体的子类来帮助其增强，这样会导致继承体系过于庞大。</p><p>装饰者设计模式实现的增强类： 优点：内部可以通过多态技术对多个需要增强的类进行增强，可以使这些装饰类达到互相装饰的效果，使用比较灵活。<br>缺点：需要内部通过多态技术维护需要被增强的类的实例。进而使得代码稍微复杂。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设置模式之装饰者模式&quot;&gt;&lt;a href=&quot;#设置模式之装饰者模式&quot; class=&quot;headerlink&quot; title=&quot;设置模式之装饰者模式&quot;&gt;&lt;/a&gt;设置模式之装饰者模式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;装饰者模式(Decorator)是一种结构式模式。动态地给一
      
    
    </summary>
    
    
      <category term="设计模式,java" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-java/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装Vundle管理vim插件</title>
    <link href="http://yoursite.com/2017/11/20/Ubuntu%E5%AE%89%E8%A3%85Vundle/"/>
    <id>http://yoursite.com/2017/11/20/Ubuntu安装Vundle/</id>
    <published>2017-11-20T09:33:00.000Z</published>
    <updated>2017-12-09T08:50:51.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>我在学习Linux这段时间里，使用vim编程，为了提高自己的逼格，也为了提高自己的效率，就尝试着安装了2个插件。感觉逼格高了很多。</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装其他插件之前，我们首先需要安装一个管理插件的插件，它就是Vundle，Vundle可以帮助我们管理和安装其他的插件，非常好用。</p><h3 id="安装Vundle插件"><a href="#安装Vundle插件" class="headerlink" title="安装Vundle插件"></a>安装Vundle插件</h3><p>Vundle可以在GitHub上找到，地址：<a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="noopener">https://github.com/VundleVim/Vundle.vim</a> </p><p>1、  如果在你的Linux或者Ubuntu中没有暗转git，首先请先安装git</p><blockquote><p>sudo apt-get install git</p></blockquote><p>2、 使用git安装Vundle ，可以安装到~/.vim/bundle/Vundle.vim下</p><blockquote><p>git clone <a href="https://github.com/VundleVim/Vundle.vim.git" target="_blank" rel="noopener">https://github.com/VundleVim/Vundle.vim.git</a> ~/.vim/bundle/Vundle.vim</p></blockquote><p>3、 添加官方文档提供的配置信息到  ~/.vimrc 中(.vimrc 如果不存在就创建一个【vi  ~/.vimrc】)：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">set nocompatible              <span class="string">" be iMproved, required</span></span><br><span class="line"><span class="string">filetype off                      "</span> required</span><br><span class="line"></span><br><span class="line"><span class="string">" set the runtime path to include Vundle and initialize</span></span><br><span class="line"><span class="string">set rtp+=~/.vim/bundle/Vundle.vim</span></span><br><span class="line"><span class="string">call vundle#begin()</span></span><br><span class="line"><span class="string">"</span> alternatively, pass <span class="selector-tag">a</span> path where Vundle should install plugins</span><br><span class="line"><span class="string">"call vundle#begin('~/some/path/here')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> let Vundle manage Vundle, required</span><br><span class="line">Plugin <span class="string">'VundleVim/Vundle.vim'</span></span><br><span class="line"></span><br><span class="line"><span class="string">" The following are examples of different formats supported.</span></span><br><span class="line">" Keep Plugin commands between vundle#begin/end.</span><br><span class="line"><span class="string">" plugin on GitHub repo</span></span><br><span class="line"><span class="string">Plugin 'tpope/vim-fugitive'</span></span><br><span class="line"><span class="string">"</span> plugin from http:<span class="comment">//vim-scripts.org/vim/scripts.html</span></span><br><span class="line"><span class="string">" Plugin 'L9'</span></span><br><span class="line"><span class="string">"</span> Git plugin not hosted on GitHub</span><br><span class="line">Plugin <span class="string">'git://git.wincent.com/command-t.git'</span></span><br><span class="line"><span class="string">" git repos on your local machine (i.e. when working on your own plugin)</span></span><br><span class="line"><span class="string">Plugin 'file:///home/gmarik/path/to/plugin'</span></span><br><span class="line"><span class="string">"</span> The sparkup vim script is <span class="keyword">in</span> <span class="selector-tag">a</span> subdirectory of this repo called vim.</span><br><span class="line"><span class="string">" Pass the path to set the runtimepath properly.</span></span><br><span class="line"><span class="string">Plugin 'rstacruz/sparkup', &#123;'rtp': 'vim/'&#125;</span></span><br><span class="line"><span class="string">"</span> Install L9 and avoid <span class="selector-tag">a</span> Naming conflict <span class="keyword">if</span> you<span class="string">'ve already installed a</span></span><br><span class="line"><span class="string">" different version somewhere else.</span></span><br><span class="line"><span class="string">" Plugin '</span>ascenator/L9<span class="string">', &#123;'</span>name<span class="string">': '</span>newL9<span class="string">'&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">" All of your Plugins must be added before the following line</span></span><br><span class="line"><span class="string">call vundle#end()            " required</span></span><br><span class="line"><span class="string">filetype plugin indent on    " required</span></span><br><span class="line"><span class="string">" To ignore plugin indent changes, instead use:</span></span><br><span class="line"><span class="string">"filetype plugin on</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">" Brief help</span></span><br><span class="line"><span class="string">" :PluginList       - lists configured plugins</span></span><br><span class="line"><span class="string">" :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate</span></span><br><span class="line"><span class="string">" :PluginSearch foo - searches for foo; append `!` to refresh local cache</span></span><br><span class="line"><span class="string">" :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">" see :h vundle for more details or wiki for FAQ</span></span><br><span class="line"><span class="string">" Put your non-Plugin stuff after this line</span></span><br></pre></td></tr></table></figure><blockquote><p> <strong>注意：如果按这个文件配置，我在进行安装的时候回报错：</strong><br> 提示说  Plugin ‘file:///home/gmarik/path/to/plugin’   找不到，文档中说：git repos on your local machine (i.e. when working on your own plugin)  意思是这个安装本地插件的一个目录，我这没有本地插件，所以我就把这句注释掉了。</p></blockquote><p>4、  打开vim ，安装默认插件：</p><blockquote><p>只在终端键入 vim，后面什么都不加<br>    sudo  vim    –sudo临时提高权限，如果不加sudo，可能会遇到权限不够。<br>   然后键入下面的命令<br>    :PluginInstall<br>   之后等待安装完成，[ :q ] 来退出即可</p></blockquote><p> 安装成功如下图所示：<br> <img src="安装语句.png" alt="Ubuntu"></p><h3 id="安装2个常用插件"><a href="#安装2个常用插件" class="headerlink" title="安装2个常用插件"></a>安装2个常用插件</h3><p>1、  tagbar</p><p>这个插件可以浏览当前文件的标签，如果想更深的了解，GitHub地址为:   <a href="https://github.com/majutsushi/tagbar" target="_blank" rel="noopener">https://github.com/majutsushi/tagbar</a><br>效果图如下：<br><img src="vim-tagbar.png" alt="Ubuntu"></p><ul><li>该插件安装之前需要先安装 ctags</li></ul><blockquote><p>  sudo apt-get install ctags</p></blockquote><ul><li>添加插件和其他配置信息到   ~/.vimrc 中</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">进入 ~/.vimrc</span><br><span class="line"></span><br><span class="line"># 添加以下  tagbar  插件</span><br><span class="line">Plugin <span class="string">'majutsushi/tagbar'</span></span><br><span class="line"></span><br><span class="line"># 配置 tagbar 插件</span><br><span class="line">let g:tagbar_ctags_bin=<span class="string">'ctags'</span>     <span class="string">"ctags 程序的路径</span></span><br><span class="line"><span class="string">let g:tagbar_width=30                   "</span>窗口宽度设置为 <span class="number">30</span></span><br><span class="line">let g:tagbar_left=<span class="number">1</span>                         <span class="string">"设置在 vim 左边显示</span></span><br><span class="line"><span class="string">let g:tagbar_map_openfold = "</span>zv<span class="string">"   "</span>按 zv 组合键打开标签，默认 zc 关闭标签</span><br><span class="line"></span><br><span class="line"><span class="string">"如果是 C 语言的程序的话，tagbar 自动开启</span></span><br><span class="line"><span class="string">autocmd BufReadPost *.cpp,*.c,*.h,*.hpp,*.cc,*.cxx call tagbar#autoopen() </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>我设置 F2 为打开或者关闭的快捷键，根据你的习惯更改</span><br><span class="line">nnoremap &lt;silent&gt; &lt;F2&gt; :TagbarToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure><ul><li>然后通过命令进行安装，语句和安装Vundle 第4步相同</li></ul><p>2、  安装 vim-airline 插件<br>    这个插件没有很大的实用性，但能增加逼格，增加vim的有趣性。<br>    <strong>第一步，我们先把下面的需要配置的文件添加到 ~/.vimrc 中</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" ------------------------安装 vim-airline------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set laststatus=2   "</span> 永远显示状态栏</span><br><span class="line">set t_Co=<span class="number">256</span>       <span class="string">" 在windows中用xshell连接打开vim可以显示色彩</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>Vim 在与屏幕/键盘交互时使用的编码(取决于实际的终端的设定)        </span><br><span class="line">:set encoding=utf-<span class="number">8</span></span><br><span class="line">:set langmenu=zh_CN.UTF-<span class="number">8</span></span><br><span class="line">:set fileencodings=utf-<span class="number">8</span></span><br><span class="line">:set fileencoding=utf-<span class="number">8</span></span><br><span class="line">:set termencoding=utf-<span class="number">8</span></span><br><span class="line"></span><br><span class="line">Plugin <span class="string">'vim-airline'</span>    </span><br><span class="line">let g:airline_theme=<span class="string">"molokai"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"这个是安装字体后 必须设置此项"</span> </span><br><span class="line">let g:airline_powerline_fonts = <span class="number">1</span>  </span><br><span class="line"><span class="string">"打开tabline功能,方便查看Buffer和切换,省去了minibufexpl插件</span></span><br><span class="line"><span class="string"> let g:airline#extensions#tabline#enabled = 1</span></span><br><span class="line"><span class="string"> let g:airline#extensions#tabline#buffer_nr_show = 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>设置切换Buffer快捷键<span class="string">"</span></span><br><span class="line"><span class="string">nnoremap &lt;F4&gt; :bn&lt;CR&gt;</span></span><br><span class="line"><span class="string">"</span> 关闭状态显示空白符号计数</span><br><span class="line"> let g:airline#extensions#whitespace<span class="selector-id">#enabled</span> = <span class="number">0</span></span><br><span class="line"> let g:airline#extensions#whitespace<span class="selector-id">#symbol</span> = <span class="string">'!'</span></span><br><span class="line"></span><br><span class="line"> <span class="string">" 设置consolas字体"</span>前面已经设置过</span><br><span class="line"> <span class="string">"set guifont=Consolas\ for\ Powerline\ FixedD:h11</span></span><br><span class="line"><span class="string"> if !exists('g:airline_symbols')</span></span><br><span class="line"><span class="string">let g:airline_symbols = &#123;&#125;</span></span><br><span class="line"><span class="string"> endif</span></span><br><span class="line"><span class="string"> "</span> old vim-powerline symbols</span><br><span class="line"> let g:airline_left_sep = <span class="string">'⮀'</span></span><br><span class="line"> let g:airline_left_alt_sep = <span class="string">'⮁'</span></span><br><span class="line"> let g:airline_right_sep = <span class="string">'⮂'</span></span><br><span class="line"> let g:airline_right_alt_sep = <span class="string">'⮃'</span></span><br><span class="line"> let g:airline_symbols<span class="selector-class">.branch</span> = <span class="string">'⭠'</span></span><br><span class="line"> let g:airline_symbols<span class="selector-class">.readonly</span> = <span class="string">'⭤'</span></span><br></pre></td></tr></table></figure><p><strong>第二步：要安装字体，如果没有安装字体的话，vim-airline的效果就没法正确的显示</strong></p><p>字体安装GitHub地址：<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">https://github.com/powerline/fonts</a></p><p>在终端上一步步输入下面的内容即可：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># clone</span><br><span class="line">git clone https:<span class="comment">//github.com/powerline/fonts.git --depth=1</span></span><br><span class="line"># install</span><br><span class="line">cd fonts</span><br><span class="line">./install.sh</span><br><span class="line"># clean-up a bit</span><br><span class="line">cd ..</span><br><span class="line">rm -rf fonts</span><br></pre></td></tr></table></figure><p>第三步：继续执行安装Vundle的第四步即可</p><p>效果图如下：<br> <img src="字体.png" alt="Ubuntu"></p><blockquote><p> 注意：在安装的时候，如果遇到权限不够，使用sudo vim 临时提高权限<br> 使用vim时遇到的问题： 如何用vim命令把编辑文件的几行内容拷贝到一个新文件 — 如把58行到79行拷贝到~/test.txt文件可以使用下面的命令&gt;&gt; :58,79w!~/.test.txt</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;我在学习Linux这段时间里，使用vim编程，为了提高自己的逼格，也为了提高自己的效率，就尝试着安装了2个插件。感觉逼格高了
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux，vim，Vundle" scheme="http://yoursite.com/tags/Linux%EF%BC%8Cvim%EF%BC%8CVundle/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解JVM】总结</title>
    <link href="http://yoursite.com/2017/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/10/20/深入理解JVM总结/</id>
    <published>2017-10-20T02:33:00.000Z</published>
    <updated>2017-12-05T06:50:42.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过三周的时间我把<strong>周志明</strong>的【深入理解java虚拟机】看完了，对我而言我感觉只是看到一些皮毛，以上的文章都是基于这本书来写的，基本上能理解的都写了上去，我也参考了许多大V的博客，下面我把主要参考博客链接发下下面，如果觉得我写的一般般，可以参考他们的，谢谢！</p><blockquote><p> 兰亭风雨：<a href="http://my.csdn.net/mmc_maodun" target="_blank" rel="noopener">http://my.csdn.net/mmc_maodun</a><br> ChangWen的博客： <a href="http://blog.csdn.net/oChangWen" target="_blank" rel="noopener">http://blog.csdn.net/oChangWen</a><br> 生命壹号：<a href="http://www.cnblogs.com/smyhvae/category/587723.html" target="_blank" rel="noopener">http://www.cnblogs.com/smyhvae/category/587723.html</a></p></blockquote><p>生命壹号对于JVM的总结：<br><a href="http://www.cnblogs.com/smyhvae/p/4810168.html" target="_blank" rel="noopener">http://www.cnblogs.com/smyhvae/p/4810168.html</a></p><p>以下是我的总结：通过XMind见到总结了一下，希望对你有用：<br><img src="JVM常见问题总结.png" alt="总结"></p><blockquote><p>一个菜鸟到一个大神，需要经历许多许多，但是只要梦想在，就要继续前进，因为有很多人需要你照顾。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;经过三周的时间我把&lt;strong&gt;周志明&lt;/strong&gt;的【深入理解java虚拟机】看完了，对我而言我感觉只是看到一些皮毛，以上的文章都是
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM，总结" scheme="http://yoursite.com/tags/JVM%EF%BC%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解JVM】之七：Javac编译与JIT编译</title>
    <link href="http://yoursite.com/2017/10/15/Javac%E7%BC%96%E8%AF%91%E4%B8%8EJIT%E7%BC%96%E8%AF%91/"/>
    <id>http://yoursite.com/2017/10/15/Javac编译与JIT编译/</id>
    <published>2017-10-15T02:33:00.000Z</published>
    <updated>2017-12-05T06:51:06.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>本文章参考周志明的【深入理解Java虚拟机】<br>代码编译的结果从本地机器码转变成字节码，是存储格式发展的一小步，却是编译语言发展的一大步。</p></blockquote><hr><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java虚拟机的执行引擎在执行java代码的时候都有解释执行（通过解释器执行）和编译执行（通过编译器产生本地代码执行）这两种选择。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不论是解释还是编译，也不论是物理机还是虚拟机，大部分的程序代码从开始编译到最终转化成物理机的目标代码或虚拟机能执行的指令集之前，都会按照如下图所示的各个步骤进行：<br><img src="编译过程.png" alt="JIT"></p><blockquote><p>其中绿色的模块可以选择性实现。很容易看出，上图中间的那条分支是解释执行的过程（即一条字节码一条字节码地解释执行，如JavaScript），而下面的那条分支就是传统编译原理中从源代码到目标机器代码的生成过程。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今，基于物理机、虚拟机等的语言，大多都遵循这种基于现代经典编译原理的思路，在执行前先对程序源码进行词法解析和语法解析处理，把源码转化为抽象语法树。<strong>对于一门具体语言的实现来说，词法和语法分析乃至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言。也可以把抽象语法树或指令流之前的步骤实现一个半独立的编译器，这类代表是Java语言。又或者可以把这些步骤和执行引擎全部集中在一起实现，如大多数的JavaScript执行器。</strong></p><h2 id="Javac编译"><a href="#Javac编译" class="headerlink" title="Javac编译"></a>Javac编译</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java中提到“编译”，<strong>自然很容易想到Javac编译器将<em>.java文件编译成为</em>.class文件的过程，这里的Javac编译器称为前端编译器</strong>，其他的前端编译器还有诸如Eclipse JDT中的增量式编译器ECJ等。<strong>相对应的还有后端编译器，它在程序运行期间将字节码转变成机器码（现在的Java程序在运行时基本都是解释执行加编译执行）</strong>，如HotSpot虚拟机自带的JIT（Just In Time Compiler）编译器（分Client端和Server端）。另外，<strong>有时候还有可能会碰到静态提前编译器（AOT，Ahead Of Time Compiler）直接把*.java文件编译成本地机器代码</strong>，如GCJ、Excelsior JET等，这类编译器我们应该比较少遇到。<br>下面简要说下Javac编译（前端编译）的过程：</p><h3 id="词法、语法分析"><a href="#词法、语法分析" class="headerlink" title="词法、语法分析"></a>词法、语法分析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;词法分析是将源代码的字符流转变为标记（Token）集合。单个字符是程序编写过程中的的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符等都可以成为标记，比如整型标志int由三个字符构成，但是它只是一个标记，不可拆分。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语法分析是根据Token序列来构造抽象语法树的过程。抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，如bao、类型、修饰符、运算符等。经过这个步骤后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上。</p><h3 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成了语法分析和词法分析之后，下一步就是填充符号表的过程。符号表是由一组符号地址和符号信息构成的表格。符号表中所登记的信息在编译的不同阶段都要用到，在语义分析（后面的步骤）中，符号表所登记的内容将用于语义检查和产生中间代码，在目标代码生成阶段，党对符号名进行地址分配时，符号表是地址分配的依据。</p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是读结构上正确的源程序进行上下文有关性质的审查。语义分析过程分为标注检查和数据及控制流分析两个步骤：</p><ul><li>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量和赋值之间的数据类型是否匹配等。</li><li>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题</li></ul><h3 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字节码生成是Javac编译过程的最后一个阶段。字节码生成阶段不仅仅是把前面各个步骤所生成的信息转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。 实例构造器<init>（）方法和类构造器<clinit>（）方法就是在这个阶段添加到语法树之中的（这里的实例构造器并不是指默认的构造函数，而是指我们自己重载的构造函数，如果用户代码中没有提供任何构造函数，那编译器会自动添加一个没有参数、访问权限与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成了）。</clinit></init></p><hr><h2 id="JIT编译"><a href="#JIT编译" class="headerlink" title="JIT编译"></a>JIT编译</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java程序最初是仅仅通过解释器解释执行的，即对字节码逐条解释执行，这种方式的执行速度相对会比较慢，尤其当某个方法或代码块运行的特别频繁时，这种方式的执行效率就显得很低。于是后来在虚拟机中引入了<strong>JIT编译器</strong>（即时编译器），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是JIT编译器。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在主流的商用虚拟机（如Sun HotSpot、IBM J9）中几乎都同时包含解释器和编译器（三大商用虚拟机之一的JRockit是个例外，它内部没有解释器，因此会有启动相应时间长之类的缺点，但它主要是面向服务端的应用，这类应用一般不会重点关注启动时间）。</p><blockquote><p><strong>二者各有优势：</strong><br> <strong>当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行；当程序运行后，随着时间的推移，编译器逐渐会返回作用，把越来越多的代码编译成本地代码后，可以获取更高的执行效率。解释执行可以节约内存，而编译执行可以提升效率。</strong></p></blockquote><p>同时解释器还可以作为编译器激进优化时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类后类型继承结构出现变化，出现“罕见陷阱”时可以通过逆优化退回到解释状态继续执行（部分没有解释器的虚拟机中也会采用不进行激进优化的C1编译器-（在虚拟机中习惯将Client compiler称为C1，将Server Compiler称为C2）担任“逃生门”的角色），因此，在整个虚拟机执行机构中，解释器与编译器经常配合工作，如下图：<br><img src="解释器与编译器的交互.png" alt="JIT"></p><p>  HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。<br>无论采用的编译器hiClient Compiler还是Server Compiler，解释器与编译器搭配使用的方式在虚拟机中称为“混合模式”（Mixed Mode）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启用分层编译的策略（1.7默认开启），分层编译根据编译器编译，优化的规模与耗时，划分出不同的编译层次，其中包括：</p><ul><li>第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译</li><li>第1层，也成C1编译，将字节码编译为本地代码，进行简单，可靠的优化，如有必要将加入性能监控的逻辑。</li><li>第2层（或2层以上），也成C2编译，也是将字节码编译成本地代码，但是会启用一些耗时较长的优化甚至会根据性能监控信息进行一些不可靠的激进优化。</li></ul><h3 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h3><p><strong>运行过程中会被即时编译器编译的“热点代码”有两类：</strong></p><ul><li>被多次调用的方法。</li><li>被多次调用的循环体。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 两种情况，编译器都是以整个方法作为编译对象，这种编译也是虚拟机中标准的编译方式。要知道一段代码或方法是不是热点代码，是不是需要触发即时编译，需要进行Hot Spot Detection（热点探测）。<strong>目前主要的热点 判定方式有以下两种：</strong></p><ul><li><strong>基于采样的热点探测</strong>：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li><li><p><strong>基于计数器的热点探测</strong>：采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。</p><p><strong>在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。</strong></p><p><strong>方法调用计数器用来统计方法调用的次数</strong>，在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数。。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，<strong>按这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减，而这段时间就称为此方法统计的半衰周期。</strong></p></li></ul><p>  <strong>回边计数器用于统计一个方法中循环体代码执行的次数</strong>（准确地说，应该是回边的次数，因为并非所有的循环都是回边），在字节码中遇到控制流向后跳转的指令就称为“回边”<br><strong>在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。</strong>   触发了JIT编译后，在默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成为止（编译工作在后台线程中进行）。当编译工作完成后，下一次调用该方法或代码时，就会使用已编译的版本。</p><hr><p>方法调用计数器触发即时编译的流程如下图：<br><img src="方法调用计数器触发即时编译.png" alt="JIT"></p><p>回边计数器触发即时编译的流程和方法调用计数器流程基本相同，这里不再累述。</p><hr><p><strong>这个世界不会亏欠每一个在孤独中重生的人。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;本文章参考周志明的【深入理解Java虚拟机】&lt;br&gt;代码编译的结果从本地机器码转变成字节码，是存储格式发展的一小步
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM，类加载" scheme="http://yoursite.com/tags/JVM%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解JVM】之六：虚拟机字节码执行引擎</title>
    <link href="http://yoursite.com/2017/10/10/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/</id>
    <published>2017-10-10T02:33:00.000Z</published>
    <updated>2017-12-05T06:49:19.433Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本文章参考周志明的【深入理解Java虚拟机】<br>代码编译的结果从本地机器码转变成字节码，是存储格式发展的一小步，却是编译语言发展的一大步。</p></blockquote><p>在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观(Facade)。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行)两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎，但从外观上看起来，所有的Java虚拟机的执行引擎都是一致的：<strong>输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行过程</strong>，下面将从概念模型的角度来讲解虚拟机的<strong>方法调用和字节码执行</strong>。</p><hr><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p><strong>栈帧(Stack Frame)</strong>是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的<strong>虚拟机栈(Virtual Machine Stack)的栈元素</strong>。栈帧存储了方法的<strong>局部变量表，操作数栈，动态链接，方法返回地址和一些额外的附加信息</strong>等信息。每一个方法从调用开始到执行完成，就对应着一个栈帧在虚拟机栈中从<strong>入栈到出栈</strong>的过程。<br><strong>在编译代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了</strong>，并且写入到了方法表的Code属性中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体虚拟机的实现。<br>在活动线程中，只有位于栈顶的栈帧才是有效的，称为<strong>当前栈帧</strong>，与这个当前栈帧关联的方法称为<strong>当前方法</strong>。<strong>执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作</strong>。<br>下图是栈帧结构的概念模型：<br><img src="栈帧的概念结构.png" alt="执行引擎"></p><h3 id="局部变量变"><a href="#局部变量变" class="headerlink" title="局部变量变"></a>局部变量变</h3><p><strong>局部变量表</strong>是一组变量值存储空间，用于存放<strong>方法参数和方法内部定义的局部变量</strong>。在Java程序编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。<br><strong>局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位</strong>。虚拟机规范中并没有明确指明一个Slot应占的内存空间的大小，只是说到每个Slot都应该存放一个boolean，byte，char，short，int，float，reference和returnAddress这8种类型数据。<br>第七种reference类型表示对一个对象实例的引用，虚拟机规范即没有说明它的长度，也没有明确指定这种应用应有怎样的结构。但一般来说，虚拟机实现至少都应该能<strong>通过这个引用做到两点</strong>：一是从此引用中直接或间接的查找到对象在java堆中的数据存放的起始地址索引，二是此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则无法实现java语言规范中定义的语法约束的约束。<br>对于64位的数据类型，虚拟机会高位对齐的方式为其分配两个连续的Slot空间，java语言规定的64位数据类型只有long和double两种（reference类型可能是32位也可能是64位）。</p><p>虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的Slot数量。如果访问的是32位数据类型的变量，<strong>索引n就代表了使用第n个Slot</strong>，如果是64位数据类型的变量，则说明会同时使用n和n+1两个Slot。对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用任何方式单独访问其中的某一个，Java虚拟机规范中明确要求了如果遇到进行这种操作的字节码序列，虚拟机应该在类加载的校验阶段抛出异常。 </p><p>在方法执行时，虚拟机是使用局部变量表完成参数变量列表的传递过程，如果是<strong>实例方法(非static方法</strong>)，那<strong>么局部变量表中的第0位索引的Slot默认是用于传递方法所属对象实例的引用</strong>，在方法中可以通过关键字<strong>“this”</strong>来访问这个隐含的参数，其余参数则按照参数列表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据<strong>方法体内部定义的变量顺序和作用域来分配其余的Slot</strong>。</p><p><strong>局部变量表中的Slot是可重用的</strong>，方法体中定义的变量，其作用域并不一定会覆盖整个方法，如果当前字节码PC计算器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其它变量使用。</p><blockquote><p>注意：虽然Slot重用可以节省栈帧空间，但是重用栈帧会伴随一些额外的副作用。如，某些情况下，Slot的复用会影响垃圾收集行为。</p></blockquote><p>影响之一：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">byte[] placeholder = new byte[64*1024*1024];</span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc())  <span class="number">68198</span>K-&gt;<span class="number">66120</span>K(<span class="number">125952</span>K), <span class="number">0.0027128</span> secs]</span><br><span class="line">[Full GC (System.gc())  <span class="number">66120</span>K-&gt;<span class="number">66063</span>K(<span class="number">125952</span>K), <span class="number">0.0080045</span> secs]</span><br></pre></td></tr></table></figure><p><strong>从结果中可以看出，在运行System.gc（）后并没有回收64M的内存。主要原因是在执行GC时，变量placeholder还处于作用域之内，虚拟机无法回收。</strong></p><p>修改代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#123;</span><br><span class="line">byte[] placeholder = new byte[64*1024*1024];</span><br><span class="line">&#125;</span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc())  <span class="number">67532</span>K-&gt;<span class="number">66176</span>K(<span class="number">125952</span>K), <span class="number">0.0013205</span> secs]</span><br><span class="line">[Full GC (System.gc())  <span class="number">66176</span>K-&gt;<span class="number">66060</span>K(<span class="number">125952</span>K), <span class="number">0.0067795</span> secs]</span><br></pre></td></tr></table></figure><p><strong>加了花括号之后，placeholder的作用域被限制在花括号之内，从逻辑代码上讲，在执行System.gc（）时，placeholder已经不可能被访问了，但结果发现，还是有64M的内存无法别回收。这又是为什么呢？？？</strong></p><p>下面我们继续修改代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#123;</span><br><span class="line">byte[] placeholder = new byte[64*1024*1024];</span><br><span class="line">&#125;</span><br><span class="line">int a =0;</span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc())  <span class="number">67532</span>K-&gt;<span class="number">66176</span>K(<span class="number">125952</span>K), <span class="number">0.0008704</span> secs]</span><br><span class="line">[Full GC (System.gc())  <span class="number">66176</span>K-&gt;<span class="number">524</span>K(<span class="number">125952</span>K), <span class="number">0.0063974</span> secs]</span><br></pre></td></tr></table></figure><p><strong>结果中我们发现，64M内存被回收了，这中间发生了什么？</strong><br>根本原因：</p><blockquote><p>placeholder被收回要看局部变量表中的slot是否还存有关于placeholder数组对象的引用，第一次修改中，代码虽然已经离开了placeholder的作用域，但在此以后，没有任何对局部变量表的读写操作，placeholder原本所占用的slot没有被其他变量复用，局部变量表仍保持着对它的关联。这种关联没有及时被打断，在绝大部分情况下影响都是很轻微的，但如果遇到一个方法，其后的代码有一些耗时很长的操作，而前面有定义了占用大量内存，实际上已经不会再使用的变量，手动将其设置为null（用来代替a=0，把变量对应的局部变量表Slot清空）便不见得是一个绝对无意义的操作。<br>但是我们不应该对赋null值的操作有过多的依赖，原因是：从编码角度将，<strong>以恰当的变量作用域来控制变量回收时间才是最优雅的解决办法</strong>。</p></blockquote><p>局部变量不像前面介绍的类变量那样存在“准备阶段”。类变量有两次赋初始值的过程，<br><strong>一次在准备阶段，赋予系统初始值。</strong><br><strong>另外一次在初始化阶段，赋予程序员定义的值。</strong><br>因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。<br><strong>但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的。不要认为Java中任何情况下都存在诸如整型变量默认为0，布尔变量默认为false等这样的默认值。</strong></p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈也常被称为操作栈，它是一个<strong>后入先出栈</strong>。同局部变量表一样，操作数栈的最大深度也是编译的时候被写入到方法表的Code属性的max_stacks数据项中。<br>　当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在<strong>方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作</strong>。例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。<br> 　操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类检验阶段的数据流分析中还要再次验证这一点。<strong>以iadd指令为例，这个指令用于整型数加法，这在执行时，最接近栈顶的两个元素的数据类型必须为int型，不能出现一个long和一个float使用iadd命令相加的情况</strong><br>　另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了，如下图所示：<br> <img src="栈之间的数据共享.png" alt="执行引擎"></p><hr><blockquote><p><strong>Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。</strong></p></blockquote><p>下面我们来讲解一下</p><blockquote><p>许多java虚拟机的执行引擎在执行java代码的时候都有<strong>解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择</strong>—-关于编译执行（JIT），在以后的文章中将会讲解。<br><strong>解释执行即对字节码逐条解释执行。</strong></p></blockquote><h3 id="基于栈的解释器执行过程"><a href="#基于栈的解释器执行过程" class="headerlink" title="基于栈的解释器执行过程"></a>基于栈的解释器执行过程</h3><p>本节准备一段java代码，看看虚拟机总实际是如何执行的：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int calc()&#123;</span><br><span class="line">int a=100;</span><br><span class="line">int b=200;</span><br><span class="line">int c =300;</span><br><span class="line">return (a+b)*c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javap命令看看它的字节码指令：<br> <img src="Slot.png" alt="执行引擎"><br>javap 提示这段代码需要深度位2的操作数栈和4个Slot的局部变量空间。我们通过图的方式来观察javap字节码指令执行中的代码，操作数栈和局部变量表的变化：<br><strong>偏移地址为0的指令的情况：</strong><br> <img src="解释器1.png" alt="执行引擎"></p><p> <strong>偏移地址为1的指令的情况：</strong><br> <img src="解释器2.png" alt="执行引擎"></p><p> <strong>偏移地址为11的指令的情况：</strong><br> <img src="解释器3.png" alt="执行引擎"></p><p> <strong>偏移地址为12的指令的情况：</strong><br> <img src="解释器4.png" alt="执行引擎"></p><p> <strong>偏移地址为13的指令的情况：</strong><br> <img src="解释器5.png" alt="执行引擎"></p><p> <strong>偏移地址为14的指令的情况：</strong><br> <img src="解释器6.png" alt="执行引擎"></p><p> <strong>偏移地址为16的指令的情况：</strong><br> <img src="解释器7.png" alt="执行引擎"></p><blockquote><p>上面的执行过程仅仅是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述…….更准确的说，实际情况会和上面描述的概念模型差距非常大，这种差距产生的原因是虚拟机中解析器和即时编译器都会对输入的字节码进行优化。</p></blockquote><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>　</p><blockquote><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(Dynamic<br>Linking)。通过前面类文件结构，我们知道在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为<strong>静态解析</strong>。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为<strong>动态连接</strong>。</p></blockquote><h3 id="方法返回值地址"><a href="#方法返回值地址" class="headerlink" title="方法返回值地址"></a>方法返回值地址</h3><p><strong>当一个方法被执行后，有两种方式退出这个方法。</strong> </p><blockquote><p>第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口(Normal Method Invocation Completion)。<br>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口(Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。</p></blockquote><p>无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说， </p><ul><li>方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。 </li><li>而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。</li></ul><p><strong>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：</strong> </p><blockquote><p>①.恢复上层方法的局部变量表和操作数栈，<br>②.把返回值(如果有的话)压入调用都栈帧的操作数栈中，<br>③.调用PC计数器的值以指向方法调用指令后面的一条指令等。</p></blockquote><h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。<br>所以可以说栈帧分为三部分：<strong>局部变量区、操作数栈和栈帧信息</strong>。</p><hr><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>　<strong>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。</strong><br>Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于直接引用）。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期才能确定目标方法的直接引用。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><blockquote><p><strong>所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用。 在类加载的解析阶段会将一部分符号引用转化为直接引用</strong>，这种解析能成功的前提是：<strong>方法在程序真正运行之前就有一个课确定的调用版本，并且这个方法的调用版本在运行期是不可变的。</strong>也就是说，调用目标在程序代码写好，编译器进行编译时就确定下来，<strong>这类方法的调用称为解析（Resolution）</strong>。</p></blockquote><p>　在java语言中满足“编译期确定，运行期不变”的方法有<strong>静态方法和私有方法两大类</strong>。前者与类型直接关联，后者在外部不可被访问，这两种方式各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合<strong>在类加载阶段进行解析</strong>。<br>　与之相对应的是 ，在Java虚拟机里提供了5条方法调用字节码指令(实际上在JVM jdk 1.6层面只有前面四种方法调用的指令)，分别如下：<br>　1).invokestatic：调用静态方法<br>　2).invokespecial：调用类实例的构造器&lt; init&gt;方法、私有方法和父类方法<br>　3).invokevirtual：调用所有的虚方法<br>　4).invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。<br>　5).invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。 </p><p>通过以上描述，我们可以得出下面两种概念：<br><strong>非虚方法</strong>：只要能被invokestatic和invokespecial指令调用的方法，都可以在类加载的时候把符号引用解析为该方法的直接引用。这里主要是指，私有方法，静态方法，实例构造器，父类方法.（Java中明确说明了final方法是一种非虚方法，虽然被invokevirtual调用，但它无法被覆盖，没有其它版本）<br><strong>虚方法（除去final方法）</strong>，被invokevirtual和invokeinterface调用的则为虚方法，因为在编译期间并不能确定要调用的真正方法，所以称为虚方法。<br>示例如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class StaticResolution &#123;</span><br><span class="line">public static void sayHello()&#123;</span><br><span class="line">System.out.println("hello world");</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">StaticResolution.sayHello();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javap命令查看字节码如下：<br> <img src="invokestatic.png" alt="执行引擎"><br> 我们发现的确是通过invokestatic命令来调用sayHello（）方法的</p><p> 对于被final修饰的方法，虽然final方法是使用invokevirtual指令来调用，但是由于它无法被覆盖，没有其他的版本，所以也无须对方法接受者进行多态选择，又或者说多态选择的结果肯定是唯一的。<strong>在java语言规范中明确说明了final方法是一种非虚方法</strong>。</p><p> <strong>解析调用</strong>一定是个静态的过程，在编译期间就完全确定，在<strong>类装载的解析阶段就会把符号引用转为直接引用</strong>，不会延迟到运行期再去完成。而<strong>分派(Dispatch)调用</strong>则可能是静态的也可能是动态的，根据分派依据的宗量数(本文后面有讲)可分为单分派和多分派。这两类分派方式的两两组合就构成了<strong>静态单分派、静态多分派、动态单分派、动态多分派</strong>4种分派组合情况。</p><hr><h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p><strong>众所周知java面向对象的三个重要特性，封装、继承、多态。而在jvm层面多态的实现由分派完成。分派有静态分派、动态分派。</strong> </p><h4 id="静态分派–代表重载"><a href="#静态分派–代表重载" class="headerlink" title="静态分派–代表重载"></a>静态分派–代表重载</h4><p>在讲解之前，我们先看下面的代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class StaticDispatch &#123;</span><br><span class="line">    static abstract class Human &#123;&#125;</span><br><span class="line"></span><br><span class="line">    static class Man extends Human &#123;&#125;</span><br><span class="line"></span><br><span class="line">    static class Woman extends Human &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello(Human human) &#123;</span><br><span class="line">        System.out.println("hello human");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello(Man man) &#123;</span><br><span class="line">        System.out.println("hello man");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello(Woman woman) &#123;</span><br><span class="line">        System.out.println("hello woman");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Human man = new Man();</span><br><span class="line">        Human woman = new Woman();</span><br><span class="line"></span><br><span class="line">        StaticDispatch sr = new StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello ,guy!</span><br><span class="line">hello ,guy!</span><br></pre></td></tr></table></figure><p><strong>为什么会出现上面的结果呢？？？我们来看看反编译的结果</strong>：<br> <img src="反编译.png" alt="执行引擎"></p><p>解决以上 问题之前，我们先解释两个重要的概念：<br>Human man = new Man();<br>代码里的<strong>Human称为静态类型（或者叫外观类型</strong>）：其变化仅在使用时发生，变量本身的静态类型不会改变，并且最终的静态类型是在编译期可知的。<br>而<strong>Man称为实际类型</strong>：其变化的结果在运行期才可确定，编译器不编译程序时并不知道一个对象的实际类型是什么。</p><blockquote><p>main()方法的两次sayHello方法的调用，在方法接收者已经确定是对象sr的前提下，使用哪个重载版本，<strong>完全取决于传入参数的数量和数据类型</strong>，代码中刻意定义了<strong>两个静态类型相同但实际类型不同的变量</strong>，但虚拟机（准确的说是编译器）在重载时通过参数的静态类型，而不是实际类型作为判定依据。<br> 而且通过以上的反编译结果我们可以发现，<strong>man和woman在编译的时候被强转成了Human类型</strong>，所以导致上面的结果</p></blockquote><p><strong>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派</strong>。 </p><blockquote><p>静态分派典型的应用是方法重载(虚拟机准确的说是编译器，在重载时是通过参数的静态类型而不是实际类型作为判定依据的)<br>静态分派发生在编译阶段(也就是说在编译期是可知的)，因此确定静态分派的动作实际上不是由虚拟机来执行的<br>对于方法参数的匹配也是根据变量的静态类型来确定，在很多情况下根据参数的类型并不能找到”唯一的”方法调用，这个时候的处理方式是找到一个”最合适’的方法。</p></blockquote><p>如下代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class OverLoad &#123;</span><br><span class="line">    public static void sayHello(char arg) &#123;</span><br><span class="line">        System.out.println("hello char");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(int arg) &#123;</span><br><span class="line">        System.out.println("hello int");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(long arg) &#123;</span><br><span class="line">        System.out.println("hello long");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(Character arg) &#123;</span><br><span class="line">        System.out.println("hello Character");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(Serializable arg) &#123;</span><br><span class="line">        System.out.println("hello Serializable");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(Object arg) &#123;</span><br><span class="line">        System.out.println("hello object");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(char ...arg) &#123;</span><br><span class="line">        System.out.println("hello arg...");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        sayHello('a');</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从头注解方法，结果会按顺序输出。<br>注意:1、基本类型是重载按char-&gt;int-&gt;long-&gt;float-&gt;double顺序匹配的。<br>　　2、可变参数的重载优先级是最低的。</p><h4 id="动态分派–代表重写"><a href="#动态分派–代表重写" class="headerlink" title="动态分派–代表重写"></a>动态分派–代表重写</h4><p>想了解动态分派，必须先了解多态另一个体现—重写。如下示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicDispatch &#123;</span><br><span class="line">    static abstract class Human &#123;</span><br><span class="line">        protected abstract void sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Man extends Human &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void sayHello() &#123;</span><br><span class="line">            System.out.println("man say hello");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Woman extends Human &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void sayHello() &#123;</span><br><span class="line">            System.out.println("woman say hello");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Human man = new Man();</span><br><span class="line">        Human woman = new Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line"></span><br><span class="line">        man = new Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man say hello </span><br><span class="line">woman say hello </span><br><span class="line">woman say hello</span><br></pre></td></tr></table></figure><p>显然这里不可能再根据静态类型来决定，因为静态类型同样都是Human的两个变量man和woman在调用sayHello()方法时执行了不同的行为，并且变量在两次调用中执行了不同的方法。<br>导致这个现象的原因：是这两个变量的实际类型不同。<br>由于invokevirtual指令执行的第一步就是在运行期间确定接收者的实际类型，所以两次调用的invokevirtual指令把常量池中的类方法<strong>符号引用解析到了不同的直接引用</strong>上，这个过程就是Java语言方法重写的本质。这种<strong>在运行期间根据实际类型确定方法执行版本的过程称为动态分派</strong>。<br><strong>动态分派的一个重要体现就是方法的重写，虽然父类引用可以指向子类对象，但是动态分派的方法调用是在运行时根据对象的实际类型去确认的。</strong></p><h4 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h4><p><strong>方法的接收者与方法的参数称为方法的宗量。 单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。</strong></p><p>示例如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Dispatch &#123;</span><br><span class="line">static class QQ&#123;&#125;</span><br><span class="line">static class _360&#123;&#125;</span><br><span class="line">public static class Father&#123;</span><br><span class="line">public void hardChoice(QQ arg)&#123;</span><br><span class="line">System.out.println("father choose 11");</span><br><span class="line">&#125;</span><br><span class="line">public void hardChoice(_360 arg)&#123;</span><br><span class="line">System.out.println("father choose 360");</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static class Son extends Father&#123;</span><br><span class="line"><span class="comment">//重写父类的方法</span></span><br><span class="line">@Override</span><br><span class="line">public void hardChoice(QQ arg)&#123;</span><br><span class="line">System.out.println("son choose qq");</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void hardChoice(_360 arg)&#123;</span><br><span class="line">System.out.println("son choose 360");</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Father father = new Father();</span><br><span class="line">Father son = new Son();</span><br><span class="line">father.hardChoice(new _360());</span><br><span class="line">son.hardChoice(new QQ());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">father choose <span class="number">360</span> </span><br><span class="line">son choose qq</span><br></pre></td></tr></table></figure><p>看编译阶段编译器的选择过程，也就是静态分派的过程。这时选择目标方法的依据有两点：<strong>一是静态类型是Father还是Son，二是方法参数是QQ还是360。因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。</strong><br>再看运行阶段虚拟机的选择，也就是动态分派的过程。在执行“son.hardChoose(new QQ())”这句代码时（准确的说是在执行这句代码所对应的invokevirtual指令），由于编译期已经决定目标方法的签名必须为hardChoice(QQ)，虚拟机不会关心传递过来的参数”QQ”是什么，因为这时参数的静态类型、实际类型都对方的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有此方法的接收者的实际类型是Father还是Son。因为<strong>只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型</strong>。</p><p><strong>Java语言是一门静态多分派，动态单分派的语言</strong>。</p><h4 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h4><p>虚拟机在实际实现动态分派是基于性能考虑的。jvm在实现层面提供了一个叫做虚方法表的索引来代替元数据查找以提高性能，下面是书中的一张虚方法表结构图：<br> <img src="方法表结构.png" alt="执行引擎"></p><blockquote><p><strong>虚方法表中</strong>存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果重写了这个方法，子类方法表中的地址将会替换指向子类实现版本的入口地址。<br>Father是父类son是子类，并且子类重写了父类的连个方法，hardChoice(QQ),hardChoice(_360)，因此子类中的这两个方法指向了Son的类型数据，而这两个类都继承自Object且没重写它的任何方法，因此都指向了Object的类型数据。<br>方法表一般在类加载的链接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。</p></blockquote><hr><blockquote><p><strong><em>你敢不敢问自己到底要去哪里，<br>背负着恐惧寻找的终点，<br>非要是末路吗，<br>你能听到吗，<br>你还能听到吗，<br>你还有勇气直面你的恐惧吗？</em></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文章参考周志明的【深入理解Java虚拟机】&lt;br&gt;代码编译的结果从本地机器码转变成字节码，是存储格式发
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM，类加载" scheme="http://yoursite.com/tags/JVM%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解JVM】之五：虚拟机的类加载机制</title>
    <link href="http://yoursite.com/2017/10/04/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/10/04/虚拟机的类加载机制/</id>
    <published>2017-10-04T02:33:00.000Z</published>
    <updated>2017-12-05T06:49:06.257Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>本文章参考周志明的【深入理解Java虚拟机】<br>代码编译的结果从本地机器码转变成字节码，是存储格式发展的一小步，却是编译语言发展的一大步。</p></blockquote><p>虚拟机吧描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。<br>在java语言中，类型的加载，连接和初始化过程都是在程序运行期间完成的。</p><blockquote><p>注意： 以下所讲的Class文件并非特指某个存在于具体磁盘中的文件，应当是一串二进制的字节流。</p></blockquote><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>从类被加载到虚拟机内存中开始，到卸载出内存为止，类的生命周期包括加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段 。如下图：<br><img src="连接.png" alt="类加载"><br>　其中<strong>验证、准备和解析三部分称为连接</strong>，在Java语言中，类型的加载和连接过程都是在程序运行期间完成的（Java可以<strong>动态扩展的语言特性</strong>就是依赖运行期动态加载、动态连接这个特点实现的），这样会在类加载时稍微增加一些性能开销，但是却为Java应用程序提供高度的灵活性 。<br> <strong>加载、验证、准备、初始化和卸载</strong>这5个阶段的顺序是<strong>固定的</strong>（即：加载阶段必须在验证阶段开始之前开始，验证阶段必须在准备阶段开始之前开始等。这些阶段都是互相交叉地混合式进行的，通常会在一个阶段的执行过程中调用或激活另一个阶段），解析阶段则不一定，在某些情况下，解析阶段有可能在初始化阶段结束后开始，以支持Java的动态绑定。<br> 什么情况下需要开始类加载过程的加载阶段？<br> –Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><ol><li>遇到new（使用new关键字实例化对象）、getstatic（获取一个类的静态字段，final修饰符修饰的静态字段除外）、putstatic（设置一个类的静态字段，final修饰符修饰的静态字段除外）和invokestatic（调用一个类的静态方法）这4条字节码指令时，如果类还没有初始化，则必须首先对其初始化 </li><li>使用java.lang.reflect包中的方法对类进行反射调用时，如果类还没有初始化，则必须首先对其初始化 </li><li>当初始化一个类时，如果其父类还没有初始化，则必须首先初始化其父类 </li><li>当虚拟机启动时，需要指定一个主类（main方法所在的类），虚拟机会首选初始化这个主类 </li><li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li></ol><p>对于这5中会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“<strong>有且只有</strong>”，这5中场景中的行为称为对一个类进行<strong>主动引用</strong>。除此之外的方式都不会触发初始化，称为<strong>被动引用</strong>。<br><strong>被动引用的示例：</strong><br><strong>1.通过子类引用父类的静态字段，不会导致子类初始化</strong>。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class SuperClasses &#123;</span><br><span class="line">    public static int value = 123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println("SuperClasses init!");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SubClass extends SuperClasses &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println("SubClass init!");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class NotInitialization &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br>SuperClasses init!<br>123<br><strong>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只有父类会被初始化，子类不会被初始化（子类的调用方式不符合5种直接引用中的任何一种）。</strong><br>至于是否会触发子类的加载和验证，虚拟机规范没有明确规定，视虚拟机具体实现而定，对Hotspot虚拟机，可通过-XX:+TraceClassLoading参数看到此操作会导致子类的加载<br><img src="load.png" alt="类加载"><br>从图中我们可以看出，子类被加载，却没有初始化。<br><strong>2.通过数组定义的引用类，不会触发此类的初始化</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class NotInitialization &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        SuperClasses[] temp = new SuperClasses[10];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为空<br><strong>3.常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，所以不会触发定义常量的类的初始化</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ConstClass &#123;</span><br><span class="line">    public static final int A = 1;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println("ConstClass init!");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Test &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(ConstClass.A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br>1</p><p>在编译节阶段已将常量的值1存储到Test类的常量池中，对常量的Constant.A的引用实际上被转化为Test类对自身常量池的引用，这2个类在编译为Class文件后就没有任何关系了</p><blockquote><p><strong>注意：接口的加载过程与类加载过程不些不同</strong>，接口也有初始化的过程，虽然接口中不能使用静态代码块，但编译器仍然会为接口生成“<clinit>（）”类构造器，用于初始化接口中所定义的成员变量。<br><strong>接口与类真正的区别</strong>是前面讲得5种“有且仅有”需要开始初始化中的第3中：  当一个类初始化的时候，要求父类全部都已经初始化过了，但是一个接口在初始化时，不要求父类接口全部都完成初始化，只有在真正使用到接口（如使用到父类中定义的常量）时才会初始化。</clinit></p></blockquote><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>详解类加载的全过程，也就是加载、验证、准备、解析和初始化这5个阶段所执行的具体动作</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p><strong>1.通过“类全名”来获取定义此类的二进制字节流</strong><br>虚拟机规范对于“通过“类全名”来获取定义此类的二进制字节流”并没有指明二进制流必须要从一个本地class文件中获取，准确地说是根本没有指明要从哪里获取及怎样获取。例如：<br>　①.从Zip包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。<br>　②.从网络获取，常见应用Applet。<br>　③.运行时计算生成，这种场景使用的最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用ProxyGenerator.generateProxyClass来为特定接口生成$Prxoy的代理类的二进制字节流。<br>　④.由其他格式文件生成，典型场景：JSP应用<br>　⑤.从数据库中读取，这种场景相对少见，有些中间件服务器(如SAP Netweaver)可以选择把程序安装到数据库中来完成程序代码在集群间的分发<br> …………………….<br><strong>2.将字节流所代表的静态存储结构转换为方法区的运行时数据结构</strong><br>虚拟机规范并未规定方法区存储数据的具体数据结构，数据存储格式由虚拟机实现自行定义。<br><strong>3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口</strong><br>加载阶段完成后，虚拟机外部的<strong>二进制字节流</strong>就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式有虚拟机实现自行定义，虚拟机并未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较 特殊，它虽然是个对象，但在存放在方法区里!!!），这个对象作为程序访问方法区中的这些类型数据的外部接口。<br>加载阶段与链接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成，链接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于链接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。<br>相对于类加载过程的其他阶段，加载阶段(准备地说，是加载阶段中获取类的二进制字节流的动作)是开发期可控性最强的阶段，因为加载阶段可以使用系统提供的类加载器(ClassLoader)来完成，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。</p><hr><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>说到加载，不得不提到类加载器，下面就具体讲述下类加载器。<br>虚拟机设计者把类加载阶段中的“<strong>通过一个类的全限定名来获取描述此类的二进制字节流</strong>”这个动作放到java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块成为“类加载器”。<br>  类加载器虽然只用于实现类的<strong>加载动作</strong>，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它<strong>的类加载器和这个类本身</strong>一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们<strong>的类加载器不同</strong>，那这<strong>两个类就必定不相等</strong>。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。</p><h5 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h5><p><strong>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：</strong></p><ul><li><strong>启动类加载器</strong>：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分。</li><li><p><strong>所有其他的类加载器</strong>：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p><p><strong>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</strong></p></li><li><strong>启动类加载器：</strong>Bootstrap ClassLoader，跟上面相同。它负责加载存放在JDK\jre\lib(JDK代表<strong>JDK的安装目录，下同)下</strong>，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。<strong>启动类加载器是无法被Java程序直接引用的。</strong></li><li><strong>扩展类加载器</strong>：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），<strong>开发者可以直接使用扩展类加载器。</strong></li><li><strong>应用程序类加载器</strong>：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，<strong>开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</strong><br><strong>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。</strong>这些类加载器之间的关系一般如下图所示：<br><img src="ClassLoader.png" alt="类加载"><br>上图的这种层次关系称为<strong>类加载器的双亲委派模型</strong>。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。<br><strong>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</strong><br>使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是Java类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系，这对于<strong>保证Java程序的稳定运作很重要</strong>。例如，类java.lang.Object类存放在JDK\jre\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给<strong>启动类加载器进行加载</strong>，这边保证了Object类在程序中的<strong>各种类加载器中都是同一个类</strong>。</li></ul><hr><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：<strong>文件格式的验证、元数据的验证、字节码验证和符号引用验证。</strong></p><ul><li><strong>件格式的验证</strong>：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。</li><li><strong>元数据验证</strong>：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。</li><li><strong>字节码验证</strong>：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</li><li><strong>符号引用验证</strong>：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</li></ul><hr><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p> 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要<strong>注意</strong>：<br>    1、这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。<br>    2、这里所说的<strong>初始值</strong>“通常情况”下是数据类型的零值。假设一个类变量定义为:<br>                                                            public static int value = 12;<br>    那么变量value在准备阶段过后的初始值为<strong>0而不是12</strong>，因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器&lt; clinit&gt;()方法之中，所以把<strong>value赋值为12的动作将在初始化阶段</strong>才会被执行。<br> <strong>这里还需要注意如下几点：</strong></p><ul><li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li><li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li><li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。<br>下图列出了所有基本数据类型的零值：</li></ul><table><thead><tr><th>数据类型</th><th>零值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>short</td><td>（short）0</td></tr><tr><td>char</td><td>‘\u0000’</td></tr><tr><td>byte</td><td>(byte)0</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d</td></tr><tr><td>reference</td><td>null</td></tr></tbody></table><p>3、初始值“通常情况”下是零值，但在“特殊情况”下：如果类字段的字段属性表中包含<strong>ConstantValue属性</strong>，那在准备阶段变量就会被初始化为ConstantValue属性所指定的值，即如果a变量定义变为<strong>public final static int a = 1</strong>;，编译时javac会为a生成ConstantValue属性，准备阶段虚拟机就会根据ConstantValue的设置将a的值置为123。<br><strong>我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中。</strong></p><hr><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><strong>解析阶段是虚拟机将常量池内的符号引用特换成直接应用的过程</strong>。<br>a、<strong>符号引用(Symbolic References)</strong>：符号引用是一组符号来描述所引用的目标对象，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标对象并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因此符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。<br>b、<strong>直接引用(Direct References)</strong>：直接引用可以是直接指向目标对象的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机内存布局实现相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。<br>问：<strong>到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之</strong>后）？<br>答：<strong>虚拟机规范并没有规定解析阶段发生的具体时间，只要求了在执行anewarry、checkcast等16个用于操作符号引用的字节码指令之前，先对它们使用的符号引用进行解析，所以虚拟机实现会根据需要来判断</strong></p><p>对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行<strong>缓存</strong>（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。<br>    解析动作主要针<strong>对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</strong>七类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_InvokeDynamic_info七种常量类型。但是下面我们<strong>只讨论前四种</strong>。<br> 1、<strong>类或接口的解析</strong>：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。<br> 2、<strong>字段解析</strong>：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下图所示<br> <img src="解析.png" alt="类加载"></p><p> <strong>最后需要注意</strong>：理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。<strong>如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现</strong>，编译器可能会拒绝编译。如下代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class StaticTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(Child.m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Super &#123;</span><br><span class="line">public static int m = 11;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Father &#123;</span><br><span class="line">public static int m = 33;</span><br><span class="line">static &#123;</span><br><span class="line">System.out.println("执行了父类静态语句块");</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Father implements Super &#123;</span><br><span class="line">static &#123;</span><br><span class="line">System.out.println("执行了子类静态语句块");</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果编译不通过，会报如下错误：<br><img src="编译不通过.png" alt="类加载"></p><p>  3、类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。<br>  4、接口方法解析：与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类初始化阶段是“类加载过程”中最后一步，在之前的阶段，除了加载阶段用户应用程序可以通过自定义类加载器参与，其它阶段完全由虚拟机主导和控制，<strong>直到初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）</strong><br>在准备阶段，变量已经赋过一次初始值，在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其它资源，简单说，初始化阶段即虚拟机执行类构造器&lt; clinit&gt;()方法的过程，下面详细介绍下&lt; clinit&gt;方法：<br>①.&lt; clinit&gt;由编译器自动收集类中所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定，特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。示例如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class JavaTest&#123;</span><br><span class="line">static &#123;</span><br><span class="line">i = 2;                 //赋值而已编译通过</span><br><span class="line">System.out.println(i);    // 这句编译时会报“非法向前引用”</span><br><span class="line">&#125;</span><br><span class="line">static int i = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ②.类构造器&lt; clinit&gt;()方法与类的构造函数(实例构造函数&lt; init&gt;()方法)不同，它不需要显式调用父类构造，虚拟机会保证在子类&lt; clinit&gt;()方法执行之前，父类的&lt; clinit&gt;()方法已经执行完毕（<strong>这也意味着父类中定义的静态语句块要优于子类的变量赋值操作</strong>）。因此<strong>在虚拟机中的第一个执行的&lt; clinit&gt;()方法的类肯定是java.lang.Object</strong>。<br>③.&lt; clinit&gt;()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句，也没有变量赋值的操作，那么编译器可以不为这个类生成&lt; clinit&gt;()方法。<br>④.接口中不能使用静态语句块，，但是可以有<strong>类变量的赋值操作</strong>，故编译器也会对接口生成&lt; clinit&gt;()方法。但接口与类不同的是，执行接口的&lt; clinit&gt;()方法不需要先执行父接口的&lt; clinit&gt;()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt; clinit&gt;()方法。<br>⑤.虚拟机会保证一个类的&lt; clinit&gt;()方法在多线程环境中被正确加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程执行这个类的&lt; clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt; clinit&gt;()方法完毕。如果一个类的&lt; clinit&gt;()方法中有耗时很长的操作，那就可能造成多个进程阻塞。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLoopClass &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        <span class="keyword">if</span> (true) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + " init DeadLoopClass");</span><br><span class="line">            while (true)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Runnable script = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + " start");</span><br><span class="line">                DeadLoopClass dlc = new DeadLoopClass();</span><br><span class="line">                System.out.println(Thread.currentThread() + " run over");</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(script);</span><br><span class="line">        Thread t2 = new Thread(script);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>Thread[Thread-0,5,main]start<br>Thread[Thread-0,5,main]start<br>Thread[Thread-0,5,main]init  DeadLoopClass<br>一条线程在死循环以模拟长时间操作，另外的线程在阻塞等待。</p><hr><blockquote><p>你敢不敢问自己到底要去哪里，<br>背负着恐惧寻找的终点，<br>非要是末路吗，<br>你能听到吗，<br>你还能听到吗，<br>你还有勇气直面你的恐惧吗？</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;本文章参考周志明的【深入理解Java虚拟机】&lt;br&gt;代码编译的结果从本地机器码转变成字节码，是存储格式发展的一小步
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM，类加载" scheme="http://yoursite.com/tags/JVM%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>java的浅复制问题</title>
    <link href="http://yoursite.com/2017/10/03/java%E6%B5%85%E5%A4%8D%E5%88%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/10/03/java浅复制问题/</id>
    <published>2017-10-03T02:33:00.000Z</published>
    <updated>2017-10-03T04:31:25.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨天逛知乎看到一个java浅复制的问题，看到很多的解释我并不是很理解，所以今天特意写出来，讨论一下。</p><blockquote><p><strong>问题链接地址：（看一下链接的内容，然后下面的内容都是依据链接内容进行的分析）</strong><br><a href="https://www.zhihu.com/question/66099841/answer/238247431" target="_blank" rel="noopener">https://www.zhihu.com/question/66099841/answer/238247431</a></p></blockquote><h2 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是浅复制呢？</p><blockquote><p>浅复制（shallow copy）只是复制了对象的引用，而不是对象本身的拷贝。</p></blockquote><p>如果你看到上面链接的内容，你应该对 “胖胖” 这位大V的回答有了一定的了解，对他回答的内容我表示基本赞同，但是我却又一些疑问。</p><ol><li>Integer定义的时候，数值在小于127的时候，里面的值都是从数组缓存中取出的（如果对着有疑问请看  <a href="http://fxkoutlook.cn/2017/09/27/Integer%E7%94%A8==%E6%AF%94%E8%BE%83%E6%97%B6127%E7%9B%B8%E7%AD%89128%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%8E%9F%E5%9B%A0/" target="_blank" rel="noopener">Integer= =比较时127相等128不相等的原因</a> ），也就是说同一个数应该是同一个对象。假如我们定义两个数数组a1，和a2，进行数组值的替换，代码如下：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a1 = new Integer[]&#123;12,23,34,45&#125;;</span><br><span class="line">Integer[] a2 = new Integer[4];</span><br><span class="line">System.arraycopy(a1, 0, a2, 0, a1.length); //使用System静态方法进行复制（各参数含义请查API）</span><br><span class="line">System.out.println("a1="+Arrays.toString(a1));</span><br><span class="line">System.out.println("a2="+Arrays.toString(a2));</span><br><span class="line">a2[1] = 3;</span><br><span class="line">System.out.println("a1="+Arrays.toString(a1));</span><br><span class="line">System.out.println("a2="+Arrays.toString(a2));</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a1=[<span class="number">12</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">45</span>]</span><br><span class="line">a2=[<span class="number">12</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">45</span>]</span><br><span class="line"></span><br><span class="line">a1=[<span class="number">12</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">45</span>]</span><br><span class="line">a2=[<span class="number">12</span>, <span class="number">3</span>, <span class="number">34</span>, <span class="number">45</span>]</span><br></pre></td></tr></table></figure><p><strong>从结果可以看出，在复制之后，a1，a2里的数据的值，不在是同一个对象，因为如果是浅复制的话，那么a1的值应该也会改变。</strong></p><p>通过以上的疑问，我产生了一下的怀疑：<br>1、是不是复制以后，两个数组里的值不再是同一个对象，然后改变一个数组的值后，另一个不在改变。<br>但是我看到 “胖胖” 大V最后的回答，我给予了否定，我们来看看他的代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个Node对象</span></span><br><span class="line">public class Node &#123;</span><br><span class="line">private int node;</span><br><span class="line">public Node(int node) &#123;</span><br><span class="line">this.node = node;</span><br><span class="line">&#125;</span><br><span class="line">public int getNode() &#123;</span><br><span class="line">return node;</span><br><span class="line">&#125;</span><br><span class="line">public void setNode(int node) &#123;</span><br><span class="line">this.node = node;</span><br><span class="line">&#125;</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return String.valueOf(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Node[] arr1 = new Node[10];</span><br><span class="line">Node[] arr2 = new Node[10];</span><br><span class="line">Arrays.fill(arr1, new Node(1));//将指定的 Node值分配给指定 Node 型数组的每个元素</span><br><span class="line">System.arraycopy(arr1, 0, arr2, 0, arr1.length);</span><br><span class="line">System.out.println("arr1="+Arrays.toString(arr1));</span><br><span class="line">System.out.println("arr2="+Arrays.toString(arr2));</span><br><span class="line">arr1[1].setNode(2);</span><br><span class="line">System.out.println("arr1="+Arrays.toString(arr1));</span><br><span class="line">System.out.println("arr2="+Arrays.toString(arr2));</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr1=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">arr2=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">arr1=[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">arr2=[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>通过上面的测试例子，我们可以说Node在arr1和arr2里的值指向了同一个引用。修改其中的一个我们可以改变另一个数组的值。所以我的以上的怀疑并不正确。</strong><br><strong>我也看过两个数组的 hashcode，虽然并不相等，但是这里不相等是因为，定义数组是两个数组对象，根据数组在堆中的存储，并且数组的值可以指向其他的引用，所以并不能说明任何问题。</strong></p><p>那到底是什么问题呢，其实我也不知道，如果有朋友知道这个问题的答案可以帮我解答一下吗？<br>下面附上我的邮箱：</p><blockquote><p>Gmail邮箱：<a href="mailto:foutlook6@gmail.com" target="_blank" rel="noopener">foutlook6@gmail.com</a><br>QQ邮箱：<a href="mailto:foutlook@qq.com" target="_blank" rel="noopener">foutlook@qq.com</a><br>如果你看到这篇文章，并且知道答案，如果你愿意把你的答案分享出去，请发送邮件或者加我微信，给与我解答，非常感谢！</p></blockquote><hr><p>刚刚写完文章就收到了”胖胖”大V的回复，他给我一个链接，我看了以后懵懵懂懂，链接如下：</p><blockquote><p><a href="https://www.zhihu.com/question/31203609" target="_blank" rel="noopener">java到底是值传递还是引用传递？</a><br>看了链接，<strong>我觉得问题应该出在=赋值操作上</strong>，我也没法解释了，有点迷茫。<br>如果谁有更好的解释，可以回复我，感激不尽。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;昨天逛知乎看到一个java浅复制的问题，看到很多的解释我并不是很理解
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="JavaSE，shallow copy" scheme="http://yoursite.com/tags/JavaSE%EF%BC%8Cshallow-copy/"/>
    
  </entry>
  
  <entry>
    <title>如何理解 String 类型值的不可变？</title>
    <link href="http://yoursite.com/2017/09/27/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%20String%20%E7%B1%BB%E5%9E%8B%E5%80%BC%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <id>http://yoursite.com/2017/09/27/如何理解 String 类型值的不可变/</id>
    <published>2017-09-27T14:09:00.000Z</published>
    <updated>2018-07-09T04:19:15.268Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>我们都知道String类的对象是一个典型的不可变对象，我们调用它的subString（），replace（），concat（）这些方法都不会影响它原来的值，只会返回一个新构建的对象。<br>如下图，给一个已有字符串”abc”第二次赋值成”abcde”，不是在原内存地址上修改数据，而是重新指向一个新对象，新地址。<br><img src="String1.png" alt="String"></p><h3 id="String为什么不可变？"><a href="#String为什么不可变？" class="headerlink" title="String为什么不可变？"></a>String为什么不可变？</h3><p>翻开源码如下：<br><img src="Stringchar.png" alt="String"><br>首先String类是用final关键字修饰，这说明String不可继承。再看下面，String类的主力成员字段value是个char[ ]数组，而且是用final修饰的。final修饰的字段创建以后就不可改变。因为虽然value是不可变，也只是value这个引用地址不可变。挡不住Array数组是可变的事实。<br>数组的本体结构在heap堆。String类里的value用final修饰，只是说stack里的这个叫value的引用地址不可变。没有说堆里array本身数据不可变。<br>如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final int[] value=&#123;1,2,3&#125;</span><br><span class="line">int[] another=&#123;4,5,6&#125;;</span><br><span class="line">value=another;    //编译器报错，final不可变</span><br></pre></td></tr></table></figure><p>value用final修饰，编译器不允许我把value指向堆区另一个地址。但如果我直接对数组元素动手，情况就会发生变化。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final int[] value=&#123;1,2,3&#125;;</span><br><span class="line">value[2]=100;  //这时候数组里已经是&#123;1,2,100&#125;</span><br></pre></td></tr></table></figure><p>所以为了保证String不可变，String类中把char类型的数组设置成private的，外界不允许访问，而且设计者把整个String类设计成final禁止继承，避免了String被改变。所以String是不可变的关键都在底层的实现，而不是一个final。</p><h3 id="String-不可变的好处"><a href="#String-不可变的好处" class="headerlink" title="String 不可变的好处"></a>String 不可变的好处</h3><p>1、不可变的好处，就要牵扯到字符串常量池了，只有当字符串是不可变的，字符串池才有可能实现。<strong>字符串池的实现可以在运行时节约很多heap空间</strong>，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么String interning将不能实现(译者注：String interning是指对不同的字符串仅仅只保存一个，即不会保存多个相同的字符串。)，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = "aaddcc";</span><br><span class="line">String s2 = "aaddcc";</span><br></pre></td></tr></table></figure><p><img src="String2.png" alt="String"><br>这样在大量使用字符串的情况下，可以节省内存空间，提高效率。但之所以能实现这个特性，String的不可变性是最基本的一个必要条件。要是内存里字符串内容能改来改去，这么做就完全没有意义了。</p><p>2、因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。<br>3、因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。<br>4、如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。</p><p>除了上面提到的String之外，常用的还有枚举类，以及java.lang.Number的部分子类，如Long和Double等数值包装类，BigInteger和BigDecimal等大数据类型。</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><p><strong>String的特性》</strong><br>1、String类是final的，不可被继承。<br>2、String类是的本质是字符数组char[], 并且其值不可改变。<br>3、String类对象有个特殊的创建的方式，就是直接指定比如String x = “abc”，”abc”就表示一个字符串对象。而x是”abc”对象的地址，也叫做”abc”对象的引用。<br>4、String对象可以通过“+”串联。串联后会生成新的字符串。<br>5、Java运行时会维护一个String Pool（String池），JavaDoc翻译很模糊“字符串缓冲区”。String池用来存放运行时中产生的各种字符串，并且池中的字符串的内容不重复。而一般对象不存在这个缓冲池，并且创建的对象仅仅存在于方法的堆栈区。<br>6、创建字符串的方式很多，归纳起来有三类：<br>其一，使用new关键字创建字符串，比如String s1 = new String(“abc”);<br>其二，直接指定。比如String s2 = “abc”;<br>其三，使用串联生成新的字符串。比如String s3 = “ab” + “c”;</p><p><strong>《String对象的创建》</strong><br>String对象的创建也有很多门道，关键是要明白其原理。</p><p>原理1：当使用任何方式来创建一个字符串对象s=X时，Java运行时（运行中JVM）会拿着这个X在String池中找是否存在内容相同的字符串对象，如果不存在，则在池中创建一个字符串s，否则，不在池中添加。<br>原理2：Java中，只要使用new关键字来创建对象，则一定会（在堆区或栈区）创建一个新的对象。<br>原理3：使用直接指定或者使用纯字符串串联来创建String对象，则仅仅会检查维护String池中的字符串，池中没有就在池中创建一个，有则罢了！但绝不会在堆栈区再去创建该String对象。<br>原理4：使用包含变量的表达式来创建String对象，则不仅会检查维护String池，而且还会在堆栈区创建一个String对象。</p><p><strong>《不可变类》</strong><br>JAVA为了提高效率，对String类型进行了特别的处理－－－为string类型提供了串池<br>定义一个string类型的变量有两种方式：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="built_in">name</span>= <span class="string">"tom "</span>;(String <span class="built_in">name</span>=<span class="string">"t"</span>+<span class="string">"o"</span>+<span class="string">"m"</span>的效果和此处是相同的)</span><br><span class="line"><span class="built_in">string</span> <span class="built_in">name</span> =new <span class="built_in">string</span>( <span class="string">"tom "</span>)</span><br></pre></td></tr></table></figure></p><p>如果你使用了第一种方式，那么当你在声明一个内容也是 “tom “的string时，它将使用串池里原来的那个内存，而不会重新分配内存，也就是说，string saname= “tom “,将会指向同一块内存。而如果用第二种方式，不管串池里有没有”tom”，它都会在堆中重新分配一块内存，定义一个新的对象。<br>另外关于string类型是不可改变的问题： string类型是不可改变的，也就是说，当你想改变一个string对象的时候，比如name= “madding “ 那么虚拟机不会改变原来的对象，而是生成一个新的string对象，然后让name去指向它，如果原来的那个 “tom “没有任何对象去引用它，虚拟机的垃圾回收机制将接收它。<br>最后，关于定义String的堆栈问题：String s =new String()分析堆与栈,是先定义S,还是先new string()？？？</p><p><strong>1</strong><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="keyword">str1 </span>= <span class="string">"abc"</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">System.out.println</span>(<span class="keyword">str1 </span>== <span class="string">"abc"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>步骤：<br>1) 栈中开辟一块空间存放引用str1；<br>2) String池中开辟一块空间，存放String常量”abc”；<br>3) 引用str1指向池中String常量”abc”；<br>4) str1所指代的地址即常量”abc”所在地址，输出为true；</p><p><strong>2</strong><br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(str2 == <span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure></p><p>步骤：<br>1) 栈中开辟一块空间存放引用str2；<br>2) 堆中开辟一块空间存放一个新建的String对象”abc”；<br>3) 引用str2指向堆中的新建的String对象”abc”；<br>4) str2所指代的对象地址为堆中地址，而常量”abc”地址在池中，输出为false；</p><p><strong>3</strong><br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str3 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(str3 == str2);</span><br></pre></td></tr></table></figure></p><p>步骤：<br>1) 栈中开辟一块空间存放引用str3；<br>2) 堆中开辟一块新空间存放另外一个(不同于str2所指)新建的String对象；<br>3) 引用str3指向另外新建的那个String对象 ；<br>4) str3和str2指向堆中不同的String对象，地址也不相同，输出为false；</p><p><strong>4</strong><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="keyword">str4 </span>= <span class="string">"a"</span> + <span class="string">"b"</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">System.out.println</span>(<span class="keyword">str4 </span>== <span class="string">"ab"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>步骤：<br>1) 栈中开辟一块空间存放引用str4；<br>2) 根据编译器合并已知量的优化功能，池中开辟一块空间，存放合并后的String常量”ab”；<br>3) 引用str4指向池中常量”ab”；<br>4) str4所指即池中常量”ab”，输出为true；</p><p><strong>5</strong><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">String</span> s = <span class="string">"a"</span>; <span class="comment">//注意:这里s用final修饰，相当于一个常量</span></span><br><span class="line"><span class="keyword">String</span> str5 = s + <span class="string">"b"</span>;</span><br><span class="line">System.out.<span class="built_in">println</span>(str5 == <span class="string">"ab"</span>);</span><br></pre></td></tr></table></figure></p><p>步骤：<br>同四</p><p><strong>6</strong><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="built_in">s1</span> = <span class="string">"a"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span><span class="built_in">s2</span> = <span class="string">"b"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span><span class="keyword">str6 </span>= <span class="built_in">s1</span> + <span class="built_in">s2</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">System.out.println</span>(<span class="keyword">str6 </span>== <span class="string">"ab"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>步骤：<br>1) 栈中开辟一块中间存放引用s1，s1指向池中String常量”a”，<br>2) 栈中开辟一块中间存放引用s2，s2指向池中String常量”b”，<br>3) 栈中开辟一块中间存放引用str5，<br>4) s1 + s2通过StringBuilder的最后一步toString()方法还原一个新的String对象”ab”，因此堆中开辟一块空间存放此对象，<br>5) 引用str6指向堆中(s1 + s2)所还原的新String对象，<br>6) str6指向的对象在堆中，而常量”ab”在池中，输出为false</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h3&gt;&lt;p&gt;我们都知道String类的对象是一个典型的不可变对象，我们调用它的subString（），replace（），concat（）这些方法都不会
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java，String" scheme="http://yoursite.com/tags/Java%EF%BC%8CString/"/>
    
  </entry>
  
  <entry>
    <title>Integer用==比较时127相等128不相等的原因</title>
    <link href="http://yoursite.com/2017/09/27/Integer%E7%94%A8==%E6%AF%94%E8%BE%83%E6%97%B6127%E7%9B%B8%E7%AD%89128%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <id>http://yoursite.com/2017/09/27/Integer用==比较时127相等128不相等的原因/</id>
    <published>2017-09-27T02:33:00.000Z</published>
    <updated>2018-07-09T04:13:01.421Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>关于以上问题，我们首先先看如下代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">         Integer a =1;</span><br><span class="line">         Integer b =2;</span><br><span class="line">         Integer c =3;</span><br><span class="line">         Integer d =3;</span><br><span class="line">         Integer e =321;</span><br><span class="line">         Integer f =321;</span><br><span class="line">         Long g = 3L;</span><br><span class="line">         System.out.println(c==d);            //true</span><br><span class="line">         System.out.println(e == f);         </span><br><span class="line">         System.out.println(c == (a+b));      //true</span><br><span class="line">         System.out.println(c.equals(a+b));   //true</span><br><span class="line">         System.out.println(g==(a+b));        //true</span><br><span class="line">         System.out.println(g.equals(a+b));   //false</span><br></pre></td></tr></table></figure><p>运行的结果为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>咱们来看看反编译的代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">         Integer a = Integer.valueOf(1);</span><br><span class="line">         Integer b = Integer.valueOf(2);</span><br><span class="line">         Integer c = Integer.valueOf(3);</span><br><span class="line">         Integer d = Integer.valueOf(3);</span><br><span class="line">         Integer e = Integer.valueOf(321);</span><br><span class="line">         Integer f = Integer.valueOf(321);</span><br><span class="line">         Long g = Long.valueOf(3L);</span><br><span class="line">         System.out.println(c == d);</span><br><span class="line">         System.out.println(e == f);</span><br><span class="line">         System.out.println(c.intValue() == a.intValue() + b.intValue());</span><br><span class="line">          System.out.println(c.equals(Integer.valueOf(a.intValue() + b.intValue())));</span><br><span class="line">         System.out.println(g.longValue() == (long) (a.intValue() + b.intValue()));</span><br><span class="line">          System.out.println(g.equals(Integer.valueOf(a.intValue() + b.intValue())));</span><br></pre></td></tr></table></figure><p>第一个输出语句是true，第二个输出语句出现false主要是加入自动拆装箱而出现的问题，而==比较的是两个对象是不是同一个对象，如果上面的结果推算，也就是e和f经过自动拆装箱之后生成的对象不再是一个，而c和d仍是统一个对象。<br>为什么会出现这种情况呢？<br>我们来看看cdef打印的地址：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印cdef的内存地址</span></span><br><span class="line">          System.out.println(c+"-"+d+":"+System.identityHashCode(c)+"-"+System.identityHashCode(d));</span><br><span class="line">          System.out.println(e+"-"+f+":"+System.identityHashCode(e)+"-"+System.identityHashCode(f));</span><br></pre></td></tr></table></figure><p>结果如下图所示：<br><img src="Image1.png" alt="Class"></p><p> 可以看出与我们推测的一样，cd经过自动装箱后认为同一个对象，而ef经过自动差装箱后不再为通过各对象，这主要是自动拆装箱带来的后果。<br>查看源码：<br>“从0到127不同时候自动装箱得到的是同一个对象”就只能有一种解释：自动装箱并不一定new出新的对象。<br>查看Integer.valueOf()源码如下：<br><img src="Image2.png" alt="Class"><br>其注释里就直接说明了-128到127之间的值都是直接从缓存中取出的。看看是怎么实现的：如果int型参数i在IntegerCache.low和IntegerCache.high范围内，则直接由IntegerCache返回；否则new一个新的对象返回。似乎IntegerCache.low就是-128，IntegerCache.high就是127了。<br>看看IntegerCache的源码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private static class IntegerCache &#123;</span><br><span class="line">        static final int low = -128;</span><br><span class="line">        static final int high;</span><br><span class="line">        static final Integer cache[];</span><br><span class="line">        static &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            int h = 127;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, 127);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">                &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line">            cache = new Integer[(high - low) + 1];</span><br><span class="line">            int j = low;</span><br><span class="line">            for(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = new Integer(j++);</span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            assert IntegerCache.high &gt;= 127;</span><br><span class="line">        &#125;</span><br><span class="line">        private IntegerCache() &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>果然在其static块中就一次性生成了-128到127直接的Integer类型变量存储在cache[]中，对于-128到127之间的int类型，返回的都是同一个Integer类型对象。<br>这下真相大白了，整个工作过程就是：Integer.class在装载（Java虚拟机启动）时，其内部类型IntegerCache的static块即开始执行，实例化并暂存数值在-128到127之间的Integer类型对象。当自动装箱int型值在-128到127之间时，即直接返回IntegerCache中暂存的Integer类型对象。<br>为什么Java这么设计？我想是出于效率考虑，因为自动装箱经常遇到，尤其是小数值的自动装箱；而如果每次自动装箱都触发new，在堆中分配内存，就显得太慢了；所以不如预先将那些常用的值提前生成好，自动装箱时直接拿出来返回。哪些值是常用的？就是-128到127了。<br>我们继续看第5和第6个输出语句，发现两种比较的方式，输出的结果却不同，为什么会这样呢？<br>通过<strong>反编译代码我们发现，第5个输出语句使用了强制类型转换，而第6个却没有</strong>，这又是为什么呢？<br>答：<strong>主要原因是包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱，，equals方法不处理数据转换的关系，所以第6句没有强制类型转换</strong>。<br>注意，<strong>Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的，Double、Float的valueOf方法的实现是类似的。</strong></p><p>我们来试验Double类型，如下代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println("-------Double---------");</span><br><span class="line">Double i1 = 100.0;</span><br><span class="line">Double i2 = 100.0;</span><br><span class="line">Double i3 = 200.0;</span><br><span class="line">Double i4 = 200.0;</span><br><span class="line">System.out.println(i1==i2);</span><br><span class="line">System.out.println(i3==i4);</span><br></pre></td></tr></table></figure><p>结果：<br>false<br>false<br>我们来看Double的valueof方法：<br><img src="Image4.png" alt="Class"><br>然后我们观察Boolean类型，代码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println("-------Boolean--------");</span><br><span class="line">Boolean b1 = false;</span><br><span class="line">Boolean b2 = false;</span><br><span class="line">Boolean b3 = true;</span><br><span class="line">Boolean b4 = true;</span><br><span class="line">System.out.println(b1==b2);</span><br><span class="line">System.out.println(b3==b4);</span><br></pre></td></tr></table></figure><p>结果：<br>true<br>true<br>我们来看看Boolean的valueof方法<br><img src="Image5.png" alt="Class"></p><table><thead><tr><th>基本类型</th><th>==</th><th>equals</th></tr></thead><tbody><tr><td>字符串变量</td><td>对象的内存地址</td><td>内容</td></tr><tr><td>非字符串变量</td><td>地址</td><td>内容</td></tr><tr><td>基本类型</td><td>值</td><td>不可以（没有强制类型转换，不能使用）</td></tr><tr><td>包装类</td><td>地址（不同的包装类处理方式不同，Integer大小在127前在缓存中取，地址相同）</td><td>比较的是两边的包装类是否为同一个对象</td></tr></tbody></table><p>Integer包装类的equals方法：<br><img src="Image3.png" alt="Class"><br>我们看到包装类的equals方法主要是比较两边是不是同一个对像。</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><p><strong>int和Integer的区别</strong><br>1、Integer是int的包装类，int则是java的一种基本数据类型<br>2、Integer变量必须实例化后才能使用，而int变量不需要<br>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值<br>4、Integer的默认值是null，int的默认值是0</p><p><strong>关于Integer和int的比较</strong><br>1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Integer</span> i = <span class="keyword">new</span> <span class="built_in">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">Integer</span> j = <span class="keyword">new</span> <span class="built_in">Integer</span>(<span class="number">100</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(i == j); //<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>2、Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Integer</span> i = new <span class="keyword">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">int</span> j = <span class="number">100</span>；</span><br><span class="line">System.<span class="keyword">out</span>.<span class="built_in">print</span>(i == j); //true</span><br></pre></td></tr></table></figure><p>3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Integer</span> i = <span class="keyword">new</span> <span class="built_in">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">Integer</span> j = <span class="number">100</span>;</span><br><span class="line">System.<span class="keyword">out</span>.print(i == j); //<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Integer</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">Integer</span> j = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">System</span>.out.print(i == j); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Integer</span> i = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">Integer</span> j = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">System</span>.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;关于以上问题，我们首先先看如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java，自动拆装箱" scheme="http://yoursite.com/tags/Java%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解JVM】之四：字节码指令简介</title>
    <link href="http://yoursite.com/2017/09/26/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/09/26/字节码指令简介/</id>
    <published>2017-09-26T02:33:00.000Z</published>
    <updated>2017-09-30T06:21:13.994Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>java虚拟机的指令由一个字节长度的，代表着某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需参数（称为操作数）而构成。由于java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。</p><h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p>在java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息，例如，iload指令用于从局部变量表中加载int型的数据到操作数栈，而fload指令加载的则是float类型的数据。<br>对于大部分与数据类型相关的字节码指令，他们的操作码助记符中都有特殊的字符来表明专门为那种数据类型服务：i代表int类型，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference。也有一些指令的助记符中没有明确的指明操作符类型的字母，如arraylengh指令。<br>大部分的指令都没有支持整数类型byte，char和short，甚至没有任何指令支持boolean类型，编译器会在编译期或者运行期将byte和short类型的数据带符号扩展为相应的int类型数据，将boolean和char类型数据零位扩展为相应的int类型数据。与之相似，在处理boolean，byte，short和char类型数组时，也会转换成为使用对应的int类型的字节码指令来处理。</p><h3 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h3><p>加载和存储指令用于将数据在栈帧中的<strong>局部变量表和操作数栈之间</strong>来回传输，指令包括：</p><ul><li>将一个局部变量加载到操作数栈：iload，iload_<n>，lload，lload_<n>,fload，float_<n>,dload，dload_<n>，aload，aload_<n>。</n></n></n></n></n></li><li>将一个数值从操作数栈存储到局部变量表：istore,istore_<n>,lstore,lstore_<n>,fstore,fstore_<n>,dstore,dstore_<n>,astore,astore_<n>.</n></n></n></n></n></li><li>将一个常量加载到操作数栈：bipush,sipush , ldc,ldc_w , ldc2_w, aconst_null, iconst_ml, iconst_<i>,lconst_<l>, fconst_<f>, dconst_<d>.</d></f></l></i></li><li>扩充局部变量表的访问索引的指令：wide</li></ul><h3 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h3><p>运算或算术指令用于对两个操作数栈上的值惊醒某种特定运算，并把结果重新存入到操作数栈。</p><ul><li>加法指令：iadd，ladd，fadd，dadd</li><li>减法指令：isub，lsub，fsub，dsub</li><li>乘法指令：imul，lmul，fmul，dmul</li><li>除法指令：idiv，ldiv，fdiv，ddiv</li><li>求余指令：irem，lrem，frem，drem</li><li>取反指令：ineg，lneg，fneg，dneg</li><li>位移指令：ishl，ishr，iushr，lshl，lshr，lushr</li><li>按位或指令：ior，lor</li><li>按位与指令：iand，land</li><li>按位异或指令：ixor，lxor</li><li>局部变量自增指令：iinc</li><li>比较指令：dcmpg，dcmpl，fcmpg，fcmpl，lcmp</li></ul><h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><hr><blockquote><p>你敢不敢问自己到底要去哪里，<br>背负着恐惧寻找的终点，<br>非要是末路吗，<br>你能听到吗，<br>你还能听到吗，<br>你还有勇气直面你的恐惧吗？</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;java虚拟机的指令由一个字节长度的，代表着某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需参数（称为操作数）而构成
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM，Class类" scheme="http://yoursite.com/tags/JVM%EF%BC%8CClass%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解JVM】之三：Class类文件结构</title>
    <link href="http://yoursite.com/2017/09/22/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2017/09/22/Class类文件结构/</id>
    <published>2017-09-22T04:33:00.000Z</published>
    <updated>2017-09-25T11:22:26.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本文章参考周志明的【深入理解Java虚拟机】<br>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。<br>提示：如果想系统的了解java虚拟机，我建议买一本周志明写的【深入理解Java虚拟机】来看看，通俗易懂，一本圣经。</p></blockquote><h2 id="Class类文件结构"><a href="#Class类文件结构" class="headerlink" title="Class类文件结构"></a>Class类文件结构</h2><p>Class文件是一组以8为字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。<br>根据Java虚拟机规范规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据的，这种微结构中只有两种数据类型：无符号数和表。<br>1.无符号数<br>无符号数属于基本数据类型，主要可以用来描述数字、索引符号、数量值或者按照UTF-8编码构成的字符串值，大小使用u1、u2、u4、u8分别表示1字节、2字节、4字节和8字节。<br>2.表<br>  表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有的表都习惯以“_info” 结尾。表是用于描述有层次关系的复合结构的数据，整个Class文件本质就是一张表，它是由图1所示的数据项构成。<br>  <img src="Class文件格式.png" alt="Class"><br> 在class文件中，主要分为魔数、Class文件的版本号、常量池、访问标志、类索引（还包括父类索引和接口索引集合）、字段表集合、方法表集合、属性表集合。<br> 无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型数据的集合。</p><hr><h3 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h3><p>每个Class文件的头4个字节成为魔数（Magic Number），它唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件。很多文件存储标准都使用魔数进行身份的识别，如图片格式 gif或jpeg等在文件头都有魔数。使用魔数而不是扩展名进行身份识别主要基于安全考虑，因为扩展名可以所以的改动。<br>文件格式的制定者可以自由选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混乱即可。<br>Class文件的魔数是0xCAFEBABE。紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。<br>示例代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.JVMDemo;</span><br><span class="line"></span><br><span class="line">public class JavaTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">byte[] b = null;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">b = new byte[1 * 1024 * 1024];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图显示的是使用十六进制编辑器WinHex打开的Class文件的结果。<br><img src="javaclass.png" alt="Class"><br>可以看到开头的4个字节的16进制表示是0xCAFEBABE，代表此版本号的是第5和第6个字节值为0x0000，主版本号是0x0034，也即是10进制的52。<br>  这个的版本号是随着jdk版本的不同而表示不同的版本范围的。Java的版本号是从45开始的。如果Class文件的版本号超过虚拟机版本，将被拒绝执行。<br>  0X0034（对应十进制的52）：JDK1.8<br>  0X0033（对应十进制的51）：JDK1.7<br>  0X0032（对应十进制的50）：JDK1.6<br>  0X0031（对应十进制的49）：JDK1.5　　<br>  0X0030（对应十进制的48）：JDK1.4　　<br>  0X002F（对应十进制的47）：JDK1.3　　<br>  0X002E（对应十进制的46）：JDK1.2 </p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>紧接着魔数与版本号之后的是常量池入口，常量池简单理解为class文件的资源从库，它是Class文件结构中与其它项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在文件中第一个出现的表类型数据项目。<br>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值(constant_pool_count)。这个容量计数器从1开始计数。<br>如下图中，常量池容量（十六进制0x001B），即使十进制的27，，这就代表常量池中有26项常量，索引值范围为1-26.<br><img src="常量池结构.png" alt="Class"><br>这样做的目的是有特殊考虑的， 第0项腾出来满足后面某些指向常量池的索引值的数据在特定情况下需要表达”不引用任何一个常量池项目”的意思，这种情况就可以把索引值置为0来表示。Class文件结构中只有常量池的容量计数器是从1开始的，对与其它集合类型，包括接口索引集合，字段表集合，方法表集合等容量计数都是从0开始。<br>使用Javap命令输出常量表，如下：<br><img src="Javap输出常量表.png" alt="Class"><br>从表中可以发现总共有26个，也就是说常量池容量为26。<br>常量池之中主要存放两大类常量：<br> 1).字面量: 比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等<br> 2).符号引用: 属于编译原理方面的概念，包括了下面三类常量:<br>   ①.类和接口的全限定名<br>   ②.字段的名称和描述符<br>   ③.方法的名称和描述符<br> Java代码在进行Java编译的时候，并不像C和C++那样有”连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法和字段的最终内存布局信息，因此这些字段和方法的符号引用不经过转换的话是无法被虚拟机使用的。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析并翻译到具体的内存地址之中。<br> 常量池中每一项常量都是一个表，在jdk1.7之前共有11中结构各不相同的表结构数据，之后又增加了3中。<br> 这14中都有一个共同的特点，就是表开始的第一位是一个u1类型的标志位，代表当前这个属性属于那种类型常量。具体如下图所示：<br> <img src="常量池的项目类型.png" alt="Class"></p><p> <strong>符号引用与直接引用的关联</strong><br>    符号引用是一组符号，用来描述所引用的目标，符号是以任何形式存在的字面量。对于符号引用Java虚拟机并没有严格的限制。规定只需要使用的时候能够无歧义定位到目标就可以。常量池存在于Class文件中，而Class文件是必须首先通过Java虚拟机的类加载机制加载到内存中（确切的说是方法区这个内存区域，回顾一下，方法区存放的主要是对象的实例，这个Class文件是虚拟机对外接受访问的接口）。符号引用属于常量池中的内容，那么是不是说符号引用的目标已经加载到内存中了呢？答案是否定的，因为符号引用与虚拟机的内存布局无关，符号引用的目标并不一定已经加载到内存中了。<br>    直接引用可以是直接指向引用目标的指针、相对偏移量或者是一个能够间接定位到目标的句柄。直接引用是和虚拟机的内存布局有关的，同一个符号引用在不同的虚拟机上翻译的直接引用一般是不同的。如果有了直接引用，那么引用的目标必定是存在内存中的。</p><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>在常量池结束之后，紧接着的两个字节代表访问标志（access_flags）,这个标志用于识别一些类或者接口层次的访问信息。具体的标志位以及标志的含义见下表：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>是否为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>是否被声明为final，只有类可设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否允许使用invokespecial字节码指令的新语意，invokespecial指令的语意在JDK1.2发生过改变，为了区别这条指令使用哪种语意，JDK1.0.2之后编译出来的类的这个标志必须为真</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标识这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为abstract类型，对于接口和抽象类，此标志为真，其它类为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标识别这个类并非由用户代码产生</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标识这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标识这是一个枚举</td></tr></tbody></table><p>access_flags一共有16个标志位可以使用，当前只定义了其中8个（JDK1.5增加后面3种），没有使用到标志位一律为0。仍以开始代码为例，类JavaTest为一个普通的类，不是借口，枚举或者注解，被public修饰但没有声明final和abstract，用的是JDK1.2之后的编译器进行编译的。所以ACC_PUBLIC，ACC_SUPER标志应当为真，其他为假。所以access_flags的值为：0x0001|0x0020 = 0x0021。结果如下图：<br><img src="0021.png" alt="Class"></p><h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h3><p>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而借口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系。<br> 类索引(this_class)，用于确定这个类的全限定名，占2字节，父类索引(super_class)，用于确定这个类父类的全限定名（Java语言不允许多重继承，故父类索引只有一个。除了java.lang.Object类之外所有类都有父类，故除了java.lang.Object类之外，所有类该字段值都不为0），占2字节。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句后的接口顺序从左到右排列在接口索引集合中。<br>  this_class、super_class与interfaces按顺序排列在访问标志之后，它们中保存的索引值均指向常量池中一个CONSTANT_Class_info类型的常量，通过这个常量中保存的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。<br> 类索引，父类索引与接口索引的内容如下图所示：<br> <img src="类索引.png" alt="Class"><br> 测试类对应的this_class的值为0x0001，即常量池中第1个常量，super_class的值为0x0003，即常量池中的第3个常量，interfaces_counts的值为0x0000，故接口索引集合大小为0.<br>  <img src="javap类索引.png" alt="Class"></p><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>字段表用于描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的变量。<br>  在Java中一般通过如下几项描述一个字段：字段作用域（public、protected、private修饰符）、是类级别变量还是实例级别变量（static修饰符）、可变性（final修饰符）、并发可见性（volatile修饰符）、可序列化与否（transient修饰符）、字段数据类型（基本类型、对象、数组）以及字段名称。在字段表中，变量修饰符使用标志位表示，字段数据类型和字段名称则引用常量池中常量表示，字段表格式如下表所示：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><p>字段表里的字段修饰符放在access_flags中，占2个字节，与类中的访问标志（access_flags）十分相似，都是u2的数据类型，其中可以设置的标志位和含义见表：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为volatile</td></tr><tr><td>ACC_TRANSIENT</td><td>0x0080</td><td>字段是否为transient</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>字段是否为编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为enum</td></tr></tbody></table><p> 当然实际上，ACC_PUBLIC、ACC_PRIVATE和ACC_PROTECTED这3个标志只能选择一个，接口中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志，Class文件对此并无规定，这些都是java语言所要求的。<br>跟随access_flags标志的是两项索引值：name_index和descriptor_index。他们都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符。<br><strong>简单名称，描述符的解释</strong>：<br><strong>简单名称</strong>：是指没有类型和参数修饰的方法或者字段名称，这一个类的main（）方法的简单名称时main。<br><strong>描述符</strong>：作用是用来描述字段的数据类型，方法的参数列表（包括数量，类型以及顺序）和返回值。根据描述符规则，基本数据类型以及代表无返回值的void类型都用一个大写字符表示，而对象类型则用字符L加对象的权限定名来表示，如下表：</p><table><thead><tr><th>标识字符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本类型byte</td></tr><tr><td>C</td><td>基本类型char</td></tr><tr><td>D</td><td>基本类型double</td></tr><tr><td>F</td><td>基本类型float</td></tr><tr><td>I</td><td>基本类型int</td></tr><tr><td>J</td><td>基本类型long</td></tr><tr><td>S</td><td>基本类型short</td></tr><tr><td>Z</td><td>基本类型boolean</td></tr><tr><td>V</td><td>基本类型void</td></tr><tr><td>L</td><td>对象类型，如Ljava/lang/Object</td></tr></tbody></table><p><strong>对于数组类型</strong>，每一维度将使用一个前置的“[” 字符来描述，如一个定义为“java.lang.String[ ][ ]”类型的二维数组，将被记录为：”[[Ljava/lang/String” ，一个整形数组“int[]“将被记录为”[I“。<br>用描述符描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“（）”之内，如方法void inc() 的描述符是“（）V”，方法java.lang.String toString（）的描述符为“（）Ljava/lang/String“。<br>开始的代码案例不能有效说明字段集合，所以下面我们以如下的代码来说明：<br>代码二：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.JVMDemo;</span><br><span class="line"></span><br><span class="line">public class TestClass &#123;</span><br><span class="line">private int m;</span><br><span class="line">public int inc()&#123;</span><br><span class="line">return m+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段表结构实例如下图：<br> <img src="字段表集合.png" alt="Class"><br> 从图中可以看到，fields_count的值为0x0001，说明这个类只有一个字段表数据，接下来是access_flags表示，值为0x0002，代表private修饰符，代表字段名称的name_index的值为0x0005,从代码清单第五项常量是m，代表字段描述符的值为0<br> x0006，指向常量池的字符串“I”，根据这些信息我们可以推算字段为“<strong>private int m</strong>”<br> <img src="字段表代码清单.png" alt="Class"><br>  字段表集合中不会列出从<strong>父类或父接口</strong>中继承的字段，但是可能列出原本Java代码之中不存在的字段，如：内部类为了保持对外部类的访问性，自动添加指向外部类实例的字段.<br>  Java语言中字段是不能重载的，2个字段无论数据类型、修饰符是否相同，都不能使用相同的名称；但是对于字节码，只要字段描述符不同，字段重名就是合法的.</p><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>方法表的结构如同字段表一样，依次包括了访问标志（access_flags）,名称索引（name_index），描述符索引（descriptor_index），属性表集合（attributes）几项；如下表所示：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><p>由于ACC_VOLATILE标志和ACC_TRANSIENT标志不能修饰方法，所以access_flags中不包含这两项，同时增加ACC_SYNCHRONIZED标志、ACC_NATIVE标志、ACC_STRICTFP标志和ACC_ABSTRACT标志。<br> <img src="方法表描述.png" alt="Class"><br>  access_flags为0x0001，即public；name_index为0x0007，即常量池中第7个常量；descriptor_index为0x0008，即常量池中第8个常量， 接下来2个字节为属性计数器，其值为0x0001，说明这个方法的属性表集合中有一个属性（详细说明见后面“八、属性表集合”）， 属性名称为接下来2位0x0009，指向常量池中第9个常量：Code。<br>    在Java语言中，重载一个方法除了要求和原方法拥有相同的简单名称外，还要求必须拥有一个与原方法不同的特征签名，由于特征签名不包含返回值，故Java语言中不能仅仅依靠返回值的不同对一个已有的方法重载；但是在Class文件格式中，特征签名即为方法描述符，只要是描述符不完全相同的2个方法也可以合法共存，即2个除了返回值不同之外完全相同的方法在Class文件中也可以合法共存</p><h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>属性表在Class文件，字段表，方法表都可以携带自己的表集合，以用来描述某些场景专有的信息。<br>与Class文件中其他的数据项目要求严格的顺序，长度和内容不同，属性表集合的限制稍微宽松了一些，不在要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以想属性表中写入自己定义的信息，java虚拟机运行时会忽略掉它不认识的属性。<br>为了能正确解析Class文件，虚拟机规范中预定义了虚拟机实现必须能够识别的9项属性（预定义属性已经增加到21项），如下表：</p><table><thead><tr><th>属性名称</th><th>使用位置</th><th>含义</th></tr></thead><tbody><tr><td>Code</td><td>方法表</td><td>Java代码编译成的字节码指令</td></tr><tr><td>ConstantValue</td><td>字段表</td><td>final关键字定义的常量值</td></tr><tr><td>Deprecated</td><td>类文件、字段表、方法表</td><td>被声明为deprecated的方法和字段</td></tr><tr><td>Exceptions</td><td>方法表</td><td>方法抛出的异常</td></tr><tr><td>InnerClasses</td><td>类文件</td><td>内部类列表</td></tr><tr><td>LineNumberTale</td><td>Code属性</td><td>Java源码的行号与字节码指令的对应关系</td></tr><tr><td>LocalVariableTable</td><td>Code属性</td><td>方法的局部变量描述</td></tr><tr><td>SourceFile</td><td>类文件</td><td>源文件名称</td></tr><tr><td>Synthetic</td><td>类文件、方法表、字段表</td><td>标识方法或字段是由编译器自动生成的</td></tr></tbody></table><p><strong>关于属性表集合这里不再详细介绍，如果想深入理解，请参考周志明的【深入理解java虚拟机】</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文章参考周志明的【深入理解Java虚拟机】&lt;br&gt;代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM，Class类" scheme="http://yoursite.com/tags/JVM%EF%BC%8CClass%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解JVM】之二：垃圾收集器与常用JVM配置参数</title>
    <link href="http://yoursite.com/2017/09/20/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%B8%B8%E7%94%A8JVM%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2017/09/20/java垃圾收集器与常用JVM配置参数/</id>
    <published>2017-09-20T09:33:00.000Z</published>
    <updated>2018-06-26T11:51:59.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>本文章参考周志明的【深入理解Java虚拟机】<br>java与C++支架有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。</p></blockquote><h3 id="GC的概述"><a href="#GC的概述" class="headerlink" title="GC的概述"></a>GC的概述</h3><p>1.<strong>GC</strong>：Garbage Collection 垃圾收集。这里所谓的垃圾指的是在系统运行过程当中所产生的一些无用的对象，这些对象占据着一定的内存空间，如果长期不被释放，可能导致OOM。<br>在C/C++里是由程序猿自己去申请、管理和释放内存空间，因此没有GC的概念。而在Java中，后台专门有一个专门用于垃圾回收的线程来进行监控、扫描，自动将一些无用的内存进行释放，这就是垃圾收集的一个基本思想，目的在于防止由程序猿引入的人为的内存泄露。<br>2.<strong>内存区域中的程序计数器、虚拟机栈、本地方法栈这3个区域随着线程而生，线程而灭</strong>；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈的操作，每个栈帧中分配多少内存基本是在类结构确定下来时就已知的。在这几个区域不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。<br>而<strong>Java堆和方法区</strong>则不同，一个接口中的多个实现类需要的内存可能不同，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，GC关注的也是这部分内存，后面的文章中如果涉及到“内存”分配与回收也仅指着一部分内存。</p><h3 id="对象存活算法"><a href="#对象存活算法" class="headerlink" title="对象存活算法"></a>对象存活算法</h3><p>堆中几乎存放着Java世界中所有的对象实例，垃圾收集器在对堆回收之前，第一件事情就是要确定这些对象哪些还“存活”着，哪些对象已经“死去”(即不可能再被任何途径使用的对象).<br>1.<strong>引用计数算法</strong><br> 很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器减1；任何时刻计数器都为0的对象就是不可能再被使用的。<br>  引用计数算法的实现简单，判断效率也很高，在大部分情况下它都是一个不错的算法。但是Java语言中没有选用引用计数算法来管理内存，其中最主要的一个原因是它很难解决对象之间相互循环引用的问题。<br>  <strong>例子：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ReferenceCountingGC &#123;  </span><br><span class="line">    public Object instance = null;  </span><br><span class="line">  </span><br><span class="line">    private static final int _1MB = 1024 * 1024;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    private byte[] bigSize = new byte[2 * _1MB];  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        ReferenceCountingGC objA = new ReferenceCountingGC();  </span><br><span class="line">        ReferenceCountingGC objB = new ReferenceCountingGC();  </span><br><span class="line">        objA.instance = objB;  </span><br><span class="line">        objB.instance = objA;  </span><br><span class="line">  </span><br><span class="line">        objA = null;  </span><br><span class="line">        objB = null;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//假设在这行发生了GC，objA和ojbB是否被回收  </span></span><br><span class="line">        System.gc();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="GCTest.png" alt="GC"></p><p>从结果中可以看出虚拟机启动GC后，日志中包含“6758K -&gt; 592K”(红色的框)，意味着虚拟机并没有因为这两个对象相互引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。<br>2.<strong>可达性分析算法</strong><br>  在主流的商用程序语言中(Java和C#)，都是使用可达性分析算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会判定为是可回收对象。<br><img src="GCRootSet.png" alt="参数"><br> 在Java语言里，可作为GC Roots对象的包括如下几种：<br> a.虚拟机栈(栈桢中的本地变量表)中的引用的对象<br> b.方法区中的类静态属性引用的对象<br> c.方法区中的常量引用的对象<br> d.本地方法栈中JNI的引用的对象 </p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>Java中的垃圾回收一般是在Java堆中进行，因为堆中几乎存放了Java中所有的对象实例。谈到Java堆中的垃圾回收，自然要谈到引用。无论通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与引用有关。在JDK1.2之前，Java中的引用定义很很纯粹：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。但在JDK1.2之后，Java对引用的概念进行了扩充，将其分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，引用强度依次减弱。<br>a.<strong>强引用</strong>：如“Object obj = new Object（）”，这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。<br>b.<strong>软引用</strong>：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2之后提供了SoftReference类来实现软引用。<br>c.<strong>弱引用</strong>：它也是用来描述非需对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存岛下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。<br>d.<strong>虚引用</strong>：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后提供了PhantomReference类来实现虚引用。</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，java规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，在方法区进行垃圾收集的性价比很低，在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%-95%的空间，而永生代垃圾收集率远低于此。<br>永生代的垃圾收集主要回收两个部分内容：废弃常量和无用的类<br>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用类”的条件相对苛刻，类需满足下面3个条件：<br>1.该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例<br>2.加载该类的ClassLoader已经被收回<br>3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。<br>在大量使用反射，动态代理，CGLib等ByteCode框架，动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>1.<strong>标记-清除算法</strong><br> 标记—清除算法是最基础的收集算法，它分为“标记”和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程。如图：<br> <img src="Mark-Sweep.png" alt="参数"><br> 缺点：<br>    ①.效率问题：标记清除过程效率都不高。<br>    ②.空间问题：标记清除之后会产生大量的不连续的内存碎片(空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续的内存空间而不得不提前触发另一次垃圾收集动作。）<br>2.<strong>复制算法</strong><br> 复制算法是针对标记—清除算法的缺点，在其基础上进行改进而得到的，它讲课用内存按容量分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面，然后再把已使用过的内存空间一次清理掉。复制算法有如下优点：<br>每次只对一块内存进行回收，运行高效。<br>只需移动栈顶指针，按顺序分配内存即可，实现简单。<br>内存回收时不用考虑内存碎片的出现。<br>它的缺点是：可一次性分配的最大内存缩小了一半。<br><img src="Coping.png" alt="参数"><br>3.<strong>标记-整理算法</strong><br>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低，更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代（后面会讲到）一般不能直接选用这种算法。<br>根据老年代的特点，有人提出“标记-整理（Mark-Compact）”算法,标记过程仍与“标记-清除”一样，但后续不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外 的内存。如图：<br><img src="Mark-Compact.png" alt="参数"><br>4.<strong>分带收集算法</strong><br>当前商业虚拟机的垃圾收集 都采用分代收集，它根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用复制算法来完成收集，而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清除算法或标记—整理算法来进行回收。</p><h3 id="垃圾收集器-1"><a href="#垃圾收集器-1" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>HotSpot虚拟机实现的垃圾收集器可以参考下面的博客，内容很详细</p><blockquote><p>Chang_Wen_Liu博客: <a href="http://blog.csdn.net/ochangwen/article/details/51412595" target="_blank" rel="noopener">http://blog.csdn.net/ochangwen/article/details/51412595</a></p></blockquote><p>我在学习java虚拟机的时候看到一篇对本节的知识点介绍比较好理解的文章，如果大家对以上的概念有不理的地方，我想下面的这篇博客可以给你启发（图比较多，更有助于理解，无言表达比较容易懂）：</p><blockquote><p>生命壹号：<a href="http://www.cnblogs.com/smyhvae/p/4744233.html" target="_blank" rel="noopener">http://www.cnblogs.com/smyhvae/p/4744233.html</a></p></blockquote><hr><h2 id="常用JVM配置参数"><a href="#常用JVM配置参数" class="headerlink" title="常用JVM配置参数"></a>常用JVM配置参数</h2><h3 id="Trace跟踪参数"><a href="#Trace跟踪参数" class="headerlink" title="Trace跟踪参数"></a>Trace跟踪参数</h3><p>1.<strong>打开GC开关</strong></p><blockquote><p>-verbose:gc<br>-XX:+printGC<br>这两个是一样的，可以粗糙的认为其中一个相当于另一个的别名。</p></blockquote><p>在IDE的后台打印GC日志：本实例以eclipse为例<br>既然学习JVM，阅读GC日志是处理Java虚拟机内存问题的基础技能，它只是一些人为确定的规则，没有太多技术含量。<br><img src="Console.png" alt="GC"><br><img src="Console1.png" alt="GC"><br>结果：<br><img src="ConsoleGC.png" alt="GC"><br>虽然可以打印出一部分GC内容，但是这还是远远不够的，一下接收的和参数的配置方式和图中 的一样。<br>2.<strong>打印GC详细信息</strong></p><blockquote><p>-XX:+PrintGCDetails</p></blockquote><p>打印的GC结果<br><img src="Heap.png" alt="GC"><br>3.<strong>打印CG发生的时间戳</strong></p><blockquote><p>-XX:+PrintGCTimeStamps</p></blockquote><p>4.<strong>指定GC log的位置</strong>：</p><blockquote><p>-Xloggc:log/gc.log</p></blockquote><p>5.<strong>每一次GC前和GC后，都打印堆信息</strong></p><blockquote><p>-XX:+PrintHeapAtGC</p></blockquote><p>6.<strong>监控类的加载</strong></p><blockquote><p>-XX:+TraceClassLoading</p></blockquote><p><img src="Loaded.png" alt="GC"></p><hr><p><strong>理解GC日志的内容</strong>：<br>每一种收集器的日志形式都是有它们自身的实现所决定的，换言之，每个收集器的日志格式都可以不一样，但虚拟机设计者为了方便用户阅读，讲个收集器的日志都维持一定的共性。例如：<br><img src="ConsoleGC.png" alt="GC"><br>GC日志开头的“[GC”和”[Full GC” 是表示这次垃圾收集的停顿时间，而不是用来区分新生代GC还是老生代GC的，如果有Full，说明这次的GC是发生了<strong>Stop-The-Word</strong>（下面介绍）的。<br>接下来“[PSYoungGen”，“[ParOldGen”表示GC发生的区域，这里显示的区域名称与使用的GC收集器密切是相关的，例如使用Serial收集器，则新生代名为“Default New Generation” 所以会显示“[DefNew”，如果是ParNew收集器，新生代会显示“[ParNew”，如果采用Parallel Scavenge收集器，那么新生代称为“PaYoungGen”，老年代和永久代同理，名称也是由收集器决定的。<br>后面的2662K-&gt;696K(38400K) 含义是“<strong>GC前该内存区域已使用的容量–&gt; GC后该内存区域使用的容量（该内存区域总容量）</strong>”，而方括号之外的“2662K-&gt;704K(125952K)”表示“<strong>GC前java对已使用容量 —&gt; GC后java堆已使用容量（java堆总容量）</strong>”，在后面<strong>“0.0061965 secs</strong>”表示该内存区域GC所占用的时间，单位是秒。<br>-XX:+PrintGCDetails打印结果：<br><img src="Heap1.png" alt="GC"><br>heap区又分为： </p><ul><li><strong>Eden Space</strong>（伊甸园）、 </li><li><strong>Survivor Space</strong>(幸存者区)、 </li><li><strong>Old Gen</strong>（老年代）。<br>Eden Space字面意思是伊甸园，对象被创建的时候首先放到这个区域，进行垃圾回收后，不能被回收的对象被放入到空的survivor区域。<br>Survivor Space幸存者区，用于保存在eden space内存区域中经过垃圾回收后没有被回收的对象。Survivor有两个，分别为To Survivor、 From Survivor，这个两个区域的空间大小是一样的。执行垃圾回收的时候Eden区域不能被回收的对象被放入到空的survivor（也就是To Survivor，同时Eden区域的内存会在垃圾回收的过程中全部释放），另一个survivor（即From Survivor）里不能被回收的对象也会被放入这个survivor（即To Survivor），然后To Survivor 和 From Survivor的标记会互换，始终保证一个survivor是空的。<br>图中的<strong>from space</strong>对应的就是From Survivor，<strong>to space</strong> 对应的是ToServivor。<br><img src="Survivor.png" alt="GC"><br><strong>Eden Space和Survivor Space</strong>都属于新生代，新生代中执行的垃圾回收被称之为Minor GC（因为是对新生代进行垃圾回收，所以又被称为Young GC），每一次Young GC后留下来的对象age加1。<br><strong>Old Gen老年代</strong>，用于存放新生代中经过多次垃圾回收仍然存活的对象，也有可能是新生代分配不了内存的大对象会直接进入老年代。经过多次垃圾回收都没有被回收的对象，这些对象的年代已经足够old了，就会放入到老年代。<br>当老年代被放满的之后，虚拟机会进行垃圾回收，称之为<strong>Major GC</strong>（不是Minor GC）。由于Major GC除并发GC外均需对整个堆进行扫描和回收，因此又称为<strong>Full GC</strong>。<br><strong>MinorGC和Full GC区别</strong></li><li><strong>新生代GC</strong>（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕死的特性，所以Minor GC非常的频繁，一般回收速度也比较快。</li><li><strong>老年代GC</strong>（Major GC/Full GC）:指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（并非绝对，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般比Minor GC 慢10倍以上。<br>上图中，我们先看一下“[0x00000000d5e00000, 0x00000000d8880000, 0x0000000100000000)”（PSYoungGen后方括号里的内容）的含义，它表示新生代在内存当中的位置：第一个参数是申请到的起始位置，第二个参数是申请到的终点位置，第三个参数表示最多能申请到的位置。上图中的例子表示新生代申请到了43M的控件，而这个43M是等于：<strong>（eden space的33280K）+（from space的5120K）+（to space的5120K）</strong>。<br>疑问：<strong>分配到的新生代有43M，但是可用的只有38400K，为什么会有这个差异呢</strong>？<br>这里还是因为Survivor Space幸存者区，这个区有两个分别为To Survivor、 From Survivor，其中的一个区被要求用来放不能被回收的对象，所有能放新对象的区域只有 Eden space和Survivor Space中的一个。</li></ul><p><strong>Stop-The-Word</strong>：<br>1、<strong>Stop-The-World概念</strong>：<br>Java中一种全局暂停的现象。全局停顿，所有Java代码停止，native代码可以执行，但不能和JVM交互，多半情况下是由于GC引起。<br> 少数情况下由其他情况下引起，如：Dump线程、死锁检查、堆Dump。<br>2、GC时为什么会有全局停顿？<br>（1）<strong>避免无法彻底清理干净</strong><br>打个比方：类比在聚会，突然GC要过来打扫房间，聚会时很乱，又有新的垃圾产生，房间永远打扫不干净，只有让大家停止活动了，才能将房间打扫干净。<br> 况且，如果没有全局停顿，会给GC线程造成很大的负担，GC算法的难度也会增加，GC很难去判断哪些是垃圾。<br>（2）<strong>GC的工作必须在一个能确保一致性的快照中进行</strong>。<br>这里的一致性的意思是：在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果的准确性无法得到保证。<br>这点是导致GC进行时必须停顿所有Java执行线程的其中一个重要原因。</p><hr><h3 id="堆的分配参数"><a href="#堆的分配参数" class="headerlink" title="堆的分配参数"></a>堆的分配参数</h3><p>1.<strong>-Xmx –Xms</strong>：指定最大堆和最小堆<br>案例：-Xmx20m -Xms5m<br>指定最大堆内存20M，最小堆内存5M。<br>2.设置新生代大小</p><blockquote><p> -Xmn</p></blockquote><p>3.新生代和老年代的比值</p><blockquote><p>-XX:NewRatio<br>比如：-XX:NewRatio=4   表示新生代:老年代=1:4，即新生代占整个堆的1/5</p></blockquote><p>4.设置两个Survivor区和Eden的比值</p><blockquote><p>-XX:SurvivorRatio<br>例如：值为8时，表示两个Survivor:eden=2:8，即一个Survivor占年轻代的1/10</p></blockquote><p>先运行一下代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.JVMDemo;</span><br><span class="line">public class JavaTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">byte[] b = null;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">b = new byte[1 * 1024 * 1024];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们通过设置不同的GC参数来看看输出结果有什么不同：</p><ul><li><strong>-Xmx20m -Xms20m -Xmn1m -XX:+PrintGCDetails</strong> （设置新生代大小为1M）<br><img src="JVMDemo.png" alt="GC"><br>结果进行了一次GC，Allocation Failure – 引起垃圾回收的原因. 本次GC是因为年轻代中没有任何合适的区域能够存放需要分配的数据结构而触发的.</li><li><strong>-Xmx20m -Xms20m -Xmn15m -XX:+PrintGCDetails</strong>（新生代15M，足够大）<br><img src="JVMDemo1.png" alt="GC"><br>结果没有进行GC，老年代也没有使用到。所有都分配到Eden space。</li><li><strong>-Xmx20m -Xms20m –Xmn7m -XX:+PrintGCDetails</strong>（新生代大小7M）<br><img src="JVMDemo2.png" alt="GC"><br>结果进行了两次GC，老年代中使用了2152K，survivor太小需要老年代担保。</li><li><strong>-Xmx20m -Xms20m -Xmn7m -XX:SurvivorRatio=2 -XX:+PrintGCDetails</strong>（增加幸存带的大小）<br><img src="JVMDemo3.png" alt="GC"><br>进行了三次GC。<br>在新生代相同的情况下，增加了幸存带，老年代的使用减小了。<br><strong>结论：通过对GC参数的调整可以调成程序的运行速度，根据GC的值可以对程序进行优化。</strong></li></ul><p>5.OOM时导出堆信息到文件，根据这个文件，我们可以看到系统dump时发生了什么。</p><blockquote><p>-XX:+HeapDumpOnOutOfMemoryError</p></blockquote><p>6.导出OOM的路径</p><blockquote><p>-XX:+HeapDumpPath<br>例如：-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:/a.dump<br>上方意思是说，现在给堆内存最多分配20M的空间。如果发生了OOM异常，那就把dump信息导出到d:/a.dump文件中。</p></blockquote><h3 id="栈的分配参数"><a href="#栈的分配参数" class="headerlink" title="栈的分配参数"></a>栈的分配参数</h3><blockquote><p>-Xss<br>设置栈空间的大小。通常只有几百K<br>决定了函数调用的深度<br>每个线程都有独立的栈空间<br>局部变量、参数 分配在栈上</p></blockquote><p>代码示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.JVMDemo;</span><br><span class="line">public class TestStackDeep &#123;</span><br><span class="line">private static int count = 0;</span><br><span class="line">    public static void recursion(long <span class="selector-tag">a</span>, long <span class="selector-tag">b</span>, long c) &#123;</span><br><span class="line">        long e = 1, f = 2, g = 3, h = 4, i = 5, k = 6, q = 7, x = 8, y = 9, z = 10;</span><br><span class="line">        count++;</span><br><span class="line">        recursion(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            recursion(0L, 0L, 0L);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            System.out.println("deep of calling = " + count);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果设置栈大小为128k：-Xss128k<br><img src="Stackdeep.png" alt="GC"><br>如果你去掉-Xss，改成默认你会发现会结果发生变化。</p><h3 id="永久区分配参数"><a href="#永久区分配参数" class="headerlink" title="永久区分配参数"></a>永久区分配参数</h3><blockquote><p>-XX:PermSize<br>-XX:MaxPermSize</p></blockquote><hr><p>参考：</p><blockquote><p><a href="http://www.cnblogs.com/smyhvae/p/4736162.html" target="_blank" rel="noopener">http://www.cnblogs.com/smyhvae/p/4736162.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;垃圾收集器&quot;&gt;&lt;a href=&quot;#垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集器&quot;&gt;&lt;/a&gt;垃圾收集器&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="垃圾收集器,参数配置,JVM" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE-JVM/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解JVM】之一： java内存区域与内存溢出异常</title>
    <link href="http://yoursite.com/2017/09/15/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2017/09/15/java内存区域与内存溢出异常/</id>
    <published>2017-09-15T09:33:00.000Z</published>
    <updated>2017-12-05T06:42:10.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是基于周志明的《深入理解Java虚拟机》<br>java与C++支架有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。</p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，ava虚拟机规范将JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。 如下图所示：<br><img src="内存图.png" alt="虚拟机"><br>《深入理解java虚拟机》中的描述：<br><img src="dataarea.png" alt="《深入理解java虚拟机》中的描述"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的空间，他可以看做是当前线程所执行的字节码的行号指示器，在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。<br>    由于java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此， <strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器</strong>，各线程之间计数器互不影响，独立存储 ，我们称这类内存区域为“线程私有”的内存。<br>    一个处理器都只会执行一条线程中的指令，所以，每个线程都需要一个独立的程序计数器，各线程之间计数器互不影响，独立存储。如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。</p><blockquote><p>注意：此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p></blockquote><h3 id="java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="java虚拟机栈（Java Virtual Machine Stacks）"></a>java虚拟机栈（Java Virtual Machine Stacks）</h3><p>与程序计数器一样，java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的声明周期与线程相同，虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部标量表，操作数栈，动态链接，方法出口等信息。每一个<strong>方法从调用直至执行完成的过程，就读应这一个栈帧在虚拟机栈中入栈到出栈的过程</strong>。</p><ul><li>局部变量表<br>  局部变量表存放了编译期可知的各种基本数据类型（8中基本数据类型），对象引用(reference类型)和returnAddress类型（指向了一条字节码指令的地址）<br> 其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot)，其余的数据类型只占用1个。局部变量表所需的内存大小在<strong>编译期就完成了分配</strong>，也就是说当进入一个方法时，此方法需要在栈帧中分配多大的局部变量表空间时完全确定的，运行期不会改变 。<br>如下代码：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package test03;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by smyhvae on 2015/8/15.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public class StackDemo &#123;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    public static int runStatic(int <span class="selector-tag">i</span>, long l, <span class="attribute">float</span> f, Object o, byte b) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实例方法</span></span><br><span class="line">    public int runInstance(char c, short s, boolean b) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>上方代码中，静态方法有5个形参，实例方法有3个形参。其对应的局部变量表如下：<br><img src="局部变量表.png" alt="虚拟机"><br>上方表格中，静态方法和实例方法对应的局部变量表基本类似。但有以下区别：实例方法的表中，第一个位置存放的是当前对象的引用。（如果对这张图看不同不要紧，通过下节对Class类文件结构的讲解，也许你就能理解其中的含义）</p><blockquote><p>在Java虚拟机规范中，对这个区域规定了两种异常情况：<br>  （1、如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。<br>  （2、如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。<br> 这两种情况存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。在单线程的操作中，无论是由于栈帧太大，还是虚拟机栈空间太小，当栈空间无法分配时，虚拟机抛出的都是StackOverflowError异常，而不会得到OutOfMemoryError异常。而在多线程环境下，则会抛出OutOfMemoryError异常。</p></blockquote><ul><li>操作数栈<br><strong>操作数栈又常被称为操作栈，操作数栈的最大深度也是在编译的时候就确定了</strong>。32位数据类型所占的栈容量为1,64为数据类型所占的栈容量为 2。当一个方法开始执行时，它的操作栈是空的，在方法的执行过程中，会有各种字节码指令（比如：加操作、赋值元算等）向操作栈中写入和提取内容，也就是入栈和出栈操作。<br>Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。因此我们也称Java虚拟机是基于栈的，这点不同于Android虚拟机，Android虚拟机是基于寄存器的。<br>基于栈的指令集最主要的优点是可移植性强，主要的缺点是执行速度相对会慢些；而由于寄存器由硬件直接提供，所以基于寄存器指令集最主要的优点是执行速度快，主要的缺点是可移植性差。         </li><li>动态链接<br>每个栈帧都包含一个指向运行时常量池（<strong>1.7之前在方法区中</strong>，后面介绍）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。（接下的文章将会讲解什么是<strong>直接引用，什么是间接引用</strong>）</li><li>方法返回地址<br> 当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。<br>方法退出的过程实际上等同于把当前栈帧出站，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。</li></ul><h3 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h3><blockquote><p>作用和虚拟机栈非常相似，区别：<br>　虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务<br>　JVM规范没有强制规定本地方法栈中的方法使用的语言、使用方式、数据结构，所以具体JVM不同实现。 有的虚拟机如HotSpot虚拟机直接把虚拟机栈和本地方法栈合二为一了。</p></blockquote><h3 id="java堆（Java-Heap）"><a href="#java堆（Java-Heap）" class="headerlink" title="java堆（Java Heap）"></a>java堆（Java Heap）</h3><p>Java Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。<br>根据Java虚拟机规范的规定，Java堆可以处在物理上不连续的内存空间 、中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。  </p><h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>  方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区域又被称为“永久代”，<strong>但这仅仅对于Sun HotSpot来讲</strong>，JRockit和IBM J9虚拟机中并不存在永久代的概念。Java虚拟机规范把方法区描述为Java堆的一个逻辑部分，而且它和Java Heap一样不需要连续的内存，可以选择固定大小或可扩展，另外，虚拟机规范允许该区域可以选择不实现垃圾回收。相对而言，垃圾收集行为在这个区域比较少出现。该区域的内存回收目标主要针是对废弃常量的和无用类的回收。<strong>运行时常量池是方法区的一部分（1.7以后的版本把它放在了堆内存中</strong>），Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池（Class文件常量池）</strong>，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中的常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的是String类的intern（）方法。<br>   根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><blockquote><p>常量池之中主要存放两大类常量：<br>    1).字面量: 比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等<br>    2).符号引用: 属于编译原理方面的概念，包括了下面三类常量:<br>      ①.类和接口的全限定名<br>      ②.字段的名称和描述符<br>      ③.方法的名称和描述符  </p></blockquote><h3 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，它直接从操作系统中分配，因此不受Java堆大小的限制，但是会受到本机总内存的大小及处理器寻址空间的限制，因此它也可能导致OutOfMemoryError异常出现。在JDK1.4中新引入了NIO机制，它是一种基于通道与缓冲区的新I/O方式，可以直接从操作系统中分配直接内存，即在堆外分配内存，这样能在一些场景中提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><h3 id="对象实例化分析"><a href="#对象实例化分析" class="headerlink" title="对象实例化分析"></a>对象实例化分析</h3><p>  对内存分配情况分析最常见的示例便是对象实例化: Object obj = new Object();<br>  这段代码的执行会涉及java栈、Java堆、方法区三个最重要的内存区域。假设该语句出现在方法体中，及时对JVM虚拟机不了解的Java使用这，应该也知道obj会作为引用类型（reference）的数据保存在Java栈的本地变量表中，而会在Java堆中保存该引用的实例化对象，但可能并不知道，Java堆中还必须包含能查找到此对象类型数据的地址信息（如对象类型、父类、实现的接口、方法等），这些类型数据则保存在方法区中。<br>    另外，由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同。<br>    主流的访问方式有两种：使用句柄池和直接使用指针。<br>    a. 通过句柄池访问对象<br>    如果使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据的具体各自的地址信息。如图1<br>    <img src="句柄访问.png" alt="虚拟机"><br>    b.直接指针访问<br>    如果使用直接指针访问的话，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如图所示<br>    <img src="指针访问.png" alt="虚拟机"><br> 这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。<br>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问的在Java中非常频繁，因此这类开销积小成多也是一项非常可观的执行成本。从上一部分讲解的对象内存布局可以看出，就虚拟机HotSpot而言，它是使用第二种方式进行对象访问，但在整个软件开发的范围来看，各种语言、框架中使用句柄来访问的情况也十分常见。      </p><h3 id="虚拟机对象的创建"><a href="#虚拟机对象的创建" class="headerlink" title="虚拟机对象的创建"></a>虚拟机对象的创建</h3><p>　Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常（例外：克隆、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（本文中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？<br>　虚拟机遇到一条new指令时，<br>　1).首先检验：<br>　　a.检查这个指令的参数是否能在常量池中定位到一个类的符号引用<br>　　b.并且检查这个符号引用代表的类是否已被加载、解析和初始化过的。<br>　　如果没有，那必须先执行相应的类加载过程。<br>　2).<strong>在类加载查通过后，接下来虚拟机将为新生对象分配内存</strong>。 准备阶段<br>　　对象所需内存的大小在类加载完成后便可完全确定（如何确定在下一节对象内存布局时再详细讲解），为对象分配空间的任务具体便等同于一块确定大小的内存从Java堆中划分出来，怎么划呢？<br>　　a.假设Java堆中内存是<strong>绝对规整的</strong>，所有用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“<strong>指针碰撞</strong>”（Bump The Pointer）。<br>　　b.如果Java堆中的<strong>内存并不是规整</strong>的，已被使用的内存和空闲的内存相互交错，那就没有办法简单的进行<strong>指针碰撞</strong>了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“<strong>空闲列表</strong>”（Free List）。<br>　　选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有<strong>压缩整理功能</strong>决定。<br>　　因此在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，就通常采用空闲列表。<br>　3).考虑并发情况下<strong>线程安全</strong>问题<br>　　除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存。<br>　　解决这个问题有两个方案，<br>　　a.一种是对分配内存空间的动作进行同步——实际上虚拟机是采用<strong>CAS</strong>配上失败重试的方式保证更新操作的原子性；<br>　　b.另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲</strong>，（TLAB ，Thread Local Allocation Buffer）。<br>　　哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完，分配新的TLAB时才需要同步锁定。虚拟机是否使用TLAB，可以通过 <strong>-XX:+/-UseTLAB</strong> 参数来设定。<br>　4).内存空间初始化为0 对应类加载的初始化<br>　　内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB的话，这一个工作也可以提前至TLAB分配时进行。<strong>这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值</strong>。　<br>　5).对象头的设置<br>　　接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内容，在下一节再详细介绍。 　<br>　6)<strong>.执行init()方法</strong><br>　　在上面工作都完成之后，在虚拟机的视角来看，一个新的对象已经产生了。但是在Java程序的视角看来，对象创建才刚刚开始——&lt; init&gt;方法还没有执行，所有的字段都为零呢。所以一般来说（由字节码中是否跟随有invokespecial指令所决定），<strong>new指令之后会接着就是执行&lt; init&gt;方法，把对象按照程序员的意愿进行初始化。</strong><br>　　这样一个真正可用的对象才算完全产生出来。</p><h3 id="内存泄露和内存溢出的区别："><a href="#内存泄露和内存溢出的区别：" class="headerlink" title="内存泄露和内存溢出的区别："></a>内存泄露和内存溢出的区别：</h3><p> 内存泄露是值分配出去的内存没有被回收回来，由于失去了对该内存区域的控制，因而造成了资源的浪费，java中一般不会产生内存泄露，以为有垃圾回收器自动回收垃圾，但是这也不绝对，当我们new对象，并保存了其引用，但是后面一直没有用它，而垃圾回收器又不会去回收它，这便造成内存泄露。<br> 内存溢出是值程序所需要的内存超出了系统所能分配的内存（包括动态扩展）的上限。</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><blockquote><p>兰亭风雨的专栏: <a href="http://blog.csdn.net/ns_code/article/details/17565503" target="_blank" rel="noopener">http://blog.csdn.net/ns_code/article/details/17565503</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文是基于周志明的《深入理解Java虚拟机》&lt;br&gt;java与C++支架有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM,内存区域，内存溢出异常" scheme="http://yoursite.com/tags/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%EF%BC%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
</feed>

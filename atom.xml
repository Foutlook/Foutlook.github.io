<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Foutin</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-03T14:46:46.045Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Foutlook</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>害怕</title>
    <link href="http://yoursite.com/2018/08/31/%E5%AE%B3%E6%80%95/"/>
    <id>http://yoursite.com/2018/08/31/害怕/</id>
    <published>2018-08-31T01:00:00.000Z</published>
    <updated>2018-09-03T14:46:46.045Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>抬起头，又底下</p></blockquote><p>当我胆小怕事的时候，我总是问自己，你到底在害怕什么？<br>以前的雄心壮志呢？以前的为所谓呢？被狗吃了？</p><p>你所谓的勇敢就是这？</p><p>你到底在害怕什么？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;抬起头，又底下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当我胆小怕事的时候，我总是问自己，你到底在害怕什么？&lt;br&gt;以前的雄心壮志呢？以前的为所谓呢？被狗吃了？&lt;/p&gt;
&lt;p&gt;你所谓的勇敢就是这？&lt;/p&gt;
&lt;p&gt;你到底在害怕什么？&lt;/p&gt;

      
    
    </summary>
    
      <category term="所思" scheme="http://yoursite.com/categories/%E6%89%80%E6%80%9D/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JMM和volatile与synchronized</title>
    <link href="http://yoursite.com/2018/08/26/JMM%E5%92%8Cvolatile%E4%B8%8Esynchronized/"/>
    <id>http://yoursite.com/2018/08/26/JMM和volatile与synchronized/</id>
    <published>2018-08-26T04:00:00.000Z</published>
    <updated>2018-08-26T04:09:34.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;
      
    
    </summary>
    
      <category term="线程" scheme="http://yoursite.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JMM，volatile，synchronized" scheme="http://yoursite.com/tags/JMM%EF%BC%8Cvolatile%EF%BC%8Csynchronized/"/>
    
  </entry>
  
  <entry>
    <title>初次提交代码总结</title>
    <link href="http://yoursite.com/2018/08/26/%E5%88%9D%E6%AC%A1%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/26/初次提交代码总结/</id>
    <published>2018-08-26T01:00:00.000Z</published>
    <updated>2018-08-26T13:07:04.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>自己空白的还有很多，记录一下本周所感所想</p></blockquote><p>本周算是经历了第一次的merge request，虽然是在我师傅写好的代码下填补一些小功能，不过感觉学到的东西还是挺多的。无论是对开发中的细节，还是良好习惯的培养都让我受益颇多。</p><hr><h2 id="从前"><a href="#从前" class="headerlink" title="从前"></a>从前</h2><p>前面的一个月基本上都是在学习zstack的基本知识，架构还有里面的实现原理。这次也是我真正去读别人的代码，跟着别人代码的思想去理解整个结构，去添加一些需求。可以说这周的开发过程也是对我一次深刻的提醒。<br>意识到其实在以前学习zstack的时候许多重要的点并没有深刻的去理解，以前的心态就是能看懂就行，不需要问原因和原理，所以遇到一些不是特别清晰的并没有过于的深刻探究其中主要原理。像Inner Msg在zstack中处理的过程，CloudBus怎么处理去拦截和收集这些消息的，FlowChain的调用过程，回调实现的方式，一些类的继承实现有的时候居然不知道为什么。以前在学校的时候就接触过回调函数这方面的知识点，也从未认真看过。这次要不是我师傅的指点，我恐怕陷得很深。</p><hr><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>本周主要是对审计模块一些简单功能的添加，实现用户自定义operation name，并且添加一些基本的测试。这两个功能前前后后花了一周的时间。接到需求的第一天，我大概浏览了各个问题的要求，然后开始添加自己的代码，在做的过程中，我发现我面临许多的问题，我对问题并不是很理解。比如添加用户自定义operation name，我理解的就是把某一个属性写到配置文件中，加载新来而已。还有添加inner  msg的case，我以为Inner Msg实现审计模块会有人帮我写好。一切都源于对问题的不清晰然后就开始干，第一天就踩了不少的坑。辛亏我师父救场，问我有哪些不懂的问题，不然我还在按照自己的思路在写。还有后面看代码十分的不认真，有一个问题是set集合的泛型问题，在创建HashSet集合的时候，泛型放在前面和后面有着不同的意义。<br>其实开始的我以为这部分功能最多三天就搞完了，最终还是在我师父帮助下，五天勉勉强强的完成。我总结这次主要原因如下：</p><ol><li>zstack部分功能理解不深入</li><li>没有搞清楚需求是怎么样的就急于入手</li><li>不善于提问，总认为自己可以解决，思维逻辑混乱</li><li>过于浮躁，不认真</li></ol><hr><h2 id="以后"><a href="#以后" class="headerlink" title="以后"></a>以后</h2><p>踩坑真的是能让人进步的过程，如果不真的接触代码，真的很少能够意识到那么多的问题。<br><strong>现阶段我不足的部分：</strong></p><ol><li>回调方面的部分，我总是感觉有些地方不是特别理解，但是又说不上来。</li><li>FlowChain部分也是有点模糊</li><li>… 等待发现</li></ol><p>也许这几部分也要通过写代码的方式来锻炼，来理解。后面的工作我会尽力去做。不能解决的问题，我会尽量的问我的师傅，不会自己再闷头苦想（虽然自己是应届生，不过遇到弱智的问题，感觉还是挺丢人的）。</p><p>后面再写一段代码，我会把我学到的zstack知识尽量做一个总结，写几篇博客，把zstack的原理自己总结一下。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>跟着QB团队学到不少的东西，有着中国第一的PM孙总，zstack的高级开发者和精通Java的我师傅，python和java都精通的伟嘉，打得过PM的高级开发工程师强哥，受益匪浅。比在上海那三个月的实习学到的多得多。不过感觉赶上他们的步伐还是好难。这段时间也听到了很多陌生的词，像比特币，区域块，股票方面的知识还有他们对中国经济和政府投资的分析。我有的时候真的明天为什么有些人可以赚那么多钱了。<br>很感谢我师傅的指导，很有耐心，知道我缺什么，然后认真提出方法来解决。还有我师傅认真起来真的很吓人。<br>最后：</p><blockquote><p>不要把不会当成一个负担，不会就问。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;自己空白的还有很多，记录一下本周所感所想&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本周算是经历了第一次的merg
      
    
    </summary>
    
      <category term="所思" scheme="http://yoursite.com/categories/%E6%89%80%E6%80%9D/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://yoursite.com/2018/08/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/08/19/线程池/</id>
    <published>2018-08-19T01:00:00.000Z</published>
    <updated>2018-08-26T04:09:18.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;
      
    
    </summary>
    
      <category term="线程" scheme="http://yoursite.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://yoursite.com/2018/08/13/%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/13/线程/</id>
    <published>2018-08-13T01:00:00.000Z</published>
    <updated>2018-08-26T11:23:17.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>深感自己的能力的不足，此处仅仅是对知识的记录和总结，许多地方都是借鉴他人的语句</p></blockquote><hr><h2 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h2><p><strong>想要了解线程，必须首先知道进程，并知道他与线程的区别是什么？</strong></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong>进程</strong></h3><p>通常，我们把一个程序的执行称为一个进程。反过来讲，进程用于描述程序的执行过程。因此，程序和进程是一对概念，它们分別描述了一个程序的静态和动态特征：除此之外，进程还操作系统进行资源分配的一个基本单位。</p><h4 id="进程的衍生"><a href="#进程的衍生" class="headerlink" title="进程的衍生"></a><strong>进程的衍生</strong></h4><p>进程使用<code>fork</code>（）系统调用来创建。父进程调用<code>fork</code>创建子进程。每个子进程都是源自它的父进程的一个副本，它会获得父进程的数据段、堆和栈的副本，并与父进程共享代码段。每一份副本都是独立的，子进程对属于它的副本的修改对其父进程和兄弟进程（同父进程）都是不可见的，反之亦然。全盘复制父进程的数据是一种相当低效的做法。 Linux操作系统内核使用写时复制（Copy on Write,常简称为COW，<strong>也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</strong>)等技术来提高进程创建的效率。当然，刚创建的子进程也可以通过系统调用exec把一个新的程序加载到自己的内存中，而原先在内存中的数据段、堆、栈以及代码段就会被替换掉，在这之后，子进程执行的就会是那个刚刚加载进来的新程序（意思就是当传入的参数或者变量不同的时候，子进程就相当于在做自己的事情）。</p><p><strong>父进程被如果优先于子进程结束，那么子进程就会被原来父进程的父进程“收养”（也就是子进程的爷爷）。</strong></p><p>为了管理进程，内核必须对每个进程的数据和行为进行详细的记录，包括进程的优先级、状态、虚拟地址范围以及各种访问权限等等。更具体地说，这些信息都会被记在每个进程的进程描述符中。进程描述符并不是一个简单的符号，而是一个非常复杂的数据结构。保存在进程描述符中的进程ID (常称为PID )是进程在操作系统中的唯一标识，其中<strong>进程ID为1的进程就是之前提到的内核启动进程</strong>。进程id是一个非负整数且总是顺序的编号，新创建的进程ID总是前一个进程ID递增的结果。此外，进程ID也可以重复使用。当进程ID达到其最大限值时，内核会从头开始查找闲置的进程ID并使用M先找到的那一个作为新进程的ID。另外，进程描述符中还会包含当前进程的父进程的ID (常称为PPID )。</p><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><p>进程通信叫做IPC(Inter-Process Communication)，Linux中通信的方式大致可分成三种：</p><ol><li>基于通信的IPC</li><li>基于信号的IPC</li><li>基于同步的IPC</li></ol><p><strong>通信IPC</strong></p><ul><li>以数据为传送手段的IPC</li></ul><blockquote><p>管道(pipe)：用于传输字节流<br>消息队列(message queue)：用来传输结构化的对象</p></blockquote><ul><li>以共享内存为手段的IPC</li></ul><blockquote><p>共享内存区（share memory)：最快的IPC方法</p></blockquote><p> <strong>信号IPC</strong></p><blockquote><p>操作系统的信号（signal）机制：唯一一种异步IPC方法。通过kill -l查看。</p></blockquote><p><strong>同步IPC</strong></p><blockquote><p>信号量（semaphore）</p></blockquote><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程可以视为进程中的控制流。一个进程至少包含一个线程，因为其他至少会有一个控制流持续运行。因而，<strong>一个进程的第一个线程会随着这个进程的启动而创建</strong>，这个线程被称为该进程的主线程。当然，一个进程可以包含多个线程。这些线程都是由当前线程中已经存在的线程创建出来的，创建的方法就是系统调用（pthread_create）。<strong>拥有多个线程的进程可以并发执行多个任务，并且即时某个或某些任务被阻塞，也不会影响其他任务执行，这可以大大改善程序的响应时间和吞吐量</strong>。另一方面，线程不可能独立于进程存在。它的生命周期不可能逾越所属进程的生命周期。</p><p>一个进程中的所有线程都拥有自己线程栈，并以此存储自己的私有数据。这些线程的线程栈都包含在其所属进程的虚拟内存地址中。不过要注意，一个进程中的很多资源都会被其中的所有线程共享，这些被线程共享的资源包含当前进程所持有文件描述符，等等。正因为如此，同一个进程的多个线程运行的一定是同一个程序，只不过具体的控制流程的执行函数可能有所不同。在同一个进程的多个线程之间共享数据也是一件非常轻松和自然的事情。另外，创建一个新线程，也不会像创建一个新进程那样耗时费力，因为在其所属进程的虚拟内存地址中存储的代码、数据和资源都不需要被复制。</p><p>和进程一样，每个线程都有自己的ID（由内核分配），叫做线程ID或者TID。但是在操作系统范围内不唯一，在所属进程的范围内唯一。</p><hr><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><h3 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h3><p>在线程的生命周期中，它要经过<strong>新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态</strong>。尤其是当线程启动以后，它不可能一直”霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换</p><p><img src="./attachments/1535250738191.drawio.html" alt="Diagram"></p><p><img src="生命周期.jpg" alt="生命周期"></p><ol><li>新建状态，当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值</li><li>就绪状态，当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行</li><li>运行状态，如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态</li><li>阻塞状态，当处于运行状态的线程失去所占用资源之后，便进入阻塞状态</li><li>死亡状态，线程终止</li></ol><h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>线程可以通过多种方式来终结同一个进程中的其他线程。其他一种方式就是调用系统调用pthread_cancel，其作用是取消掉给定线程ID代表的那个线程。更确切地讲，它会向目标线程发送一个请求，要求它立刻终止执行。但是该函数只是发送请求并即可返回。但是，该函数只是发送请求并立刻返回，而不会等待目标线程对该请求做出响应。至于目标线程什么时候对此做出线程、怎么样的响应，则取决与另外的因素（比如线程目标的取消状态及类型）。在默认情况下，目标线程总是会接受线程取消请求，不过等到时机成熟（执行到某个取消点）的时候，目标线程才会响应线程的取消请求。</p><h3 id="连接已终止的线程"><a href="#连接已终止的线程" class="headerlink" title="连接已终止的线程"></a>连接已终止的线程</h3><p>此操作由系统调用pthread_join来执行，该函数会一直等待与给定的线程ID对应的那个线程终止，并把线程执行的pthread_create函数的返回值告知调用线程。如果目标线程已经处于终止状态，那么该函数会立即返回。这就像是把调用线程放置在了目标线程的后面，当目标线程把线程控制权交出时，调用线程会接过流程控制权并继续执行pthread_join函数调用之后的代码。这也把这一操作称为连接的缘由之一。实际上，如果一个线程可被连接，那么在它终止之前就必须连接，否则就会变成一个僵尸线程。僵尸线程不但会导致系统资源浪费，还会无意义减少其进程的可创建线程数量。</p><h3 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h3><p>将一个线程分离后那么它将变得不可连接。而在默认情况下，一个线程总是可以被连接的。分离操作的另一个作用是让操作系统内核在目标线程终止时自行进行清理和销毁工作。注意，分离操作是不可逆的。也就是说，我们无法使一个不可连接的线程变回可连接的状态。不过，对于一个已处于分离状态的线程，执行终止操作仍然会起作用。分离操作由系统调用pthread_detach来执行，它接受一个代表了线程ID的参数值。</p><blockquote><p>一个线程对自身也可以进行两种控制：<strong>终止和分离</strong>。线程终止自身的方式有很多种。在线程执行的start函数中执行return语句，会使该线程随着start函数的结束而终止。需要注意的是，如果在主线程中执行了return语句，那么当前进程中的所有线程都会终止。另外，在任意线程中调用系统调用exit也会达到这种效果。还有一种终止自身的方式就是显示调用pthread_exit。而分离pthread_detach函数则是传入自己的TID。</p></blockquote><hr><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>主线程在其所属进程启动时创建。其他线程可以通过别的线程用pthread_create来创建——要传入新线程将要执行的函数以及传入该函数的参数值。在创建成功的时候，该函数会返回线程的TID。</p><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><p>线程创建的方式有三种，在我至今使用的经历中从来没有使用到过第三种方法：所以今天只介绍两种，第一种是继承<code>Thread</code>类，第二种是实现<code>Runnable</code>接口。两种方法的优缺点就和继承和接口优缺点有关了，其实底层都是一样的。<br>具体的代码这里不再进行详述，基本上都是见过的。</p><hr><h2 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h2><p>在多个线程之间交换线程是非常简单和自然的事，而在多个进程之间只能通过一些额外的手段（比如管道、消息队列、信号量和共享内存区）传递数据。显然，使用这些额外手段会增加开发成本。不过，<strong>线程间交换数据虽然简单但却由于可能发生竞态条件而不得不使用一些同步工具（比如互斥量和条件变量）加以保护</strong>。这些与业务逻辑无关的代码会增加程序的复杂度，尤其在使用不当的情况下还会引起灾难。</p><blockquote><p>互斥量可以理解为我们常见的锁。而条件变量所做的就是保证线程间共享的数据状态改变时通知到其他因此而被阻塞的线程。条件变量总是与互斥量组合使用。当线程成功锁定互斥量并访问到共享数据时，共享数据的状态并不一定满足它的要求。</p></blockquote><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>使用synchronize的可以加载方法，代码块，类上，以此实现多线同步。</p><ol><li>同步代码块：<br>即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">代码如： </span><br><span class="line"><span class="keyword">synchronized</span>(object)&#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注：同步是一种高开销的操作，因此应该尽量减少同步的内容。 </span><br><span class="line">通常没有必要同步整个方法，使用<span class="keyword">synchronized</span>代码块同步关键代码即可。</span><br></pre></td></tr></table></figure><ol start="2"><li>同步方法<br>即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码如： </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类</p><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>使用volatile修饰共享变量可以实现线程同步。<strong>其中的原理与synchronized区别会在JMM文章中讲到。</strong><br>a.volatile关键字为域变量的访问提供了一种免锁机制，<br>b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，<br>c.因此每次使用该域就要重新计算，而不是使用寄存器中的值<br>d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量</p><h4 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h4><p>ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> account = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">//需要声明这个锁</span></span><br><span class="line">            <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> account;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里不再需要synchronized </span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    account += money;</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        ｝</span><br></pre></td></tr></table></figure><p>ReenreantLock类的常用方法有：</p><blockquote><p> ReentrantLock() : 创建一个ReentrantLock实例<br> lock() : 获得锁<br> unlock() : 释放锁</p></blockquote><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>与互斥锁不同，条件变量是用来等待而不是用来上锁的。<strong>条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用</strong>。条件变量分为两部分:<code>条件和变量</code>。条件本身是由互斥量保护的。线程在改变条件状态前先要锁住互斥量。条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。条件的检测是在<code>互斥锁</code>的保护下进行的。如果一个条件为假，一个线程自动阻塞，并释放等待状态改变的<code>互斥锁</code>。如果另一个线程改变了条件，它发信号给关联的条件变量，唤醒一个或多个等待它的线程，重新获得<code>互斥锁</code>，重新评价条件。<strong>如果两进程共享可读写的内存，条件变量可以被用来实现这两进程间的线程同步。</strong></p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，<br>副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。<br>ThreadLocal 类的常用方法</p><blockquote><p>ThreadLocal() : 创建一个线程本地变量  get() : 返回此线程局部变量的当前线程副本中的值<br>initialValue() : 返回此线程局部变量的当前线程的”初始值”<br>set(T value) :将此线程局部变量的当前线程副本中的值设置为value</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">           <span class="comment">//使用ThreadLocal类管理共享变量account</span></span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; account = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">               account.set(account.get()+money);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAccount</span><span class="params">()</span></span>&#123;</span><br><span class="line">               <span class="keyword">return</span> account.get();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>ThreadLocal下面单独讲</strong></p><hr><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>一句话概括：Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。所以ThreadLocal的应用场合，最适合的是按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。</p><p>数据隔离的秘诀其实是这样的，Thread有个TheadLocalMap类型的属性，叫做threadLocals，该属性用来保存该线程本地变量。这样每个线程都有自己的数据，就做到了不同线程间数据的隔离，保证了数据安全。</p><p>有点累这部分暂时留着：有问题看这篇博客：<br><a href="https://blog.csdn.net/lufeng20/article/details/24314381" target="_blank" rel="noopener">https://blog.csdn.net/lufeng20/article/details/24314381</a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>并发（Concurrency）和并行（Parallelism）</strong></p><blockquote><p>并发和并行往往被人所混淆。它们都可以表示两个或多个任务一起执行，但是偏重点有些不同。并发偏重于多个任务交替执行，而多个任务有可能还是串行。而并行则是真正意义上的“同时执行”。</p><p>严格来说，<strong>并行的多个任务是真实的同时执行</strong>，<strong>而对并发来说，这个过程这是交替的，一会儿运行任务A一会儿执行任务B，系统会不停地在两者间切换</strong>。但对于外部观察者来说，即使多个任务之间是串行并发的，也会造成多任务间是并行执行的错觉。</p></blockquote><p><strong>临界区</strong></p><blockquote><p>临界区(criticalsection)用来表示一种公共资源或者共享数据，可以被多个线程使用。但是每一次，只有一个线程可以使它，一旦临界区资源被占用，其他线程要想使用资源，就必须等待，即串行化访问或执行。</p></blockquote><p><strong>死锁（DeadLock）、饥饿（Starvation）和活锁（Livelock）</strong></p><blockquote><p>死锁、饥饿和活锁都属于多线程的活跃性问题，如果发生上述情况，那么相关线程可能就不再活跃，也就是说它可能很难继续往下执行了。<br>死锁应该是最糟糕的一种情况了，虽然别的情况也没有好到哪儿去。</p><ul><li>死锁：多个线程互相等待多方释放资源而一直没有执行。</li><li>饥饿：一个或多个线程因为种种原因无法获取所得的需要资源，导致一直无法执行。导致的原因往往是当前线程优先级不高导致没有资源，或某线程一直占着关键资源不放。</li><li>活锁：多个线程都释放资源给别的线程使用，导致没有线程拿到资源而正常执行。</li></ul></blockquote><p><strong>阻塞和非阻塞</strong></p><blockquote><p>描述的是用户线程调用内核 I/O 操作的方式：</p><ul><li>阻塞（Blocking）是指 I/O 操作需要彻底完成后才返回到用户空间；</li><li>非阻塞（Non-Blocking）是指 I/O 操作被调用后立即返回给用户一个状态值，无需等到 I/O 操作彻底完成。</li></ul><p>一个 I/O 操作其实分成了两个步骤：</p><ol><li>发起 I/O 请求</li><li>实际的 I/O 操作。</li></ol><p><strong>阻塞 I/O 和非阻塞 I/O 的区别在于第一步，发起 I/O 请求是否会被阻塞</strong>。如果阻塞直到完成那么就是传统的阻塞 I/O，如果不阻塞，那么就是非阻塞 I/O 。 <strong>同步 I/O 和异步 I/O 的区别就在于第二个步骤是否阻塞</strong>，如果实际的 I/O 读写阻塞请求进程，那么就是同步 I/O 。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;深感自己的能力的不足，此处仅仅是对知识的记录和总结，许多地方都是借鉴他人的语句&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="线程" scheme="http://yoursite.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务--原子性</title>
    <link href="http://yoursite.com/2018/08/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1-%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    <id>http://yoursite.com/2018/08/12/数据库事务-原子性/</id>
    <published>2018-08-12T01:00:00.000Z</published>
    <updated>2018-08-12T16:17:15.188Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据库看似简单，却是个十分复杂的东西</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>ACID：</strong> 指数据库事务正确执行的四个基本要素的缩写。包含：<strong>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</strong>。一个支持事务（Transaction）的数据库，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。 </p><p><strong>如果没有没有正确执行便会出现以下问题：</strong><br>1，脏读（dirtyRead）<br>脏读是指的一个事物正在访问数据，并且对数据进行了修改，而且这种修改还没有提交到数据库中，这时，另一个事物也访问这个数据<br>，然后使用了这个数据。因为这个数据还没有提交数据，那么另外一个事物读到的这个数据就是脏数据。</p><p>2，不可重复读<br>不可重复读，就是在同一事务中，两次读取同一数据（同一主键），得到内容不同。不可重复读和脏读的区别是，不可重复读读取到的都是已经提交的数据，而不是脏数据。</p><p>3，虚读(幻读)<br>幻读指的是，同一事务中，用同样的操作读取两次，得到的记录数不相同。幻读和不可重复读都是读取到了另一条已经提交的事物，这一点和脏读不同。<br>看似幻读和不可重复读都是一样的，但是区别在于不可重复读针对的是同一个主键的数据。而幻读针对的是一批数据两次读取中，有新增或者减少。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>了解了数据库的四大特性，那么今天就来讲讲数据库特性之一 —–<strong>原子性</strong><br>首先：原子性一说大家都明白，那你能说说在<strong>执行的操作过程中，如果还没做完系统就崩溃了，或者断电了，你怎么办啊？ 你怎么保证原子性？如果我还没做完，系统就崩溃了，那系统重启以后我就得做恢复操作？</strong></p><p>下面我们就来讲讲这个问题的答案。<br>首先以<strong>旺财有200块钱， 小强有50 块钱，现在旺财要给小强转账，假设转100块</strong>为例。如果按照事务完整进行则会有一下四步：<br>(1)  开始事务 T1 （假设T1是个事务的内部编号）<br>(2)  旺财余额 = 旺财余额 -100<br>(3)  小强余额 = 小强余额 + 100<br>(4)  提交事务 T1<br>我们知道所有的计算操作都是在内存中进行的，这个时候被计算的数据首先放入缓冲区中：如下图<br><img src="原子性.jpg" alt="原子"><br>因为硬盘的速度太慢，所以不会经常性的操作硬盘，而是把数据放入到缓冲区中，然后一次性保存到硬盘中。</p><h2 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h2><p>这里先假定数据缓冲区能和硬盘的数据文件同步。<br>问题：旺财在给小强转账， 第二步执行完了，旺财的余额变成了100块 （200-100）， 假设已经写入了硬盘文件， 现在断电了， 小强的余额有没有加上，系统的钱白白消失了100块， 数据已经不一致了，  你怎么办？<br>而这个叫做Undo的日志文件，就是为了解决这个问题的。<br><strong>分析：</strong><br>按照上面的情况，会在日志文件中记录下事务开始之前他俩账号余额：</p><blockquote><p>[事务T1,  旺财原有余额 ， 200]<br>   [事务T1, 小强原有余额， 50 ] </p></blockquote><p>如果事务执行到一半，就断电了，那数据库重启以后我就根据undo的日志文件来恢复。</p><p><strong>问题：恢复数据的时候， 那你怎么才能知道一个事务没有完成呢？</strong></p><blockquote><p>[开始事务 T1]<br>   [事务T1, 旺财原有余额，200]<br>    [事务T1, 小强原有余额，50]<br>    [提交事务 T1]</p></blockquote><p>Undo日志文件中不仅仅只有余额， 事务的开始和结束也会记录，如果我在日志文件中看到了<strong>提交事务 T1</strong>, 或者 <strong>回滚事务 T1</strong>, 我就知道这个事务已经结束，不用再去理会它了， 更不用去恢复。 如果我只看到 <strong>开始事务 T1</strong>, 而找不到提交或回滚，那我就得恢复。比如下面这个：</p><blockquote><p>[开始事务 T1]<br>   [事务T1, 旺财原有余额，200]<br>   [事务T1, 小强原有余额，50]</p></blockquote><p>如果已经恢复了，就在日志文件中加上一行 <strong>回滚事务 T1</strong> ， 这样下一次恢复我就不用再考虑T1这个事务了。</p><p><strong>问题：那我们应该什么时候记录Undo日志呢？什么时候把Undo日志写入文件呢？</strong></p><p>把日志记录也放到了内存的Undo日志缓冲区，伺机写入硬盘。<br><img src="日志.jpg" alt="日志"></p><p>我们来看看下面的分析：</p><ol><li>如果系统在第4步和第5步之间崩溃，旺财的余额写入了硬盘，但是小强的还没写入， 那Undo日志看起来是这样的：</li></ol><blockquote><p>[开始事务 T1]<br>   [事务T1, 旺财原有余额，200]</p></blockquote><p>由于找不到事务结束的日志， 你会进行恢复操作， 把旺财的原有余额给恢复了。</p><ol start="2"><li>如果是在第7步和第8步之间系统崩溃，旺财和小强的最新余额都写入了硬盘，但是没有提交事务， 那Undo日志看起来是这样的：</li></ol><blockquote><p>[开始事务 T1]<br>  [事务T1, 旺财原有余额，200]<br>  [事务T1, 小强原有余额，50]</p></blockquote><p>由于没有事务结束的日志，你也需要进行恢复，把旺财和小强的原有余额恢复成200和50 ”</p><ol start="3"><li>如果是在第8步和第9步之间系统崩溃， 旺财和小强的最新余额都写入了硬盘， 也提交了事务， 但是提交事务的操作没有写入Undo 日志， 所以Undo日志还是这样：</li></ol><blockquote><p>[开始事务 T1]<br>   [事务T1, 旺财原有余额，200]<br>   [事务T1, 小强原有余额，50]</p></blockquote><p>由于没有事务结束的日志，你还得需要进行恢复，把旺财和小强的原有余额恢复成200和50。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这里面是有规律的，如果实现了这个规律便可以解决所有的问题：</p><ol><li><p>在你把最新余额写入硬盘之前， <strong>一定要先把相关的Undo日志记录写入硬盘</strong>。 例如 <strong>[事务T1, 旺财原有余额，200]</strong> 一定要在旺财的新余额=100写入硬盘之前写入。</p></li><li><p><strong>[提交事务 T1]</strong> 这样的<strong>Undo日志记录一定要在所有的新余额写入硬盘之后再写入</strong>。  有了这两条的保证，我就可以高枕无忧了！， 比如说，换个操作次序也没有问题：<br><img src="日志2.jpg" alt="日志"></p></li></ol><h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665514001&amp;idx=1&amp;sn=17b72c3e69db6c4277e3045c699b7b6b&amp;chksm=80d67c52b7a1f5446020826841869221873f4578524181384592839d19c4810dc68807117e13&amp;mpshare=1&amp;scene=1&amp;srcid=0311ddHdl0tOCk3XkUy6l8lA#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665514001&amp;idx=1&amp;sn=17b72c3e69db6c4277e3045c699b7b6b&amp;chksm=80d67c52b7a1f5446020826841869221873f4578524181384592839d19c4810dc68807117e13&amp;mpshare=1&amp;scene=1&amp;srcid=0311ddHdl0tOCk3XkUy6l8lA#rd</a></p><blockquote><p>我所向往的不过是如此简单而已</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;数据库看似简单，却是个十分复杂的东西&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;ACID：&lt;/st
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库，事务" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>策略模式和观察者模式</title>
    <link href="http://yoursite.com/2018/07/31/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/07/31/策略模式和观察者模式/</id>
    <published>2018-07-31T14:09:00.000Z</published>
    <updated>2018-08-12T14:07:44.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>哪里会有人喜欢孤独，不过是不喜欢失望罢了。</p></blockquote><p>在学习Zstack时候看到了系统中多处使用策略模式和观察者模式，学习发现这两种模式在开发中经常用到，故在此记录下来。</p><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</strong><br>策略模式是一种对象行为型模式。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以<strong>根据环境或者条件的不同选择不同的策略来完成该项任务</strong>。</li><li>在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。</li><li>在软件系统中，<strong>有许多算法可以实现某一功能</strong>，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。</li></ol><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="策略模式.jpg" alt="策略"><br>对照类图可以看到，<strong>策略模式</strong>与模版方法模式的区别仅仅是多了一个单独的<strong>封装类Context</strong>，它与模版方法模式的区别在于：在模版方法模式中，调用算法的主体在抽象的父类中，而在策略模式中，调用算法的主体则是封装到了封装类Context中，<strong>抽象策略Strategy一般是一个接口，目的只是为了定义规范</strong>，里面一般不包含逻辑。其实，这只是通用实现，而在实际编程中，因为各个具体策略实现类之间难免存在一些相同的逻辑，为了避免重复的代码，我们常常使用抽象类来担任Strategy的角色，在里面封装公共的代码。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><ol><li>创建一个接口</li></ol><p><strong>Strategy.java</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">   public int doOperation(int num1, int num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>创建实现接口的实体类</li></ol><p><strong>OperationAdd.java</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class OperationAdd implements Strategy&#123;</span><br><span class="line">   @Override</span><br><span class="line">   public int doOperation(int num1, int num2) &#123;</span><br><span class="line">      return num1 + num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>创建 Context 类</li></ol><p><strong>Context.java</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">   private Strategy strategy;</span><br><span class="line"> </span><br><span class="line">   public Context(Strategy strategy)&#123;</span><br><span class="line">      this.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public int executeStrategy(int num1, int num2)&#123;</span><br><span class="line">      return strategy.doOperation(num1, num2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出：创建Context时，传入不同的Strategy的子类会执行不同的功能方法。使用到java<strong>父类的引用指向子类对象</strong>。</p><h2 id="优缺点和注意事项"><a href="#优缺点和注意事项" class="headerlink" title="优缺点和注意事项"></a>优缺点和注意事项</h2><p>优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。<br>缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。</p><h2 id="Zstack中的体现"><a href="#Zstack中的体现" class="headerlink" title="Zstack中的体现"></a>Zstack中的体现</h2><p><img src="zstack中体现.jpg" alt="策略"><br>Zstack中充斥着大量的回调函数，如上图所示。CloudBusCallBack是一个接口，通过在方法中实现匿名类重写接口中定义的方法，方法中的功能可以根据上层类要实现的功能去灵活的定义。 这种方式就和传入一个子类对象一样，不过这个子类对象没有名字。因为Zstack所有功能的模块都是通过异步通信的，对策略模式了解可以有效的加深对整个Zstack的了解。</p><hr><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。<br><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p><h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ol><blockquote><p>注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p></blockquote><h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2><p>创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。<br><img src="观察者.jpg" alt="观察"></p><h2 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h2><p>观察者模式，我理解的就是<strong>观察者订阅被观察者的状态，当被观察者状态改变的时候会通知所有订阅的观察者的过程。</strong></p><ol><li>创建观察者接口</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Observer &#123;    </span><br><span class="line">    public abstract void update(String msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>观察者的实现类</li></ol><p>第一个观察者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class F_Observer extends Observer &#123;</span><br><span class="line">    public void update(String msg) &#123;</span><br><span class="line">        System.out.println(F_Observer.class.getName() + &quot; : &quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二个观察者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">S_Observer</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">void</span> update(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">        System.out.println(S_Observer.class.getName() + <span class="string">" : "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三个观察者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">T_Observer</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">void</span> update(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">        System.out.println(T_Observer.class.getName() + <span class="string">" : "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>被观察者</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;        </span><br><span class="line">    private List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();    <span class="comment">//状态改变    </span></span><br><span class="line">    public <span class="keyword">void</span> setMsg(<span class="built_in">String</span> msg) &#123;        </span><br><span class="line">        notifyAll(msg);    </span><br><span class="line">    &#125;   </span><br><span class="line">     <span class="comment">//订阅    </span></span><br><span class="line">    public <span class="keyword">void</span> addAttach(Observer observer) &#123;        </span><br><span class="line">        observers.add(observer);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//通知所有订阅的观察者    </span></span><br><span class="line">    private <span class="keyword">void</span> notifyAll(<span class="built_in">String</span> msg) &#123;        </span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;            </span><br><span class="line">            observer.update(msg);        </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>运行</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;    </span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;        </span><br><span class="line">        F_Observer fObserver = <span class="keyword">new</span> F_Observer();        </span><br><span class="line">        S_Observer sObserver = <span class="keyword">new</span> S_Observer();        </span><br><span class="line">        T_Observer tObserver = <span class="keyword">new</span> T_Observer();                </span><br><span class="line">        Subject subject = <span class="keyword">new</span> Subject();        </span><br><span class="line">        subject.addAttach(fObserver);        </span><br><span class="line">        subject.addAttach(sObserver);        </span><br><span class="line">        subject.addAttach(tObserver);                </span><br><span class="line">        subject.setMsg(<span class="string">"msg change"</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>从上面的代码中可以看出，当被观察者的行为改变的时候就可以通知观察者，观察者可以依据不同的变现做出不同的反应，<strong>我猜想：</strong>MQ有一种模式是消息订阅模式，其中必用到观察者模式，不过MQ使用的必然是异步的方式。</p><h2 id="Zstack中的体现-1"><a href="#Zstack中的体现-1" class="headerlink" title="Zstack中的体现"></a>Zstack中的体现</h2><p><strong>观察者模式</strong>在Zstack中的体现就要和<strong>Zstack的三驾马车（后面会讲到）</strong>联系到一起了。三驾马车分别对应着三层：<strong>应用层，业务层和领域层。</strong><br><strong>应用层（可以被调用的API）</strong>：就是界面定义的一些功能。<br><strong>业务层（一个Impl）</strong>：一个服务的入口，对功能的分发，不会处理底层很具体功能。<br><strong>领域层（base）</strong>：这层主要是一些行为的逻辑，对某一个功能具体的操作。</p><blockquote><p>我们知道各个层之间是需要<strong>通信</strong>的，那么层与层之间只能是单向的。上层可以直接使用或操作下层元素，方法是通过调用下层元素的公共接口，保持对下层元素的引用（至少是暂时的），以及采用常规的交互手段。而如果下层元素需要与上层元素通信，则需要采用另一种<strong>通信机制</strong>——比如<strong>回调或者Observers模式</strong>（在ZStack中即是ExtensionPoint）。</p></blockquote><p>这里以PrimaryStorageBase为例：在PrimaryStorageBase中，其中handle APIAttachPrimaryStorageToClusterMsg的地方会做事件发送：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extpEmitter.preAttach(self, msg.getClusterUuid());</span><br></pre></td></tr></table></figure><p>其会发送向：<br><img src="connectHook.jpg" alt="connect"><br>在抽象等级上，PrimaryStorageBase是比图中的这些Base高的。而<strong>这类具象Base可以使Message返回Success或者Fail使高层Base做出不同的决策</strong>。这里是通过回调函数的形式来对上层的Base进行通知的。具体对象的Base执行失败或者成功会回调上层的fail或者success，这样上层就知道下面的方法是否执行成功。因为系统中都是通过异步的方式来实现的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;哪里会有人喜欢孤独，不过是不喜欢失望罢了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在学习Zstack时候看到了
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，Java" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>1688开放平台对接</title>
    <link href="http://yoursite.com/2018/06/19/1688%E5%AF%B9%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/06/19/1688对接/</id>
    <published>2018-06-19T09:33:00.000Z</published>
    <updated>2018-06-27T13:16:24.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>什么是1688开放平台（ <a href="https://open.1688.com" target="_blank" rel="noopener">https://open.1688.com</a>  ）？</p><blockquote><p>依托B2B海量用户资源以及强大的平台优势，是为阿里巴巴商家提供基础服务的重要开放途径，帮助商家提升经营能力、拓宽生意渠道、提高办公效率。从今年开始，阿里巴巴开放平台将向合作伙伴和广大第三方开发者逐步开放会员、公司库、类目、产品、交易、咨讯等一系列接口。为合作伙伴提供快捷的提交通路，多入口最优展现的同时，共享商机，互利双赢。</p></blockquote><hr><h3 id="对接过程"><a href="#对接过程" class="headerlink" title="对接过程"></a>对接过程</h3><p>以下演示是以对接1688采购订单为例。</p><h4 id="1-注册开发者"><a href="#1-注册开发者" class="headerlink" title="1 注册开发者"></a>1 注册开发者</h4><p>如果想使用1688开放平台，必须首先要注册成为开发者，需要同时具备以下两个条件：</p><ol><li>具备一个阿里巴巴中国站帐号；</li><li>必须绑定了通过个人实名（公司企业）认证的支付宝帐号；个人开发者必须绑定通过个人实名认证的支付宝账号，企业开发者必须绑定通过商家认证的支付宝账号；</li></ol><p>开发者身份绑定的支付宝账户用于产品分成结算的收款账户。因此为了确认您的身份和安全考虑，必须通过支付宝认证。</p><h4 id="2-获取证书"><a href="#2-获取证书" class="headerlink" title="2 获取证书"></a>2 获取证书</h4><p>一、什么是应用证书：<br>证书指的是开发者在阿里巴巴开放平台创建应用是默认给开发者的应用开发证书。想要调用1688开放平台上的API必须申请证书。证书包含四个内容：</p><p><strong>证书编号：App Key</strong></p><p><strong>证书密钥：App Secret</strong></p><p>接口权限：开发者可以调用的API权限，包含基础开放与增值包</p><p>证书流量：应用可以调用API的流量限制</p><p>也就是“权限+流量+appkey+app secret=证书”，每个应用都有对应的应用开发证书，在应用创建时开发者获得证书。<br>二、什么是App Key？</p><p>App Key是应用的唯一标识，阿里巴巴开放平台通过App Key来鉴别应用的身份。<br>三、什么是App Secret？</p><p>AppSecret是阿里巴巴开放平台给应用分配的密钥，开发者需要妥善保存这个密钥，这个密钥用来保证应用来源的可靠性，防止被伪造。</p><h5 id="获取证书过程"><a href="#获取证书过程" class="headerlink" title="获取证书过程"></a>获取证书过程</h5><blockquote><p><a href="https://open.1688.com/developer/serviceType.htm?spm=a260s.8209130.sidebar.2.4fbb55edhIdo07#/?_k=l6b00o" target="_blank" rel="noopener">https://open.1688.com/developer/serviceType.htm?spm=a260s.8209130.sidebar.2.4fbb55edhIdo07#/?_k=l6b00o</a></p></blockquote><p>1.<strong>创建应用</strong>：根据自己公司的业务需求可以选择不同的应用类型，如下图所示：</p><p><img src="创建应用.jpg" alt="1688"><br>选择采购对接<br><img src="采购对接.jpg" alt="1688"><br>企业对接面向的是从1688网站上采购的数据信息拉取到公司自己的管理软件中进行统一的管理。点击<strong>采购对接</strong>后填写必要的一些信息提交申请就可以了。<br>在填写信息的时候，<strong>应用类目</strong>选择企业采购，大企业采购一般是通过不了的；<strong>授权用户数</strong>可以选择<strong>单用户授权</strong>也可以选择<strong>多用户授权</strong>，他们其中的区别放到下面讲。<br><img src="信息填写.jpg" alt="1688"></p><p>提交成功后便可在<strong>应用列表</strong>中看到申请到的对接应用。可以点击查看，就会看到应用详情，里面便包括了App Key和App Secret。如下图：<br><img src="查看应用详情.jpg" alt="1688"></p><p>2.<strong>申请解决方案</strong>：即针对你申请到的账户需要申请调用对应API的权限</p><p><strong>申请解决方案</strong>一般在48小时之内会反馈方案是否给予通过。所以开发的时候如果急于上线，需要提前申请。通过的解决方案便可以使用。<br><img src="申请解决方案.jpg" alt="1688"></p><p>3.<strong>测试账号</strong></p><p>当你在解决方案列表看到已经通过的账号，下一步就需要在线测试账号的可用性。<br>在API文档中点击<strong>API TOOLS 在线测试工具</strong>，输入App Key和App Secret便可以测试账号是否可用。<br><img src="测试.jpg" alt="1688"></p><p>4.<strong>下载jar包进行开发</strong></p><p><img src="sdk下载.jpg" alt="1688"></p><p>5.<strong>编程</strong></p><p>具体代码请看我的github上的项目，里面有完整的授权流程代码，地址：<a href="https://github.com/Foutlook/Docking-1688-Interface" target="_blank" rel="noopener">多用户授权下调用1688接口API授权流程</a>。</p><h4 id="3-关于单用户授权和多用户授权的说明"><a href="#3-关于单用户授权和多用户授权的说明" class="headerlink" title="3 关于单用户授权和多用户授权的说明"></a>3 关于单用户授权和多用户授权的说明</h4><p>我们首先看一下官方给的不同授权方式的定义：<br><img src="授权.jpg" alt="1688"></p><blockquote><p><strong>单用户授权和多用户授权</strong>的区别是：<br>1.单用户授权在调用API的时候不需要传access_token，而多用户授权需要传access_token ,不然的话无法调用1688的API。<br>2.单用户授权在申请上线的时候一个公司只能有一个账户，而多用户授权在上线的时候可以有多个账户。<br>3.多用户授权可以关联其他的账户，通过一个账户拉去多个账户的信息。</p></blockquote><p>虽然多用户授权有很多的好处，不过它开发起来要比单用户授权麻烦很多，主要是处理access_token 的问题。<br>首先我们先看看多用户授权下access_token 的授权流程，也就是获取access_token 的流程（<a href="https://open.1688.com/api/sysAuth.htm?spm=a260s.8208024.0.0.9f0e55edLOgOy1&amp;ns=cn.alibaba.open" target="_blank" rel="noopener">官网授权解释地址</a>）：</p><p><img src="流程.jpg" alt="1688"><br>首先通过code即<strong>临时令牌</strong>得到<strong>access_token</strong>，第一次授权后会得到<strong>refresh_token</strong>，等下次access_token过期的时候就可以通过refresh_token来得到。授权的流程图如下所示：<br><img src="授权流程.jpg" alt="1688"></p><p>具体代码请看我的github，地址：<a href="https://github.com/Foutlook/Docking-1688-Interface" target="_blank" rel="noopener">多用户授权下调用1688接口API授权流程</a>。</p><hr><p><strong>END</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;什么是1688开放平台（ &lt;a href=&quot;https://open.1688.com&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
    
      <category term="1688,1688开放平台,阿里巴巴" scheme="http://yoursite.com/tags/1688-1688%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"/>
    
  </entry>
  
  <entry>
    <title>jdk动态代理</title>
    <link href="http://yoursite.com/2018/01/20/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2018/01/20/jdk动态代理/</id>
    <published>2018-01-20T09:33:00.000Z</published>
    <updated>2018-06-26T11:52:00.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h3><p>代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。<strong>代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理</strong>。<br>为了保持行为的一致性，<strong>代理类和委托类</strong>通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。</p><hr><h3 id="动态代理类"><a href="#动态代理类" class="headerlink" title="动态代理类"></a>动态代理类</h3><p>Java动态代理类位于<strong>java.lang.reflect</strong>包下，一般主要涉及到以下两个类：<br>(1) Interface InvocationHandler：该接口中仅定义了一个方法</p><ul><li>publicobject invoke(Object obj,Method method, Object[] args)</li><li>在实际使用时，第一个参数obj一般是<strong>指代理类</strong>，method是被代理的方法，args为该方法的参数数组，这个抽象方法在代理类中动态实现。</li></ul><p>(2) Proxy：该类即为动态代理类，其中主要包含以下内容：    </p><ul><li>protected Proxy(InvocationHandler h)：构造函数，用于给内部的h赋值。</li><li>static InvocationHandler getInvocationHandler(Object proxy) :返回指定代理实例的调用处理程序</li><li>static Class&lt;?&gt; getProxyClass (ClassLoaderloader, Class[] interfaces)：返回代理类的 java.lang.Class 对象，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。</li><li>static boolean isProxyClass(Class&lt;?&gt; cl) //当且仅当指定的类通过 getProxyClass 方法或 newProxyInstance 方法动态生成为代理类时，返回 true。 </li><li><p>static Object newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h):/返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。</p><p><strong>所谓DynamicProxy是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些interface。你当然可以把该class的实例当作这些interface中的任何一个来用。当然，这个DynamicProxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。</strong><br>在使用动态代理类时，我们必须<strong>实现InvocationHandler接口</strong>，通过这种方式，被代理的对象(RealPerson)可以在运行时动态改变，需要控制的接口(Person接口)可以在运行时改变，控制的方式(DynamicSubject类)也可以动态改变，从而实现了非常灵活的动态代理关系。</p></li></ul><hr><h3 id="动态代理的步骤"><a href="#动态代理的步骤" class="headerlink" title="动态代理的步骤"></a>动态代理的步骤</h3><p>1.创建一个实现接口InvocationHandler的类，它必须实现invoke方法<br>2.创建被代理的类以及接口<br>3.通过Proxy的静态方法<br>newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)创建一个代理<br>4.通过代理调用方法</p><hr><h3 id="动态代理的实现"><a href="#动态代理的实现" class="headerlink" title="动态代理的实现"></a>动态代理的实现</h3><p>1：创建动态代理的接口</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.Proxy_one;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态代理接口</span></span><br><span class="line">public interface Person &#123;</span><br><span class="line">String SayHello(String name);</span><br><span class="line">String SayGoodBye();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2：创建需要代理的对象</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.Proxy_one;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际对象</span></span><br><span class="line">public class RealPerson implements Person &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String SayHello(String name) &#123;</span><br><span class="line">return "Hello "+name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String SayGoodBye() &#123;</span><br><span class="line">return "Bye";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3：实现InvocationHandler类，重写invoke方法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.Proxy_one;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用处理类实现类</span></span><br><span class="line"><span class="comment">//每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象</span></span><br><span class="line">public class InvocationHandlerImpl implements InvocationHandler &#123;</span><br><span class="line"><span class="comment">//我们要代理的真是对象</span></span><br><span class="line">private Person person;</span><br><span class="line">public InvocationHandlerImpl(Person person) &#123;</span><br><span class="line">this.person = person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法负责集中处理动态代理类上的所有方法调用</span></span><br><span class="line"><span class="comment"> * 调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"><span class="comment">//在代理真实对象方法前可以添加自己的操作</span></span><br><span class="line">System.out.println("在调用方法之前，我正在走路！");</span><br><span class="line">System.out.println("Method:"+method);</span><br><span class="line"><span class="comment">/*当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler</span></span><br><span class="line"><span class="comment"> *对象的invoke方法进行调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object returnValue = method.invoke(person, args);</span><br><span class="line"><span class="comment">//调用真实的代理对象的方法后，我们可以添加自己的方法</span></span><br><span class="line">System.out.println("调用之后，我继续向前走！");</span><br><span class="line"></span><br><span class="line">return returnValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4：测试jdk动态代理</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.Proxy_one;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class DynamicProxyTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"><span class="comment">//代理的真实对象</span></span><br><span class="line">Person realperson = new RealPerson();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能</span></span><br><span class="line"><span class="comment">         * 实现方法调用从代理类到委托类的分派转发</span></span><br><span class="line"><span class="comment">         * 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.</span></span><br><span class="line"><span class="comment">         * 即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">InvocationHandler ih = new InvocationHandlerImpl(realperson);</span><br><span class="line">Person proxy = (Person) Proxy.newProxyInstance(realperson.getClass().getClassLoader(),</span><br><span class="line">realperson.getClass().getInterfaces(), ih);</span><br><span class="line">System.out.println("动态代理对象的类型："+proxy.getClass().getName());</span><br><span class="line">String hello = proxy.SayHello("樊兴凯");</span><br><span class="line">System.out.println(hello);</span><br><span class="line">String bye = proxy.SayGoodBye();</span><br><span class="line">System.out.println(bye);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5：输出结果</p><blockquote><p>动态代理对象的类型：com.sun.proxy.$Proxy0<br>在调用方法之前，我正在走路！<br>Method:public abstract java.lang.String com.fan.Proxy_one.Person.SayHello(java.lang.String)<br>调用之后，我继续向前走！<br>Hello 张三<br>在调用方法之前，我正在走路！<br>Method:public abstract java.lang.String com.fan.Proxy_one.Person.SayGoodBye()<br>调用之后，我继续向前走！<br>Bye</p></blockquote><hr><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>使用匿名内部类的方式来实现 InvocationHandlerImpl</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.Proxy_two;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class DynamicProxyTest2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Person person = new RealPerson();</span><br><span class="line">Person proxy = (Person)Proxy.newProxyInstance(person.getClass().getClassLoader(), person.getClass().getInterfaces(),</span><br><span class="line">new InvocationHandler() &#123;</span><br><span class="line"><span class="comment">//使用匿名内部类的方式</span></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"><span class="comment">//在方法调用前，添加自己的动作</span></span><br><span class="line">System.out.println("打招呼之前-");</span><br><span class="line">System.out.println("Method:"+method);</span><br><span class="line">Object obj = method.invoke(person, args);</span><br><span class="line">System.out.println("打招呼之后----");</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println("动态代理对象的类型："+proxy.getClass().getName());</span><br><span class="line">String hello = proxy.SayHello("张三");</span><br><span class="line">System.out.println(hello);</span><br><span class="line">String goodbye = proxy.SayGoodBye();</span><br><span class="line">System.out.println(goodbye);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><blockquote><p>动态代理对象的类型：com.sun.proxy.$Proxy0<br>打招呼之前-<br>Method:public abstract java.lang.String com.fan.Proxy_two.Person.SayHello(java.lang.String)<br>打招呼之后—-<br>Hello 张三<br>打招呼之前-<br>Method:public abstract java.lang.String com.fan.Proxy_two.Person.SayGoodBye()<br>打招呼之后—-<br>Bye</p></blockquote><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>一个典型的动态代理创建对象过程可分为以下四个步骤：<br>1、通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = new InvocationHandlerImpl(…);<br>2、通过为Proxy类指定ClassLoader对象和一组interface创建动态代理类<br>Class clazz = Proxy.getProxyClass(classLoader,new Class[]{…});<br>3、通过反射机制获取动态代理类的构造函数，其参数类型是调用处理器接口类型<br>Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});<br>4、通过构造函数创建代理类实例，此时需将调用处理器对象作为参数被传入<br>Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler));<br>为了简化对象创建过程，Proxy类中的newInstance方法封装了2~4，只需两步即可完成代理对象的创建。<br>生成的RealPerson继承Proxy类实现Person接口，实现的Person的方法实际调用处理器的invoke方法，而invoke方法利用反射调用的是被代理对象的的方法（Object result=method.invoke(proxied,args)）</strong></p><hr><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>Proxy已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。<br>Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。有很多条理由，人们可以否定对 class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。如果只从方法的声明以及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。但是，不完美并不等于不伟大，伟大是一种本质，Java动态代理就是佐例。<br><strong>jdk给目标类提供动态要求目标类必须实现接口，当一个目标类不实现接口时，jdk是无法为其提供动态代理的。cglib 却能给这样的类提供动态代理。</strong>cglib在接下来的时间里将会介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;动态代理&quot;&gt;&lt;a href=&quot;#动态代理&quot; class=&quot;headerlink&quot; title=&quot;动态代理&quot;&gt;&lt;/a&gt;动态代理&lt;/h2&gt;&lt;h3 id=&quot;什么是代理&quot;&gt;&lt;a href=&quot;#什么是代理&quot; class=&quot;headerlink&quot; title=&quot;什么是代理&quot;&gt;
      
    
    </summary>
    
    
      <category term="java,动态代理" scheme="http://yoursite.com/tags/java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse中git的使用</title>
    <link href="http://yoursite.com/2018/01/16/Egit%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/01/16/Egit的使用/</id>
    <published>2018-01-16T09:33:00.000Z</published>
    <updated>2018-06-26T11:51:57.068Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>git在eclipse中的配置和远程仓库中关联，这里不再累述，如果有问题可以参考下面博客：这里有详细的说明。</strong></p><blockquote><p><a href="http://blog.csdn.net/hhhccckkk/article/details/10458159" target="_blank" rel="noopener">http://blog.csdn.net/hhhccckkk/article/details/10458159</a></p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>下面主要是我在使用中遇到的问题：rejected - non-fast-forward<br><img src="rejected.jpg" alt="git"><br>我在网上查找原因的时候，并没有一个很完整的文档，总结的都是挺乱的。故我对使用方式给予详细总结，以帮助更多的人。</p><hr><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p><strong>出现此问题的原因主要是：</strong></p><blockquote><p>我们平时使用eclipse开发的时候，主要是用git的commit和push，如果你的github库没有初始化，第一次push是可以正确提交的，但是当你已经push过一次后，会遇到无法提交到master分支（因为master分支是在服务器已经初始化好了，在服务器上已经存在了一个master分支，你在本地初始化的master分支和服务器的有冲突，并不是一个分支，就会提示rejected - non-fast-forward），如果你此时非要想提交到主分支，必须先要把服务器的初始化的git主分支pull到本地。只有这样才能正确的提交。</p></blockquote><hr><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><strong>1，点window—preference–team—git–configuration————-Repository Settings，Repository选择你的项目的本地仓库，然后点右边的open，</strong>视图如下：</p><p><img src="configuration2.jpg" alt="git"></p><p>open后会看到如下的config信息<br><img src="config.jpg" alt="git"></p><p><strong>2，然后在上面的基础上填上如下信息</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">   remote = origin</span><br><span class="line">   merge = refs/heads/master</span><br><span class="line"></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">   url = git@github<span class="selector-class">.com</span>:xxxx/xx                    -----&gt;你自己的仓库ssh的url</span><br><span class="line">   fetch = +refs/heads<span class="comment">/*:refs/remotes/origin/*</span></span><br><span class="line"><span class="comment">   push = refs/heads/master:refs/heads/master</span></span><br></pre></td></tr></table></figure><p><img src="gitRepositories.jpg" alt="git"></p><p><strong>3，配置好后选择项目Team–&gt; pull ，会看到项目会变成如下效果：</strong></p><p><img src="pull.jpg" alt="git"></p><p>查看本地仓库目录：<br><img src="readme.jpg" alt="git"></p><p><strong>4，push本地项目到远程仓库</strong></p><p><img src="destination.jpg" alt="git"></p><p>过程和第一次push的过程相同，填写信息然后push就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;git在eclipse中的配置和远程仓库中关联，这里不再累述，如果有问题可以参考下面博客：这里有详细的说明。&lt;/strong
      
    
    </summary>
    
    
      <category term="eclipse,git,github" scheme="http://yoursite.com/tags/eclipse-git-github/"/>
    
  </entry>
  
  <entry>
    <title>装饰者模式</title>
    <link href="http://yoursite.com/2017/12/30/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/12/30/装饰者模式/</id>
    <published>2017-12-30T09:33:00.000Z</published>
    <updated>2018-06-26T11:51:58.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设置模式之装饰者模式"><a href="#设置模式之装饰者模式" class="headerlink" title="设置模式之装饰者模式"></a>设置模式之装饰者模式</h2><p><strong>装饰者模式(Decorator)是一种结构式模式。动态地给一个对象添加一些额外的职责。就增加功能来说，装饰者模式相比生成子类更为灵活。同时还可以让这些装饰类互相装饰。</strong><br> <img src="装饰者模式.jpg" alt="设计模式"></p><hr><h3 id="1-装饰者设计模式的步骤："><a href="#1-装饰者设计模式的步骤：" class="headerlink" title="1: 装饰者设计模式的步骤："></a>1: 装饰者设计模式的步骤：</h3><p>a.在装饰类的内部维护一个被装饰类的引用。<br>b.让装饰类有一个共同的父类或者是父接口</p><hr><h3 id="2-具体过程："><a href="#2-具体过程：" class="headerlink" title="2:具体过程："></a>2:具体过程：</h3><p>Component : 定义一个对象接口，可以给这些对象动态地添加职责。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line">public interface Component &#123;</span><br><span class="line">void operation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteComponent:实现Component定义的接口</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Component定义的接口</span></span><br><span class="line">public class ConcreteComponent implements Component &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void operation() &#123;</span><br><span class="line">System.out.println("初始化");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Decorator : 装饰抽象类，继承了 Component， 从外类来扩展 Component 类的功能，但对于 Component 来说，是无需知道 Decorator 的存在的。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line">public class Decorator implements Component &#123;</span><br><span class="line"><span class="comment">//维护一个Component对象，和Component形成聚合关系</span></span><br><span class="line">private Component component;</span><br><span class="line">public Decorator(Component component) &#123;</span><br><span class="line">this.component = component;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用要修饰对象的原方法</span></span><br><span class="line">@Override</span><br><span class="line">public void operation() &#123;</span><br><span class="line">component.operation();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteDecoratorA : 具体的装饰对象，起到给 Component 添加职责A的功能。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line">public class ConcreteDecoretorA extends Decorator &#123;</span><br><span class="line"></span><br><span class="line">public ConcreteDecoretorA(Component component) &#123;</span><br><span class="line">super(component);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void operation()&#123;</span><br><span class="line">super.operation();</span><br><span class="line">System.out.println("添加属性：性属性1");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteDecoratorB : 具体的装饰对象，起到给 Component 添加职责B的功能。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line">public class ConcreteDecoratorB extends Decorator &#123;</span><br><span class="line"></span><br><span class="line">public ConcreteDecoratorB(Component component) &#123;</span><br><span class="line">super(component);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void operation() &#123;</span><br><span class="line">super.operation();</span><br><span class="line">System.out.println("添加行为");</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line">public class DecoratorPattern &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Component component = new ConcreteComponent();</span><br><span class="line">component.operation();</span><br><span class="line">System.out.println("++++++++++++++++++++++");</span><br><span class="line"></span><br><span class="line">Decorator decoratorA = new  ConcreteDecoretorA(component);</span><br><span class="line">decoratorA.operation();     //通过super向上级层层调用</span><br><span class="line">System.out.println("++++++++++++++++++++++");</span><br><span class="line">Decorator decoratorB = new ConcreteDecoratorB(decoratorA);</span><br><span class="line">decoratorB.operation();//B调用A的 --A调用父类的，父类调用接口的实现类operation方法</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><blockquote><p>初始化<br>++++++++++++++++++<br>初始化<br>添加属性：性属性1<br>++++++++++++++++++<br>初始化<br>添加属性：性属性1<br>添加行为</p></blockquote><hr><h3 id="3-装饰者模式的应用场景"><a href="#3-装饰者模式的应用场景" class="headerlink" title="3:装饰者模式的应用场景"></a>3:装饰者模式的应用场景</h3><p>a.需要动态的、透明的为一个对象添加职责，即不影响其他对象。<br>b.需要动态的给一个对象添加功能，这些功能可以再动态的撤销。<br>c.需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。<br>d.当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</p><hr><h3 id="4-要点："><a href="#4-要点：" class="headerlink" title="4:要点："></a>4:要点：</h3><ul><li>装饰者和被装饰对象有相同的超类型。</li><li>可以用一个或多个装饰者包装一个对象。</li><li>装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的。</li><li>对象可以在任何时候被装饰，所以可以在运行时动态的，不限量的用你喜欢的装饰者来装饰对象。</li><li>装饰模式中使用继承的关键是想达到装饰者和被装饰对象的类型匹配，而不是获得其行为。</li><li>装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。在实际项目中可以根据需要为装饰者添加新的行为，做到“半透明”装饰者。</li></ul><hr><h3 id="5-继承实现的增强类和修饰模式实现的增强类有和区别？"><a href="#5-继承实现的增强类和修饰模式实现的增强类有和区别？" class="headerlink" title="5:继承实现的增强类和修饰模式实现的增强类有和区别？"></a>5:继承实现的增强类和修饰模式实现的增强类有和区别？</h3><blockquote><p>继承实现的增强类： 优点：代码结构清晰，而且实现简单.<br>缺点：对于每一个的需要增强的类都要创建具体的子类来帮助其增强，这样会导致继承体系过于庞大。</p><p>装饰者设计模式实现的增强类： 优点：内部可以通过多态技术对多个需要增强的类进行增强，可以使这些装饰类达到互相装饰的效果，使用比较灵活。<br>缺点：需要内部通过多态技术维护需要被增强的类的实例。进而使得代码稍微复杂。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设置模式之装饰者模式&quot;&gt;&lt;a href=&quot;#设置模式之装饰者模式&quot; class=&quot;headerlink&quot; title=&quot;设置模式之装饰者模式&quot;&gt;&lt;/a&gt;设置模式之装饰者模式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;装饰者模式(Decorator)是一种结构式模式。动态地给一
      
    
    </summary>
    
    
      <category term="设计模式,java" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-java/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装Vundle管理vim插件</title>
    <link href="http://yoursite.com/2017/11/20/Ubuntu%E5%AE%89%E8%A3%85Vundle/"/>
    <id>http://yoursite.com/2017/11/20/Ubuntu安装Vundle/</id>
    <published>2017-11-20T09:33:00.000Z</published>
    <updated>2017-12-09T08:50:51.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>我在学习Linux这段时间里，使用vim编程，为了提高自己的逼格，也为了提高自己的效率，就尝试着安装了2个插件。感觉逼格高了很多。</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装其他插件之前，我们首先需要安装一个管理插件的插件，它就是Vundle，Vundle可以帮助我们管理和安装其他的插件，非常好用。</p><h3 id="安装Vundle插件"><a href="#安装Vundle插件" class="headerlink" title="安装Vundle插件"></a>安装Vundle插件</h3><p>Vundle可以在GitHub上找到，地址：<a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="noopener">https://github.com/VundleVim/Vundle.vim</a> </p><p>1、  如果在你的Linux或者Ubuntu中没有暗转git，首先请先安装git</p><blockquote><p>sudo apt-get install git</p></blockquote><p>2、 使用git安装Vundle ，可以安装到~/.vim/bundle/Vundle.vim下</p><blockquote><p>git clone <a href="https://github.com/VundleVim/Vundle.vim.git" target="_blank" rel="noopener">https://github.com/VundleVim/Vundle.vim.git</a> ~/.vim/bundle/Vundle.vim</p></blockquote><p>3、 添加官方文档提供的配置信息到  ~/.vimrc 中(.vimrc 如果不存在就创建一个【vi  ~/.vimrc】)：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">set nocompatible              <span class="string">" be iMproved, required</span></span><br><span class="line"><span class="string">filetype off                      "</span> required</span><br><span class="line"></span><br><span class="line"><span class="string">" set the runtime path to include Vundle and initialize</span></span><br><span class="line"><span class="string">set rtp+=~/.vim/bundle/Vundle.vim</span></span><br><span class="line"><span class="string">call vundle#begin()</span></span><br><span class="line"><span class="string">"</span> alternatively, pass <span class="selector-tag">a</span> path where Vundle should install plugins</span><br><span class="line"><span class="string">"call vundle#begin('~/some/path/here')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> let Vundle manage Vundle, required</span><br><span class="line">Plugin <span class="string">'VundleVim/Vundle.vim'</span></span><br><span class="line"></span><br><span class="line"><span class="string">" The following are examples of different formats supported.</span></span><br><span class="line">" Keep Plugin commands between vundle#begin/end.</span><br><span class="line"><span class="string">" plugin on GitHub repo</span></span><br><span class="line"><span class="string">Plugin 'tpope/vim-fugitive'</span></span><br><span class="line"><span class="string">"</span> plugin from http:<span class="comment">//vim-scripts.org/vim/scripts.html</span></span><br><span class="line"><span class="string">" Plugin 'L9'</span></span><br><span class="line"><span class="string">"</span> Git plugin not hosted on GitHub</span><br><span class="line">Plugin <span class="string">'git://git.wincent.com/command-t.git'</span></span><br><span class="line"><span class="string">" git repos on your local machine (i.e. when working on your own plugin)</span></span><br><span class="line"><span class="string">Plugin 'file:///home/gmarik/path/to/plugin'</span></span><br><span class="line"><span class="string">"</span> The sparkup vim script is <span class="keyword">in</span> <span class="selector-tag">a</span> subdirectory of this repo called vim.</span><br><span class="line"><span class="string">" Pass the path to set the runtimepath properly.</span></span><br><span class="line"><span class="string">Plugin 'rstacruz/sparkup', &#123;'rtp': 'vim/'&#125;</span></span><br><span class="line"><span class="string">"</span> Install L9 and avoid <span class="selector-tag">a</span> Naming conflict <span class="keyword">if</span> you<span class="string">'ve already installed a</span></span><br><span class="line"><span class="string">" different version somewhere else.</span></span><br><span class="line"><span class="string">" Plugin '</span>ascenator/L9<span class="string">', &#123;'</span>name<span class="string">': '</span>newL9<span class="string">'&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">" All of your Plugins must be added before the following line</span></span><br><span class="line"><span class="string">call vundle#end()            " required</span></span><br><span class="line"><span class="string">filetype plugin indent on    " required</span></span><br><span class="line"><span class="string">" To ignore plugin indent changes, instead use:</span></span><br><span class="line"><span class="string">"filetype plugin on</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">" Brief help</span></span><br><span class="line"><span class="string">" :PluginList       - lists configured plugins</span></span><br><span class="line"><span class="string">" :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate</span></span><br><span class="line"><span class="string">" :PluginSearch foo - searches for foo; append `!` to refresh local cache</span></span><br><span class="line"><span class="string">" :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">" see :h vundle for more details or wiki for FAQ</span></span><br><span class="line"><span class="string">" Put your non-Plugin stuff after this line</span></span><br></pre></td></tr></table></figure><blockquote><p> <strong>注意：如果按这个文件配置，我在进行安装的时候回报错：</strong><br> 提示说  Plugin ‘file:///home/gmarik/path/to/plugin’   找不到，文档中说：git repos on your local machine (i.e. when working on your own plugin)  意思是这个安装本地插件的一个目录，我这没有本地插件，所以我就把这句注释掉了。</p></blockquote><p>4、  打开vim ，安装默认插件：</p><blockquote><p>只在终端键入 vim，后面什么都不加<br>    sudo  vim    –sudo临时提高权限，如果不加sudo，可能会遇到权限不够。<br>   然后键入下面的命令<br>    :PluginInstall<br>   之后等待安装完成，[ :q ] 来退出即可</p></blockquote><p> 安装成功如下图所示：<br> <img src="安装语句.png" alt="Ubuntu"></p><h3 id="安装2个常用插件"><a href="#安装2个常用插件" class="headerlink" title="安装2个常用插件"></a>安装2个常用插件</h3><p>1、  tagbar</p><p>这个插件可以浏览当前文件的标签，如果想更深的了解，GitHub地址为:   <a href="https://github.com/majutsushi/tagbar" target="_blank" rel="noopener">https://github.com/majutsushi/tagbar</a><br>效果图如下：<br><img src="vim-tagbar.png" alt="Ubuntu"></p><ul><li>该插件安装之前需要先安装 ctags</li></ul><blockquote><p>  sudo apt-get install ctags</p></blockquote><ul><li>添加插件和其他配置信息到   ~/.vimrc 中</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">进入 ~/.vimrc</span><br><span class="line"></span><br><span class="line"># 添加以下  tagbar  插件</span><br><span class="line">Plugin <span class="string">'majutsushi/tagbar'</span></span><br><span class="line"></span><br><span class="line"># 配置 tagbar 插件</span><br><span class="line">let g:tagbar_ctags_bin=<span class="string">'ctags'</span>     <span class="string">"ctags 程序的路径</span></span><br><span class="line"><span class="string">let g:tagbar_width=30                   "</span>窗口宽度设置为 <span class="number">30</span></span><br><span class="line">let g:tagbar_left=<span class="number">1</span>                         <span class="string">"设置在 vim 左边显示</span></span><br><span class="line"><span class="string">let g:tagbar_map_openfold = "</span>zv<span class="string">"   "</span>按 zv 组合键打开标签，默认 zc 关闭标签</span><br><span class="line"></span><br><span class="line"><span class="string">"如果是 C 语言的程序的话，tagbar 自动开启</span></span><br><span class="line"><span class="string">autocmd BufReadPost *.cpp,*.c,*.h,*.hpp,*.cc,*.cxx call tagbar#autoopen() </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>我设置 F2 为打开或者关闭的快捷键，根据你的习惯更改</span><br><span class="line">nnoremap &lt;silent&gt; &lt;F2&gt; :TagbarToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure><ul><li>然后通过命令进行安装，语句和安装Vundle 第4步相同</li></ul><p>2、  安装 vim-airline 插件<br>    这个插件没有很大的实用性，但能增加逼格，增加vim的有趣性。<br>    <strong>第一步，我们先把下面的需要配置的文件添加到 ~/.vimrc 中</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" ------------------------安装 vim-airline------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set laststatus=2   "</span> 永远显示状态栏</span><br><span class="line">set t_Co=<span class="number">256</span>       <span class="string">" 在windows中用xshell连接打开vim可以显示色彩</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>Vim 在与屏幕/键盘交互时使用的编码(取决于实际的终端的设定)        </span><br><span class="line">:set encoding=utf-<span class="number">8</span></span><br><span class="line">:set langmenu=zh_CN.UTF-<span class="number">8</span></span><br><span class="line">:set fileencodings=utf-<span class="number">8</span></span><br><span class="line">:set fileencoding=utf-<span class="number">8</span></span><br><span class="line">:set termencoding=utf-<span class="number">8</span></span><br><span class="line"></span><br><span class="line">Plugin <span class="string">'vim-airline'</span>    </span><br><span class="line">let g:airline_theme=<span class="string">"molokai"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"这个是安装字体后 必须设置此项"</span> </span><br><span class="line">let g:airline_powerline_fonts = <span class="number">1</span>  </span><br><span class="line"><span class="string">"打开tabline功能,方便查看Buffer和切换,省去了minibufexpl插件</span></span><br><span class="line"><span class="string"> let g:airline#extensions#tabline#enabled = 1</span></span><br><span class="line"><span class="string"> let g:airline#extensions#tabline#buffer_nr_show = 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>设置切换Buffer快捷键<span class="string">"</span></span><br><span class="line"><span class="string">nnoremap &lt;F4&gt; :bn&lt;CR&gt;</span></span><br><span class="line"><span class="string">"</span> 关闭状态显示空白符号计数</span><br><span class="line"> let g:airline#extensions#whitespace<span class="selector-id">#enabled</span> = <span class="number">0</span></span><br><span class="line"> let g:airline#extensions#whitespace<span class="selector-id">#symbol</span> = <span class="string">'!'</span></span><br><span class="line"></span><br><span class="line"> <span class="string">" 设置consolas字体"</span>前面已经设置过</span><br><span class="line"> <span class="string">"set guifont=Consolas\ for\ Powerline\ FixedD:h11</span></span><br><span class="line"><span class="string"> if !exists('g:airline_symbols')</span></span><br><span class="line"><span class="string">let g:airline_symbols = &#123;&#125;</span></span><br><span class="line"><span class="string"> endif</span></span><br><span class="line"><span class="string"> "</span> old vim-powerline symbols</span><br><span class="line"> let g:airline_left_sep = <span class="string">'⮀'</span></span><br><span class="line"> let g:airline_left_alt_sep = <span class="string">'⮁'</span></span><br><span class="line"> let g:airline_right_sep = <span class="string">'⮂'</span></span><br><span class="line"> let g:airline_right_alt_sep = <span class="string">'⮃'</span></span><br><span class="line"> let g:airline_symbols<span class="selector-class">.branch</span> = <span class="string">'⭠'</span></span><br><span class="line"> let g:airline_symbols<span class="selector-class">.readonly</span> = <span class="string">'⭤'</span></span><br></pre></td></tr></table></figure><p><strong>第二步：要安装字体，如果没有安装字体的话，vim-airline的效果就没法正确的显示</strong></p><p>字体安装GitHub地址：<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">https://github.com/powerline/fonts</a></p><p>在终端上一步步输入下面的内容即可：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># clone</span><br><span class="line">git clone https:<span class="comment">//github.com/powerline/fonts.git --depth=1</span></span><br><span class="line"># install</span><br><span class="line">cd fonts</span><br><span class="line">./install.sh</span><br><span class="line"># clean-up a bit</span><br><span class="line">cd ..</span><br><span class="line">rm -rf fonts</span><br></pre></td></tr></table></figure><p>第三步：继续执行安装Vundle的第四步即可</p><p>效果图如下：<br> <img src="字体.png" alt="Ubuntu"></p><blockquote><p> 注意：在安装的时候，如果遇到权限不够，使用sudo vim 临时提高权限<br> 使用vim时遇到的问题： 如何用vim命令把编辑文件的几行内容拷贝到一个新文件 — 如把58行到79行拷贝到~/test.txt文件可以使用下面的命令&gt;&gt; :58,79w!~/.test.txt</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;我在学习Linux这段时间里，使用vim编程，为了提高自己的逼格，也为了提高自己的效率，就尝试着安装了2个插件。感觉逼格高了
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux，vim，Vundle" scheme="http://yoursite.com/tags/Linux%EF%BC%8Cvim%EF%BC%8CVundle/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解JVM】总结</title>
    <link href="http://yoursite.com/2017/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/10/20/深入理解JVM总结/</id>
    <published>2017-10-20T02:33:00.000Z</published>
    <updated>2017-12-05T06:50:42.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过三周的时间我把<strong>周志明</strong>的【深入理解java虚拟机】看完了，对我而言我感觉只是看到一些皮毛，以上的文章都是基于这本书来写的，基本上能理解的都写了上去，我也参考了许多大V的博客，下面我把主要参考博客链接发下下面，如果觉得我写的一般般，可以参考他们的，谢谢！</p><blockquote><p> 兰亭风雨：<a href="http://my.csdn.net/mmc_maodun" target="_blank" rel="noopener">http://my.csdn.net/mmc_maodun</a><br> ChangWen的博客： <a href="http://blog.csdn.net/oChangWen" target="_blank" rel="noopener">http://blog.csdn.net/oChangWen</a><br> 生命壹号：<a href="http://www.cnblogs.com/smyhvae/category/587723.html" target="_blank" rel="noopener">http://www.cnblogs.com/smyhvae/category/587723.html</a></p></blockquote><p>生命壹号对于JVM的总结：<br><a href="http://www.cnblogs.com/smyhvae/p/4810168.html" target="_blank" rel="noopener">http://www.cnblogs.com/smyhvae/p/4810168.html</a></p><p>以下是我的总结：通过XMind见到总结了一下，希望对你有用：<br><img src="JVM常见问题总结.png" alt="总结"></p><blockquote><p>一个菜鸟到一个大神，需要经历许多许多，但是只要梦想在，就要继续前进，因为有很多人需要你照顾。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;经过三周的时间我把&lt;strong&gt;周志明&lt;/strong&gt;的【深入理解java虚拟机】看完了，对我而言我感觉只是看到一些皮毛，以上的文章都是
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM，总结" scheme="http://yoursite.com/tags/JVM%EF%BC%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解JVM】之七：Javac编译与JIT编译</title>
    <link href="http://yoursite.com/2017/10/15/Javac%E7%BC%96%E8%AF%91%E4%B8%8EJIT%E7%BC%96%E8%AF%91/"/>
    <id>http://yoursite.com/2017/10/15/Javac编译与JIT编译/</id>
    <published>2017-10-15T02:33:00.000Z</published>
    <updated>2017-12-05T06:51:06.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>本文章参考周志明的【深入理解Java虚拟机】<br>代码编译的结果从本地机器码转变成字节码，是存储格式发展的一小步，却是编译语言发展的一大步。</p></blockquote><hr><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java虚拟机的执行引擎在执行java代码的时候都有解释执行（通过解释器执行）和编译执行（通过编译器产生本地代码执行）这两种选择。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不论是解释还是编译，也不论是物理机还是虚拟机，大部分的程序代码从开始编译到最终转化成物理机的目标代码或虚拟机能执行的指令集之前，都会按照如下图所示的各个步骤进行：<br><img src="编译过程.png" alt="JIT"></p><blockquote><p>其中绿色的模块可以选择性实现。很容易看出，上图中间的那条分支是解释执行的过程（即一条字节码一条字节码地解释执行，如JavaScript），而下面的那条分支就是传统编译原理中从源代码到目标机器代码的生成过程。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今，基于物理机、虚拟机等的语言，大多都遵循这种基于现代经典编译原理的思路，在执行前先对程序源码进行词法解析和语法解析处理，把源码转化为抽象语法树。<strong>对于一门具体语言的实现来说，词法和语法分析乃至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言。也可以把抽象语法树或指令流之前的步骤实现一个半独立的编译器，这类代表是Java语言。又或者可以把这些步骤和执行引擎全部集中在一起实现，如大多数的JavaScript执行器。</strong></p><h2 id="Javac编译"><a href="#Javac编译" class="headerlink" title="Javac编译"></a>Javac编译</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java中提到“编译”，<strong>自然很容易想到Javac编译器将<em>.java文件编译成为</em>.class文件的过程，这里的Javac编译器称为前端编译器</strong>，其他的前端编译器还有诸如Eclipse JDT中的增量式编译器ECJ等。<strong>相对应的还有后端编译器，它在程序运行期间将字节码转变成机器码（现在的Java程序在运行时基本都是解释执行加编译执行）</strong>，如HotSpot虚拟机自带的JIT（Just In Time Compiler）编译器（分Client端和Server端）。另外，<strong>有时候还有可能会碰到静态提前编译器（AOT，Ahead Of Time Compiler）直接把*.java文件编译成本地机器代码</strong>，如GCJ、Excelsior JET等，这类编译器我们应该比较少遇到。<br>下面简要说下Javac编译（前端编译）的过程：</p><h3 id="词法、语法分析"><a href="#词法、语法分析" class="headerlink" title="词法、语法分析"></a>词法、语法分析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;词法分析是将源代码的字符流转变为标记（Token）集合。单个字符是程序编写过程中的的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符等都可以成为标记，比如整型标志int由三个字符构成，但是它只是一个标记，不可拆分。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语法分析是根据Token序列来构造抽象语法树的过程。抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，如bao、类型、修饰符、运算符等。经过这个步骤后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上。</p><h3 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成了语法分析和词法分析之后，下一步就是填充符号表的过程。符号表是由一组符号地址和符号信息构成的表格。符号表中所登记的信息在编译的不同阶段都要用到，在语义分析（后面的步骤）中，符号表所登记的内容将用于语义检查和产生中间代码，在目标代码生成阶段，党对符号名进行地址分配时，符号表是地址分配的依据。</p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是读结构上正确的源程序进行上下文有关性质的审查。语义分析过程分为标注检查和数据及控制流分析两个步骤：</p><ul><li>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量和赋值之间的数据类型是否匹配等。</li><li>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题</li></ul><h3 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字节码生成是Javac编译过程的最后一个阶段。字节码生成阶段不仅仅是把前面各个步骤所生成的信息转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。 实例构造器<init>（）方法和类构造器<clinit>（）方法就是在这个阶段添加到语法树之中的（这里的实例构造器并不是指默认的构造函数，而是指我们自己重载的构造函数，如果用户代码中没有提供任何构造函数，那编译器会自动添加一个没有参数、访问权限与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成了）。</clinit></init></p><hr><h2 id="JIT编译"><a href="#JIT编译" class="headerlink" title="JIT编译"></a>JIT编译</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java程序最初是仅仅通过解释器解释执行的，即对字节码逐条解释执行，这种方式的执行速度相对会比较慢，尤其当某个方法或代码块运行的特别频繁时，这种方式的执行效率就显得很低。于是后来在虚拟机中引入了<strong>JIT编译器</strong>（即时编译器），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是JIT编译器。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在主流的商用虚拟机（如Sun HotSpot、IBM J9）中几乎都同时包含解释器和编译器（三大商用虚拟机之一的JRockit是个例外，它内部没有解释器，因此会有启动相应时间长之类的缺点，但它主要是面向服务端的应用，这类应用一般不会重点关注启动时间）。</p><blockquote><p><strong>二者各有优势：</strong><br> <strong>当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行；当程序运行后，随着时间的推移，编译器逐渐会返回作用，把越来越多的代码编译成本地代码后，可以获取更高的执行效率。解释执行可以节约内存，而编译执行可以提升效率。</strong></p></blockquote><p>同时解释器还可以作为编译器激进优化时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类后类型继承结构出现变化，出现“罕见陷阱”时可以通过逆优化退回到解释状态继续执行（部分没有解释器的虚拟机中也会采用不进行激进优化的C1编译器-（在虚拟机中习惯将Client compiler称为C1，将Server Compiler称为C2）担任“逃生门”的角色），因此，在整个虚拟机执行机构中，解释器与编译器经常配合工作，如下图：<br><img src="解释器与编译器的交互.png" alt="JIT"></p><p>  HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。<br>无论采用的编译器hiClient Compiler还是Server Compiler，解释器与编译器搭配使用的方式在虚拟机中称为“混合模式”（Mixed Mode）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启用分层编译的策略（1.7默认开启），分层编译根据编译器编译，优化的规模与耗时，划分出不同的编译层次，其中包括：</p><ul><li>第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译</li><li>第1层，也成C1编译，将字节码编译为本地代码，进行简单，可靠的优化，如有必要将加入性能监控的逻辑。</li><li>第2层（或2层以上），也成C2编译，也是将字节码编译成本地代码，但是会启用一些耗时较长的优化甚至会根据性能监控信息进行一些不可靠的激进优化。</li></ul><h3 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h3><p><strong>运行过程中会被即时编译器编译的“热点代码”有两类：</strong></p><ul><li>被多次调用的方法。</li><li>被多次调用的循环体。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 两种情况，编译器都是以整个方法作为编译对象，这种编译也是虚拟机中标准的编译方式。要知道一段代码或方法是不是热点代码，是不是需要触发即时编译，需要进行Hot Spot Detection（热点探测）。<strong>目前主要的热点 判定方式有以下两种：</strong></p><ul><li><strong>基于采样的热点探测</strong>：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li><li><p><strong>基于计数器的热点探测</strong>：采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。</p><p><strong>在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。</strong></p><p><strong>方法调用计数器用来统计方法调用的次数</strong>，在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数。。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，<strong>按这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减，而这段时间就称为此方法统计的半衰周期。</strong></p></li></ul><p>  <strong>回边计数器用于统计一个方法中循环体代码执行的次数</strong>（准确地说，应该是回边的次数，因为并非所有的循环都是回边），在字节码中遇到控制流向后跳转的指令就称为“回边”<br><strong>在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。</strong>   触发了JIT编译后，在默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成为止（编译工作在后台线程中进行）。当编译工作完成后，下一次调用该方法或代码时，就会使用已编译的版本。</p><hr><p>方法调用计数器触发即时编译的流程如下图：<br><img src="方法调用计数器触发即时编译.png" alt="JIT"></p><p>回边计数器触发即时编译的流程和方法调用计数器流程基本相同，这里不再累述。</p><hr><p><strong>这个世界不会亏欠每一个在孤独中重生的人。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;本文章参考周志明的【深入理解Java虚拟机】&lt;br&gt;代码编译的结果从本地机器码转变成字节码，是存储格式发展的一小步
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM，类加载" scheme="http://yoursite.com/tags/JVM%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解JVM】之六：虚拟机字节码执行引擎</title>
    <link href="http://yoursite.com/2017/10/10/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/</id>
    <published>2017-10-10T02:33:00.000Z</published>
    <updated>2017-12-05T06:49:19.433Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>本文章参考周志明的【深入理解Java虚拟机】<br>代码编译的结果从本地机器码转变成字节码，是存储格式发展的一小步，却是编译语言发展的一大步。</p></blockquote><p>在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观(Facade)。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行)两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎，但从外观上看起来，所有的Java虚拟机的执行引擎都是一致的：<strong>输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行过程</strong>，下面将从概念模型的角度来讲解虚拟机的<strong>方法调用和字节码执行</strong>。</p><hr><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p><strong>栈帧(Stack Frame)</strong>是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的<strong>虚拟机栈(Virtual Machine Stack)的栈元素</strong>。栈帧存储了方法的<strong>局部变量表，操作数栈，动态链接，方法返回地址和一些额外的附加信息</strong>等信息。每一个方法从调用开始到执行完成，就对应着一个栈帧在虚拟机栈中从<strong>入栈到出栈</strong>的过程。<br><strong>在编译代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了</strong>，并且写入到了方法表的Code属性中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体虚拟机的实现。<br>在活动线程中，只有位于栈顶的栈帧才是有效的，称为<strong>当前栈帧</strong>，与这个当前栈帧关联的方法称为<strong>当前方法</strong>。<strong>执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作</strong>。<br>下图是栈帧结构的概念模型：<br><img src="栈帧的概念结构.png" alt="执行引擎"></p><h3 id="局部变量变"><a href="#局部变量变" class="headerlink" title="局部变量变"></a>局部变量变</h3><p><strong>局部变量表</strong>是一组变量值存储空间，用于存放<strong>方法参数和方法内部定义的局部变量</strong>。在Java程序编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。<br><strong>局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位</strong>。虚拟机规范中并没有明确指明一个Slot应占的内存空间的大小，只是说到每个Slot都应该存放一个boolean，byte，char，short，int，float，reference和returnAddress这8种类型数据。<br>第七种reference类型表示对一个对象实例的引用，虚拟机规范即没有说明它的长度，也没有明确指定这种应用应有怎样的结构。但一般来说，虚拟机实现至少都应该能<strong>通过这个引用做到两点</strong>：一是从此引用中直接或间接的查找到对象在java堆中的数据存放的起始地址索引，二是此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则无法实现java语言规范中定义的语法约束的约束。<br>对于64位的数据类型，虚拟机会高位对齐的方式为其分配两个连续的Slot空间，java语言规定的64位数据类型只有long和double两种（reference类型可能是32位也可能是64位）。</p><p>虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的Slot数量。如果访问的是32位数据类型的变量，<strong>索引n就代表了使用第n个Slot</strong>，如果是64位数据类型的变量，则说明会同时使用n和n+1两个Slot。对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用任何方式单独访问其中的某一个，Java虚拟机规范中明确要求了如果遇到进行这种操作的字节码序列，虚拟机应该在类加载的校验阶段抛出异常。 </p><p>在方法执行时，虚拟机是使用局部变量表完成参数变量列表的传递过程，如果是<strong>实例方法(非static方法</strong>)，那<strong>么局部变量表中的第0位索引的Slot默认是用于传递方法所属对象实例的引用</strong>，在方法中可以通过关键字<strong>“this”</strong>来访问这个隐含的参数，其余参数则按照参数列表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据<strong>方法体内部定义的变量顺序和作用域来分配其余的Slot</strong>。</p><p><strong>局部变量表中的Slot是可重用的</strong>，方法体中定义的变量，其作用域并不一定会覆盖整个方法，如果当前字节码PC计算器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其它变量使用。</p><blockquote><p>注意：虽然Slot重用可以节省栈帧空间，但是重用栈帧会伴随一些额外的副作用。如，某些情况下，Slot的复用会影响垃圾收集行为。</p></blockquote><p>影响之一：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">byte[] placeholder = new byte[64*1024*1024];</span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc())  <span class="number">68198</span>K-&gt;<span class="number">66120</span>K(<span class="number">125952</span>K), <span class="number">0.0027128</span> secs]</span><br><span class="line">[Full GC (System.gc())  <span class="number">66120</span>K-&gt;<span class="number">66063</span>K(<span class="number">125952</span>K), <span class="number">0.0080045</span> secs]</span><br></pre></td></tr></table></figure><p><strong>从结果中可以看出，在运行System.gc（）后并没有回收64M的内存。主要原因是在执行GC时，变量placeholder还处于作用域之内，虚拟机无法回收。</strong></p><p>修改代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#123;</span><br><span class="line">byte[] placeholder = new byte[64*1024*1024];</span><br><span class="line">&#125;</span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc())  <span class="number">67532</span>K-&gt;<span class="number">66176</span>K(<span class="number">125952</span>K), <span class="number">0.0013205</span> secs]</span><br><span class="line">[Full GC (System.gc())  <span class="number">66176</span>K-&gt;<span class="number">66060</span>K(<span class="number">125952</span>K), <span class="number">0.0067795</span> secs]</span><br></pre></td></tr></table></figure><p><strong>加了花括号之后，placeholder的作用域被限制在花括号之内，从逻辑代码上讲，在执行System.gc（）时，placeholder已经不可能被访问了，但结果发现，还是有64M的内存无法别回收。这又是为什么呢？？？</strong></p><p>下面我们继续修改代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#123;</span><br><span class="line">byte[] placeholder = new byte[64*1024*1024];</span><br><span class="line">&#125;</span><br><span class="line">int a =0;</span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc())  <span class="number">67532</span>K-&gt;<span class="number">66176</span>K(<span class="number">125952</span>K), <span class="number">0.0008704</span> secs]</span><br><span class="line">[Full GC (System.gc())  <span class="number">66176</span>K-&gt;<span class="number">524</span>K(<span class="number">125952</span>K), <span class="number">0.0063974</span> secs]</span><br></pre></td></tr></table></figure><p><strong>结果中我们发现，64M内存被回收了，这中间发生了什么？</strong><br>根本原因：</p><blockquote><p>placeholder被收回要看局部变量表中的slot是否还存有关于placeholder数组对象的引用，第一次修改中，代码虽然已经离开了placeholder的作用域，但在此以后，没有任何对局部变量表的读写操作，placeholder原本所占用的slot没有被其他变量复用，局部变量表仍保持着对它的关联。这种关联没有及时被打断，在绝大部分情况下影响都是很轻微的，但如果遇到一个方法，其后的代码有一些耗时很长的操作，而前面有定义了占用大量内存，实际上已经不会再使用的变量，手动将其设置为null（用来代替a=0，把变量对应的局部变量表Slot清空）便不见得是一个绝对无意义的操作。<br>但是我们不应该对赋null值的操作有过多的依赖，原因是：从编码角度将，<strong>以恰当的变量作用域来控制变量回收时间才是最优雅的解决办法</strong>。</p></blockquote><p>局部变量不像前面介绍的类变量那样存在“准备阶段”。类变量有两次赋初始值的过程，<br><strong>一次在准备阶段，赋予系统初始值。</strong><br><strong>另外一次在初始化阶段，赋予程序员定义的值。</strong><br>因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。<br><strong>但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的。不要认为Java中任何情况下都存在诸如整型变量默认为0，布尔变量默认为false等这样的默认值。</strong></p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈也常被称为操作栈，它是一个<strong>后入先出栈</strong>。同局部变量表一样，操作数栈的最大深度也是编译的时候被写入到方法表的Code属性的max_stacks数据项中。<br>　当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在<strong>方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作</strong>。例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。<br> 　操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类检验阶段的数据流分析中还要再次验证这一点。<strong>以iadd指令为例，这个指令用于整型数加法，这在执行时，最接近栈顶的两个元素的数据类型必须为int型，不能出现一个long和一个float使用iadd命令相加的情况</strong><br>　另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了，如下图所示：<br> <img src="栈之间的数据共享.png" alt="执行引擎"></p><hr><blockquote><p><strong>Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。</strong></p></blockquote><p>下面我们来讲解一下</p><blockquote><p>许多java虚拟机的执行引擎在执行java代码的时候都有<strong>解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择</strong>—-关于编译执行（JIT），在以后的文章中将会讲解。<br><strong>解释执行即对字节码逐条解释执行。</strong></p></blockquote><h3 id="基于栈的解释器执行过程"><a href="#基于栈的解释器执行过程" class="headerlink" title="基于栈的解释器执行过程"></a>基于栈的解释器执行过程</h3><p>本节准备一段java代码，看看虚拟机总实际是如何执行的：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int calc()&#123;</span><br><span class="line">int a=100;</span><br><span class="line">int b=200;</span><br><span class="line">int c =300;</span><br><span class="line">return (a+b)*c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javap命令看看它的字节码指令：<br> <img src="Slot.png" alt="执行引擎"><br>javap 提示这段代码需要深度位2的操作数栈和4个Slot的局部变量空间。我们通过图的方式来观察javap字节码指令执行中的代码，操作数栈和局部变量表的变化：<br><strong>偏移地址为0的指令的情况：</strong><br> <img src="解释器1.png" alt="执行引擎"></p><p> <strong>偏移地址为1的指令的情况：</strong><br> <img src="解释器2.png" alt="执行引擎"></p><p> <strong>偏移地址为11的指令的情况：</strong><br> <img src="解释器3.png" alt="执行引擎"></p><p> <strong>偏移地址为12的指令的情况：</strong><br> <img src="解释器4.png" alt="执行引擎"></p><p> <strong>偏移地址为13的指令的情况：</strong><br> <img src="解释器5.png" alt="执行引擎"></p><p> <strong>偏移地址为14的指令的情况：</strong><br> <img src="解释器6.png" alt="执行引擎"></p><p> <strong>偏移地址为16的指令的情况：</strong><br> <img src="解释器7.png" alt="执行引擎"></p><blockquote><p>上面的执行过程仅仅是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述…….更准确的说，实际情况会和上面描述的概念模型差距非常大，这种差距产生的原因是虚拟机中解析器和即时编译器都会对输入的字节码进行优化。</p></blockquote><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>　</p><blockquote><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(Dynamic<br>Linking)。通过前面类文件结构，我们知道在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为<strong>静态解析</strong>。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为<strong>动态连接</strong>。</p></blockquote><h3 id="方法返回值地址"><a href="#方法返回值地址" class="headerlink" title="方法返回值地址"></a>方法返回值地址</h3><p><strong>当一个方法被执行后，有两种方式退出这个方法。</strong> </p><blockquote><p>第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口(Normal Method Invocation Completion)。<br>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口(Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。</p></blockquote><p>无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说， </p><ul><li>方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。 </li><li>而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。</li></ul><p><strong>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：</strong> </p><blockquote><p>①.恢复上层方法的局部变量表和操作数栈，<br>②.把返回值(如果有的话)压入调用都栈帧的操作数栈中，<br>③.调用PC计数器的值以指向方法调用指令后面的一条指令等。</p></blockquote><h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。<br>所以可以说栈帧分为三部分：<strong>局部变量区、操作数栈和栈帧信息</strong>。</p><hr><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>　<strong>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。</strong><br>Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于直接引用）。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期才能确定目标方法的直接引用。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><blockquote><p><strong>所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用。 在类加载的解析阶段会将一部分符号引用转化为直接引用</strong>，这种解析能成功的前提是：<strong>方法在程序真正运行之前就有一个课确定的调用版本，并且这个方法的调用版本在运行期是不可变的。</strong>也就是说，调用目标在程序代码写好，编译器进行编译时就确定下来，<strong>这类方法的调用称为解析（Resolution）</strong>。</p></blockquote><p>　在java语言中满足“编译期确定，运行期不变”的方法有<strong>静态方法和私有方法两大类</strong>。前者与类型直接关联，后者在外部不可被访问，这两种方式各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合<strong>在类加载阶段进行解析</strong>。<br>　与之相对应的是 ，在Java虚拟机里提供了5条方法调用字节码指令(实际上在JVM jdk 1.6层面只有前面四种方法调用的指令)，分别如下：<br>　1).invokestatic：调用静态方法<br>　2).invokespecial：调用类实例的构造器&lt; init&gt;方法、私有方法和父类方法<br>　3).invokevirtual：调用所有的虚方法<br>　4).invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。<br>　5).invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。 </p><p>通过以上描述，我们可以得出下面两种概念：<br><strong>非虚方法</strong>：只要能被invokestatic和invokespecial指令调用的方法，都可以在类加载的时候把符号引用解析为该方法的直接引用。这里主要是指，私有方法，静态方法，实例构造器，父类方法.（Java中明确说明了final方法是一种非虚方法，虽然被invokevirtual调用，但它无法被覆盖，没有其它版本）<br><strong>虚方法（除去final方法）</strong>，被invokevirtual和invokeinterface调用的则为虚方法，因为在编译期间并不能确定要调用的真正方法，所以称为虚方法。<br>示例如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class StaticResolution &#123;</span><br><span class="line">public static void sayHello()&#123;</span><br><span class="line">System.out.println("hello world");</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">StaticResolution.sayHello();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javap命令查看字节码如下：<br> <img src="invokestatic.png" alt="执行引擎"><br> 我们发现的确是通过invokestatic命令来调用sayHello（）方法的</p><p> 对于被final修饰的方法，虽然final方法是使用invokevirtual指令来调用，但是由于它无法被覆盖，没有其他的版本，所以也无须对方法接受者进行多态选择，又或者说多态选择的结果肯定是唯一的。<strong>在java语言规范中明确说明了final方法是一种非虚方法</strong>。</p><p> <strong>解析调用</strong>一定是个静态的过程，在编译期间就完全确定，在<strong>类装载的解析阶段就会把符号引用转为直接引用</strong>，不会延迟到运行期再去完成。而<strong>分派(Dispatch)调用</strong>则可能是静态的也可能是动态的，根据分派依据的宗量数(本文后面有讲)可分为单分派和多分派。这两类分派方式的两两组合就构成了<strong>静态单分派、静态多分派、动态单分派、动态多分派</strong>4种分派组合情况。</p><hr><h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p><strong>众所周知java面向对象的三个重要特性，封装、继承、多态。而在jvm层面多态的实现由分派完成。分派有静态分派、动态分派。</strong> </p><h4 id="静态分派–代表重载"><a href="#静态分派–代表重载" class="headerlink" title="静态分派–代表重载"></a>静态分派–代表重载</h4><p>在讲解之前，我们先看下面的代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class StaticDispatch &#123;</span><br><span class="line">    static abstract class Human &#123;&#125;</span><br><span class="line"></span><br><span class="line">    static class Man extends Human &#123;&#125;</span><br><span class="line"></span><br><span class="line">    static class Woman extends Human &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello(Human human) &#123;</span><br><span class="line">        System.out.println("hello human");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello(Man man) &#123;</span><br><span class="line">        System.out.println("hello man");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello(Woman woman) &#123;</span><br><span class="line">        System.out.println("hello woman");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Human man = new Man();</span><br><span class="line">        Human woman = new Woman();</span><br><span class="line"></span><br><span class="line">        StaticDispatch sr = new StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello ,guy!</span><br><span class="line">hello ,guy!</span><br></pre></td></tr></table></figure><p><strong>为什么会出现上面的结果呢？？？我们来看看反编译的结果</strong>：<br> <img src="反编译.png" alt="执行引擎"></p><p>解决以上 问题之前，我们先解释两个重要的概念：<br>Human man = new Man();<br>代码里的<strong>Human称为静态类型（或者叫外观类型</strong>）：其变化仅在使用时发生，变量本身的静态类型不会改变，并且最终的静态类型是在编译期可知的。<br>而<strong>Man称为实际类型</strong>：其变化的结果在运行期才可确定，编译器不编译程序时并不知道一个对象的实际类型是什么。</p><blockquote><p>main()方法的两次sayHello方法的调用，在方法接收者已经确定是对象sr的前提下，使用哪个重载版本，<strong>完全取决于传入参数的数量和数据类型</strong>，代码中刻意定义了<strong>两个静态类型相同但实际类型不同的变量</strong>，但虚拟机（准确的说是编译器）在重载时通过参数的静态类型，而不是实际类型作为判定依据。<br> 而且通过以上的反编译结果我们可以发现，<strong>man和woman在编译的时候被强转成了Human类型</strong>，所以导致上面的结果</p></blockquote><p><strong>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派</strong>。 </p><blockquote><p>静态分派典型的应用是方法重载(虚拟机准确的说是编译器，在重载时是通过参数的静态类型而不是实际类型作为判定依据的)<br>静态分派发生在编译阶段(也就是说在编译期是可知的)，因此确定静态分派的动作实际上不是由虚拟机来执行的<br>对于方法参数的匹配也是根据变量的静态类型来确定，在很多情况下根据参数的类型并不能找到”唯一的”方法调用，这个时候的处理方式是找到一个”最合适’的方法。</p></blockquote><p>如下代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class OverLoad &#123;</span><br><span class="line">    public static void sayHello(char arg) &#123;</span><br><span class="line">        System.out.println("hello char");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(int arg) &#123;</span><br><span class="line">        System.out.println("hello int");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(long arg) &#123;</span><br><span class="line">        System.out.println("hello long");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(Character arg) &#123;</span><br><span class="line">        System.out.println("hello Character");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(Serializable arg) &#123;</span><br><span class="line">        System.out.println("hello Serializable");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(Object arg) &#123;</span><br><span class="line">        System.out.println("hello object");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(char ...arg) &#123;</span><br><span class="line">        System.out.println("hello arg...");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        sayHello('a');</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从头注解方法，结果会按顺序输出。<br>注意:1、基本类型是重载按char-&gt;int-&gt;long-&gt;float-&gt;double顺序匹配的。<br>　　2、可变参数的重载优先级是最低的。</p><h4 id="动态分派–代表重写"><a href="#动态分派–代表重写" class="headerlink" title="动态分派–代表重写"></a>动态分派–代表重写</h4><p>想了解动态分派，必须先了解多态另一个体现—重写。如下示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicDispatch &#123;</span><br><span class="line">    static abstract class Human &#123;</span><br><span class="line">        protected abstract void sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Man extends Human &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void sayHello() &#123;</span><br><span class="line">            System.out.println("man say hello");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Woman extends Human &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void sayHello() &#123;</span><br><span class="line">            System.out.println("woman say hello");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Human man = new Man();</span><br><span class="line">        Human woman = new Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line"></span><br><span class="line">        man = new Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man say hello </span><br><span class="line">woman say hello </span><br><span class="line">woman say hello</span><br></pre></td></tr></table></figure><p>显然这里不可能再根据静态类型来决定，因为静态类型同样都是Human的两个变量man和woman在调用sayHello()方法时执行了不同的行为，并且变量在两次调用中执行了不同的方法。<br>导致这个现象的原因：是这两个变量的实际类型不同。<br>由于invokevirtual指令执行的第一步就是在运行期间确定接收者的实际类型，所以两次调用的invokevirtual指令把常量池中的类方法<strong>符号引用解析到了不同的直接引用</strong>上，这个过程就是Java语言方法重写的本质。这种<strong>在运行期间根据实际类型确定方法执行版本的过程称为动态分派</strong>。<br><strong>动态分派的一个重要体现就是方法的重写，虽然父类引用可以指向子类对象，但是动态分派的方法调用是在运行时根据对象的实际类型去确认的。</strong></p><h4 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h4><p><strong>方法的接收者与方法的参数称为方法的宗量。 单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。</strong></p><p>示例如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Dispatch &#123;</span><br><span class="line">static class QQ&#123;&#125;</span><br><span class="line">static class _360&#123;&#125;</span><br><span class="line">public static class Father&#123;</span><br><span class="line">public void hardChoice(QQ arg)&#123;</span><br><span class="line">System.out.println("father choose 11");</span><br><span class="line">&#125;</span><br><span class="line">public void hardChoice(_360 arg)&#123;</span><br><span class="line">System.out.println("father choose 360");</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static class Son extends Father&#123;</span><br><span class="line"><span class="comment">//重写父类的方法</span></span><br><span class="line">@Override</span><br><span class="line">public void hardChoice(QQ arg)&#123;</span><br><span class="line">System.out.println("son choose qq");</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void hardChoice(_360 arg)&#123;</span><br><span class="line">System.out.println("son choose 360");</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Father father = new Father();</span><br><span class="line">Father son = new Son();</span><br><span class="line">father.hardChoice(new _360());</span><br><span class="line">son.hardChoice(new QQ());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">father choose <span class="number">360</span> </span><br><span class="line">son choose qq</span><br></pre></td></tr></table></figure><p>看编译阶段编译器的选择过程，也就是静态分派的过程。这时选择目标方法的依据有两点：<strong>一是静态类型是Father还是Son，二是方法参数是QQ还是360。因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。</strong><br>再看运行阶段虚拟机的选择，也就是动态分派的过程。在执行“son.hardChoose(new QQ())”这句代码时（准确的说是在执行这句代码所对应的invokevirtual指令），由于编译期已经决定目标方法的签名必须为hardChoice(QQ)，虚拟机不会关心传递过来的参数”QQ”是什么，因为这时参数的静态类型、实际类型都对方的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有此方法的接收者的实际类型是Father还是Son。因为<strong>只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型</strong>。</p><p><strong>Java语言是一门静态多分派，动态单分派的语言</strong>。</p><h4 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h4><p>虚拟机在实际实现动态分派是基于性能考虑的。jvm在实现层面提供了一个叫做虚方法表的索引来代替元数据查找以提高性能，下面是书中的一张虚方法表结构图：<br> <img src="方法表结构.png" alt="执行引擎"></p><blockquote><p><strong>虚方法表中</strong>存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果重写了这个方法，子类方法表中的地址将会替换指向子类实现版本的入口地址。<br>Father是父类son是子类，并且子类重写了父类的连个方法，hardChoice(QQ),hardChoice(_360)，因此子类中的这两个方法指向了Son的类型数据，而这两个类都继承自Object且没重写它的任何方法，因此都指向了Object的类型数据。<br>方法表一般在类加载的链接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。</p></blockquote><hr><blockquote><p><strong><em>你敢不敢问自己到底要去哪里，<br>背负着恐惧寻找的终点，<br>非要是末路吗，<br>你能听到吗，<br>你还能听到吗，<br>你还有勇气直面你的恐惧吗？</em></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文章参考周志明的【深入理解Java虚拟机】&lt;br&gt;代码编译的结果从本地机器码转变成字节码，是存储格式发
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM，类加载" scheme="http://yoursite.com/tags/JVM%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解JVM】之五：虚拟机的类加载机制</title>
    <link href="http://yoursite.com/2017/10/04/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/10/04/虚拟机的类加载机制/</id>
    <published>2017-10-04T02:33:00.000Z</published>
    <updated>2017-12-05T06:49:06.257Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>本文章参考周志明的【深入理解Java虚拟机】<br>代码编译的结果从本地机器码转变成字节码，是存储格式发展的一小步，却是编译语言发展的一大步。</p></blockquote><p>虚拟机吧描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。<br>在java语言中，类型的加载，连接和初始化过程都是在程序运行期间完成的。</p><blockquote><p>注意： 以下所讲的Class文件并非特指某个存在于具体磁盘中的文件，应当是一串二进制的字节流。</p></blockquote><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><p>从类被加载到虚拟机内存中开始，到卸载出内存为止，类的生命周期包括加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段 。如下图：<br><img src="连接.png" alt="类加载"><br>　其中<strong>验证、准备和解析三部分称为连接</strong>，在Java语言中，类型的加载和连接过程都是在程序运行期间完成的（Java可以<strong>动态扩展的语言特性</strong>就是依赖运行期动态加载、动态连接这个特点实现的），这样会在类加载时稍微增加一些性能开销，但是却为Java应用程序提供高度的灵活性 。<br> <strong>加载、验证、准备、初始化和卸载</strong>这5个阶段的顺序是<strong>固定的</strong>（即：加载阶段必须在验证阶段开始之前开始，验证阶段必须在准备阶段开始之前开始等。这些阶段都是互相交叉地混合式进行的，通常会在一个阶段的执行过程中调用或激活另一个阶段），解析阶段则不一定，在某些情况下，解析阶段有可能在初始化阶段结束后开始，以支持Java的动态绑定。<br> 什么情况下需要开始类加载过程的加载阶段？<br> –Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><ol><li>遇到new（使用new关键字实例化对象）、getstatic（获取一个类的静态字段，final修饰符修饰的静态字段除外）、putstatic（设置一个类的静态字段，final修饰符修饰的静态字段除外）和invokestatic（调用一个类的静态方法）这4条字节码指令时，如果类还没有初始化，则必须首先对其初始化 </li><li>使用java.lang.reflect包中的方法对类进行反射调用时，如果类还没有初始化，则必须首先对其初始化 </li><li>当初始化一个类时，如果其父类还没有初始化，则必须首先初始化其父类 </li><li>当虚拟机启动时，需要指定一个主类（main方法所在的类），虚拟机会首选初始化这个主类 </li><li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li></ol><p>对于这5中会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“<strong>有且只有</strong>”，这5中场景中的行为称为对一个类进行<strong>主动引用</strong>。除此之外的方式都不会触发初始化，称为<strong>被动引用</strong>。<br><strong>被动引用的示例：</strong><br><strong>1.通过子类引用父类的静态字段，不会导致子类初始化</strong>。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class SuperClasses &#123;</span><br><span class="line">    public static int value = 123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println("SuperClasses init!");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SubClass extends SuperClasses &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println("SubClass init!");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class NotInitialization &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br>SuperClasses init!<br>123<br><strong>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只有父类会被初始化，子类不会被初始化（子类的调用方式不符合5种直接引用中的任何一种）。</strong><br>至于是否会触发子类的加载和验证，虚拟机规范没有明确规定，视虚拟机具体实现而定，对Hotspot虚拟机，可通过-XX:+TraceClassLoading参数看到此操作会导致子类的加载<br><img src="load.png" alt="类加载"><br>从图中我们可以看出，子类被加载，却没有初始化。<br><strong>2.通过数组定义的引用类，不会触发此类的初始化</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class NotInitialization &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        SuperClasses[] temp = new SuperClasses[10];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为空<br><strong>3.常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，所以不会触发定义常量的类的初始化</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ConstClass &#123;</span><br><span class="line">    public static final int A = 1;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println("ConstClass init!");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Test &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(ConstClass.A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br>1</p><p>在编译节阶段已将常量的值1存储到Test类的常量池中，对常量的Constant.A的引用实际上被转化为Test类对自身常量池的引用，这2个类在编译为Class文件后就没有任何关系了</p><blockquote><p><strong>注意：接口的加载过程与类加载过程不些不同</strong>，接口也有初始化的过程，虽然接口中不能使用静态代码块，但编译器仍然会为接口生成“<clinit>（）”类构造器，用于初始化接口中所定义的成员变量。<br><strong>接口与类真正的区别</strong>是前面讲得5种“有且仅有”需要开始初始化中的第3中：  当一个类初始化的时候，要求父类全部都已经初始化过了，但是一个接口在初始化时，不要求父类接口全部都完成初始化，只有在真正使用到接口（如使用到父类中定义的常量）时才会初始化。</clinit></p></blockquote><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>详解类加载的全过程，也就是加载、验证、准备、解析和初始化这5个阶段所执行的具体动作</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p><strong>1.通过“类全名”来获取定义此类的二进制字节流</strong><br>虚拟机规范对于“通过“类全名”来获取定义此类的二进制字节流”并没有指明二进制流必须要从一个本地class文件中获取，准确地说是根本没有指明要从哪里获取及怎样获取。例如：<br>　①.从Zip包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。<br>　②.从网络获取，常见应用Applet。<br>　③.运行时计算生成，这种场景使用的最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用ProxyGenerator.generateProxyClass来为特定接口生成$Prxoy的代理类的二进制字节流。<br>　④.由其他格式文件生成，典型场景：JSP应用<br>　⑤.从数据库中读取，这种场景相对少见，有些中间件服务器(如SAP Netweaver)可以选择把程序安装到数据库中来完成程序代码在集群间的分发<br> …………………….<br><strong>2.将字节流所代表的静态存储结构转换为方法区的运行时数据结构</strong><br>虚拟机规范并未规定方法区存储数据的具体数据结构，数据存储格式由虚拟机实现自行定义。<br><strong>3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口</strong><br>加载阶段完成后，虚拟机外部的<strong>二进制字节流</strong>就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式有虚拟机实现自行定义，虚拟机并未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较 特殊，它虽然是个对象，但在存放在方法区里!!!），这个对象作为程序访问方法区中的这些类型数据的外部接口。<br>加载阶段与链接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成，链接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于链接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。<br>相对于类加载过程的其他阶段，加载阶段(准备地说，是加载阶段中获取类的二进制字节流的动作)是开发期可控性最强的阶段，因为加载阶段可以使用系统提供的类加载器(ClassLoader)来完成，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。</p><hr><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>说到加载，不得不提到类加载器，下面就具体讲述下类加载器。<br>虚拟机设计者把类加载阶段中的“<strong>通过一个类的全限定名来获取描述此类的二进制字节流</strong>”这个动作放到java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块成为“类加载器”。<br>  类加载器虽然只用于实现类的<strong>加载动作</strong>，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它<strong>的类加载器和这个类本身</strong>一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们<strong>的类加载器不同</strong>，那这<strong>两个类就必定不相等</strong>。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。</p><h5 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h5><p><strong>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：</strong></p><ul><li><strong>启动类加载器</strong>：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分。</li><li><p><strong>所有其他的类加载器</strong>：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p><p><strong>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</strong></p></li><li><strong>启动类加载器：</strong>Bootstrap ClassLoader，跟上面相同。它负责加载存放在JDK\jre\lib(JDK代表<strong>JDK的安装目录，下同)下</strong>，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。<strong>启动类加载器是无法被Java程序直接引用的。</strong></li><li><strong>扩展类加载器</strong>：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），<strong>开发者可以直接使用扩展类加载器。</strong></li><li><strong>应用程序类加载器</strong>：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，<strong>开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</strong><br><strong>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。</strong>这些类加载器之间的关系一般如下图所示：<br><img src="ClassLoader.png" alt="类加载"><br>上图的这种层次关系称为<strong>类加载器的双亲委派模型</strong>。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。<br><strong>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</strong><br>使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是Java类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系，这对于<strong>保证Java程序的稳定运作很重要</strong>。例如，类java.lang.Object类存放在JDK\jre\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给<strong>启动类加载器进行加载</strong>，这边保证了Object类在程序中的<strong>各种类加载器中都是同一个类</strong>。</li></ul><hr><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：<strong>文件格式的验证、元数据的验证、字节码验证和符号引用验证。</strong></p><ul><li><strong>件格式的验证</strong>：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。</li><li><strong>元数据验证</strong>：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。</li><li><strong>字节码验证</strong>：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</li><li><strong>符号引用验证</strong>：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</li></ul><hr><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p> 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要<strong>注意</strong>：<br>    1、这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。<br>    2、这里所说的<strong>初始值</strong>“通常情况”下是数据类型的零值。假设一个类变量定义为:<br>                                                            public static int value = 12;<br>    那么变量value在准备阶段过后的初始值为<strong>0而不是12</strong>，因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器&lt; clinit&gt;()方法之中，所以把<strong>value赋值为12的动作将在初始化阶段</strong>才会被执行。<br> <strong>这里还需要注意如下几点：</strong></p><ul><li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li><li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li><li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。<br>下图列出了所有基本数据类型的零值：</li></ul><table><thead><tr><th>数据类型</th><th>零值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>short</td><td>（short）0</td></tr><tr><td>char</td><td>‘\u0000’</td></tr><tr><td>byte</td><td>(byte)0</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d</td></tr><tr><td>reference</td><td>null</td></tr></tbody></table><p>3、初始值“通常情况”下是零值，但在“特殊情况”下：如果类字段的字段属性表中包含<strong>ConstantValue属性</strong>，那在准备阶段变量就会被初始化为ConstantValue属性所指定的值，即如果a变量定义变为<strong>public final static int a = 1</strong>;，编译时javac会为a生成ConstantValue属性，准备阶段虚拟机就会根据ConstantValue的设置将a的值置为123。<br><strong>我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中。</strong></p><hr><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><strong>解析阶段是虚拟机将常量池内的符号引用特换成直接应用的过程</strong>。<br>a、<strong>符号引用(Symbolic References)</strong>：符号引用是一组符号来描述所引用的目标对象，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标对象并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因此符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。<br>b、<strong>直接引用(Direct References)</strong>：直接引用可以是直接指向目标对象的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机内存布局实现相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。<br>问：<strong>到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之</strong>后）？<br>答：<strong>虚拟机规范并没有规定解析阶段发生的具体时间，只要求了在执行anewarry、checkcast等16个用于操作符号引用的字节码指令之前，先对它们使用的符号引用进行解析，所以虚拟机实现会根据需要来判断</strong></p><p>对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行<strong>缓存</strong>（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。<br>    解析动作主要针<strong>对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</strong>七类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_InvokeDynamic_info七种常量类型。但是下面我们<strong>只讨论前四种</strong>。<br> 1、<strong>类或接口的解析</strong>：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。<br> 2、<strong>字段解析</strong>：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下图所示<br> <img src="解析.png" alt="类加载"></p><p> <strong>最后需要注意</strong>：理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。<strong>如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现</strong>，编译器可能会拒绝编译。如下代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class StaticTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(Child.m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Super &#123;</span><br><span class="line">public static int m = 11;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Father &#123;</span><br><span class="line">public static int m = 33;</span><br><span class="line">static &#123;</span><br><span class="line">System.out.println("执行了父类静态语句块");</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Father implements Super &#123;</span><br><span class="line">static &#123;</span><br><span class="line">System.out.println("执行了子类静态语句块");</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果编译不通过，会报如下错误：<br><img src="编译不通过.png" alt="类加载"></p><p>  3、类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。<br>  4、接口方法解析：与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类初始化阶段是“类加载过程”中最后一步，在之前的阶段，除了加载阶段用户应用程序可以通过自定义类加载器参与，其它阶段完全由虚拟机主导和控制，<strong>直到初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）</strong><br>在准备阶段，变量已经赋过一次初始值，在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其它资源，简单说，初始化阶段即虚拟机执行类构造器&lt; clinit&gt;()方法的过程，下面详细介绍下&lt; clinit&gt;方法：<br>①.&lt; clinit&gt;由编译器自动收集类中所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定，特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。示例如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class JavaTest&#123;</span><br><span class="line">static &#123;</span><br><span class="line">i = 2;                 //赋值而已编译通过</span><br><span class="line">System.out.println(i);    // 这句编译时会报“非法向前引用”</span><br><span class="line">&#125;</span><br><span class="line">static int i = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ②.类构造器&lt; clinit&gt;()方法与类的构造函数(实例构造函数&lt; init&gt;()方法)不同，它不需要显式调用父类构造，虚拟机会保证在子类&lt; clinit&gt;()方法执行之前，父类的&lt; clinit&gt;()方法已经执行完毕（<strong>这也意味着父类中定义的静态语句块要优于子类的变量赋值操作</strong>）。因此<strong>在虚拟机中的第一个执行的&lt; clinit&gt;()方法的类肯定是java.lang.Object</strong>。<br>③.&lt; clinit&gt;()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句，也没有变量赋值的操作，那么编译器可以不为这个类生成&lt; clinit&gt;()方法。<br>④.接口中不能使用静态语句块，，但是可以有<strong>类变量的赋值操作</strong>，故编译器也会对接口生成&lt; clinit&gt;()方法。但接口与类不同的是，执行接口的&lt; clinit&gt;()方法不需要先执行父接口的&lt; clinit&gt;()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt; clinit&gt;()方法。<br>⑤.虚拟机会保证一个类的&lt; clinit&gt;()方法在多线程环境中被正确加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程执行这个类的&lt; clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt; clinit&gt;()方法完毕。如果一个类的&lt; clinit&gt;()方法中有耗时很长的操作，那就可能造成多个进程阻塞。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLoopClass &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        <span class="keyword">if</span> (true) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + " init DeadLoopClass");</span><br><span class="line">            while (true)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Runnable script = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + " start");</span><br><span class="line">                DeadLoopClass dlc = new DeadLoopClass();</span><br><span class="line">                System.out.println(Thread.currentThread() + " run over");</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(script);</span><br><span class="line">        Thread t2 = new Thread(script);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>Thread[Thread-0,5,main]start<br>Thread[Thread-0,5,main]start<br>Thread[Thread-0,5,main]init  DeadLoopClass<br>一条线程在死循环以模拟长时间操作，另外的线程在阻塞等待。</p><hr><blockquote><p>你敢不敢问自己到底要去哪里，<br>背负着恐惧寻找的终点，<br>非要是末路吗，<br>你能听到吗，<br>你还能听到吗，<br>你还有勇气直面你的恐惧吗？</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;本文章参考周志明的【深入理解Java虚拟机】&lt;br&gt;代码编译的结果从本地机器码转变成字节码，是存储格式发展的一小步
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM，类加载" scheme="http://yoursite.com/tags/JVM%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>java的浅复制问题</title>
    <link href="http://yoursite.com/2017/10/03/java%E6%B5%85%E5%A4%8D%E5%88%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/10/03/java浅复制问题/</id>
    <published>2017-10-03T02:33:00.000Z</published>
    <updated>2017-10-03T04:31:25.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨天逛知乎看到一个java浅复制的问题，看到很多的解释我并不是很理解，所以今天特意写出来，讨论一下。</p><blockquote><p><strong>问题链接地址：（看一下链接的内容，然后下面的内容都是依据链接内容进行的分析）</strong><br><a href="https://www.zhihu.com/question/66099841/answer/238247431" target="_blank" rel="noopener">https://www.zhihu.com/question/66099841/answer/238247431</a></p></blockquote><h2 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么是浅复制呢？</p><blockquote><p>浅复制（shallow copy）只是复制了对象的引用，而不是对象本身的拷贝。</p></blockquote><p>如果你看到上面链接的内容，你应该对 “胖胖” 这位大V的回答有了一定的了解，对他回答的内容我表示基本赞同，但是我却又一些疑问。</p><ol><li>Integer定义的时候，数值在小于127的时候，里面的值都是从数组缓存中取出的（如果对着有疑问请看  <a href="http://fxkoutlook.cn/2017/09/27/Integer%E7%94%A8==%E6%AF%94%E8%BE%83%E6%97%B6127%E7%9B%B8%E7%AD%89128%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%8E%9F%E5%9B%A0/" target="_blank" rel="noopener">Integer= =比较时127相等128不相等的原因</a> ），也就是说同一个数应该是同一个对象。假如我们定义两个数数组a1，和a2，进行数组值的替换，代码如下：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a1 = new Integer[]&#123;12,23,34,45&#125;;</span><br><span class="line">Integer[] a2 = new Integer[4];</span><br><span class="line">System.arraycopy(a1, 0, a2, 0, a1.length); //使用System静态方法进行复制（各参数含义请查API）</span><br><span class="line">System.out.println("a1="+Arrays.toString(a1));</span><br><span class="line">System.out.println("a2="+Arrays.toString(a2));</span><br><span class="line">a2[1] = 3;</span><br><span class="line">System.out.println("a1="+Arrays.toString(a1));</span><br><span class="line">System.out.println("a2="+Arrays.toString(a2));</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a1=[<span class="number">12</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">45</span>]</span><br><span class="line">a2=[<span class="number">12</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">45</span>]</span><br><span class="line"></span><br><span class="line">a1=[<span class="number">12</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">45</span>]</span><br><span class="line">a2=[<span class="number">12</span>, <span class="number">3</span>, <span class="number">34</span>, <span class="number">45</span>]</span><br></pre></td></tr></table></figure><p><strong>从结果可以看出，在复制之后，a1，a2里的数据的值，不在是同一个对象，因为如果是浅复制的话，那么a1的值应该也会改变。</strong></p><p>通过以上的疑问，我产生了一下的怀疑：<br>1、是不是复制以后，两个数组里的值不再是同一个对象，然后改变一个数组的值后，另一个不在改变。<br>但是我看到 “胖胖” 大V最后的回答，我给予了否定，我们来看看他的代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个Node对象</span></span><br><span class="line">public class Node &#123;</span><br><span class="line">private int node;</span><br><span class="line">public Node(int node) &#123;</span><br><span class="line">this.node = node;</span><br><span class="line">&#125;</span><br><span class="line">public int getNode() &#123;</span><br><span class="line">return node;</span><br><span class="line">&#125;</span><br><span class="line">public void setNode(int node) &#123;</span><br><span class="line">this.node = node;</span><br><span class="line">&#125;</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return String.valueOf(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Node[] arr1 = new Node[10];</span><br><span class="line">Node[] arr2 = new Node[10];</span><br><span class="line">Arrays.fill(arr1, new Node(1));//将指定的 Node值分配给指定 Node 型数组的每个元素</span><br><span class="line">System.arraycopy(arr1, 0, arr2, 0, arr1.length);</span><br><span class="line">System.out.println("arr1="+Arrays.toString(arr1));</span><br><span class="line">System.out.println("arr2="+Arrays.toString(arr2));</span><br><span class="line">arr1[1].setNode(2);</span><br><span class="line">System.out.println("arr1="+Arrays.toString(arr1));</span><br><span class="line">System.out.println("arr2="+Arrays.toString(arr2));</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr1=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">arr2=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">arr1=[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">arr2=[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>通过上面的测试例子，我们可以说Node在arr1和arr2里的值指向了同一个引用。修改其中的一个我们可以改变另一个数组的值。所以我的以上的怀疑并不正确。</strong><br><strong>我也看过两个数组的 hashcode，虽然并不相等，但是这里不相等是因为，定义数组是两个数组对象，根据数组在堆中的存储，并且数组的值可以指向其他的引用，所以并不能说明任何问题。</strong></p><p>那到底是什么问题呢，其实我也不知道，如果有朋友知道这个问题的答案可以帮我解答一下吗？<br>下面附上我的邮箱：</p><blockquote><p>Gmail邮箱：<a href="mailto:foutlook6@gmail.com" target="_blank" rel="noopener">foutlook6@gmail.com</a><br>QQ邮箱：<a href="mailto:foutlook@qq.com" target="_blank" rel="noopener">foutlook@qq.com</a><br>如果你看到这篇文章，并且知道答案，如果你愿意把你的答案分享出去，请发送邮件或者加我微信，给与我解答，非常感谢！</p></blockquote><hr><p>刚刚写完文章就收到了”胖胖”大V的回复，他给我一个链接，我看了以后懵懵懂懂，链接如下：</p><blockquote><p><a href="https://www.zhihu.com/question/31203609" target="_blank" rel="noopener">java到底是值传递还是引用传递？</a><br>看了链接，<strong>我觉得问题应该出在=赋值操作上</strong>，我也没法解释了，有点迷茫。<br>如果谁有更好的解释，可以回复我，感激不尽。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;昨天逛知乎看到一个java浅复制的问题，看到很多的解释我并不是很理解
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="JavaSE，shallow copy" scheme="http://yoursite.com/tags/JavaSE%EF%BC%8Cshallow-copy/"/>
    
  </entry>
  
  <entry>
    <title>如何理解 String 类型值的不可变？</title>
    <link href="http://yoursite.com/2017/09/27/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%20String%20%E7%B1%BB%E5%9E%8B%E5%80%BC%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <id>http://yoursite.com/2017/09/27/如何理解 String 类型值的不可变/</id>
    <published>2017-09-27T14:09:00.000Z</published>
    <updated>2018-07-09T04:19:15.268Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>我们都知道String类的对象是一个典型的不可变对象，我们调用它的subString（），replace（），concat（）这些方法都不会影响它原来的值，只会返回一个新构建的对象。<br>如下图，给一个已有字符串”abc”第二次赋值成”abcde”，不是在原内存地址上修改数据，而是重新指向一个新对象，新地址。<br><img src="String1.png" alt="String"></p><h3 id="String为什么不可变？"><a href="#String为什么不可变？" class="headerlink" title="String为什么不可变？"></a>String为什么不可变？</h3><p>翻开源码如下：<br><img src="Stringchar.png" alt="String"><br>首先String类是用final关键字修饰，这说明String不可继承。再看下面，String类的主力成员字段value是个char[ ]数组，而且是用final修饰的。final修饰的字段创建以后就不可改变。因为虽然value是不可变，也只是value这个引用地址不可变。挡不住Array数组是可变的事实。<br>数组的本体结构在heap堆。String类里的value用final修饰，只是说stack里的这个叫value的引用地址不可变。没有说堆里array本身数据不可变。<br>如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final int[] value=&#123;1,2,3&#125;</span><br><span class="line">int[] another=&#123;4,5,6&#125;;</span><br><span class="line">value=another;    //编译器报错，final不可变</span><br></pre></td></tr></table></figure><p>value用final修饰，编译器不允许我把value指向堆区另一个地址。但如果我直接对数组元素动手，情况就会发生变化。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final int[] value=&#123;1,2,3&#125;;</span><br><span class="line">value[2]=100;  //这时候数组里已经是&#123;1,2,100&#125;</span><br></pre></td></tr></table></figure><p>所以为了保证String不可变，String类中把char类型的数组设置成private的，外界不允许访问，而且设计者把整个String类设计成final禁止继承，避免了String被改变。所以String是不可变的关键都在底层的实现，而不是一个final。</p><h3 id="String-不可变的好处"><a href="#String-不可变的好处" class="headerlink" title="String 不可变的好处"></a>String 不可变的好处</h3><p>1、不可变的好处，就要牵扯到字符串常量池了，只有当字符串是不可变的，字符串池才有可能实现。<strong>字符串池的实现可以在运行时节约很多heap空间</strong>，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么String interning将不能实现(译者注：String interning是指对不同的字符串仅仅只保存一个，即不会保存多个相同的字符串。)，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = "aaddcc";</span><br><span class="line">String s2 = "aaddcc";</span><br></pre></td></tr></table></figure><p><img src="String2.png" alt="String"><br>这样在大量使用字符串的情况下，可以节省内存空间，提高效率。但之所以能实现这个特性，String的不可变性是最基本的一个必要条件。要是内存里字符串内容能改来改去，这么做就完全没有意义了。</p><p>2、因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。<br>3、因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。<br>4、如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。</p><p>除了上面提到的String之外，常用的还有枚举类，以及java.lang.Number的部分子类，如Long和Double等数值包装类，BigInteger和BigDecimal等大数据类型。</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><p><strong>String的特性》</strong><br>1、String类是final的，不可被继承。<br>2、String类是的本质是字符数组char[], 并且其值不可改变。<br>3、String类对象有个特殊的创建的方式，就是直接指定比如String x = “abc”，”abc”就表示一个字符串对象。而x是”abc”对象的地址，也叫做”abc”对象的引用。<br>4、String对象可以通过“+”串联。串联后会生成新的字符串。<br>5、Java运行时会维护一个String Pool（String池），JavaDoc翻译很模糊“字符串缓冲区”。String池用来存放运行时中产生的各种字符串，并且池中的字符串的内容不重复。而一般对象不存在这个缓冲池，并且创建的对象仅仅存在于方法的堆栈区。<br>6、创建字符串的方式很多，归纳起来有三类：<br>其一，使用new关键字创建字符串，比如String s1 = new String(“abc”);<br>其二，直接指定。比如String s2 = “abc”;<br>其三，使用串联生成新的字符串。比如String s3 = “ab” + “c”;</p><p><strong>《String对象的创建》</strong><br>String对象的创建也有很多门道，关键是要明白其原理。</p><p>原理1：当使用任何方式来创建一个字符串对象s=X时，Java运行时（运行中JVM）会拿着这个X在String池中找是否存在内容相同的字符串对象，如果不存在，则在池中创建一个字符串s，否则，不在池中添加。<br>原理2：Java中，只要使用new关键字来创建对象，则一定会（在堆区或栈区）创建一个新的对象。<br>原理3：使用直接指定或者使用纯字符串串联来创建String对象，则仅仅会检查维护String池中的字符串，池中没有就在池中创建一个，有则罢了！但绝不会在堆栈区再去创建该String对象。<br>原理4：使用包含变量的表达式来创建String对象，则不仅会检查维护String池，而且还会在堆栈区创建一个String对象。</p><p><strong>《不可变类》</strong><br>JAVA为了提高效率，对String类型进行了特别的处理－－－为string类型提供了串池<br>定义一个string类型的变量有两种方式：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="built_in">name</span>= <span class="string">"tom "</span>;(String <span class="built_in">name</span>=<span class="string">"t"</span>+<span class="string">"o"</span>+<span class="string">"m"</span>的效果和此处是相同的)</span><br><span class="line"><span class="built_in">string</span> <span class="built_in">name</span> =new <span class="built_in">string</span>( <span class="string">"tom "</span>)</span><br></pre></td></tr></table></figure></p><p>如果你使用了第一种方式，那么当你在声明一个内容也是 “tom “的string时，它将使用串池里原来的那个内存，而不会重新分配内存，也就是说，string saname= “tom “,将会指向同一块内存。而如果用第二种方式，不管串池里有没有”tom”，它都会在堆中重新分配一块内存，定义一个新的对象。<br>另外关于string类型是不可改变的问题： string类型是不可改变的，也就是说，当你想改变一个string对象的时候，比如name= “madding “ 那么虚拟机不会改变原来的对象，而是生成一个新的string对象，然后让name去指向它，如果原来的那个 “tom “没有任何对象去引用它，虚拟机的垃圾回收机制将接收它。<br>最后，关于定义String的堆栈问题：String s =new String()分析堆与栈,是先定义S,还是先new string()？？？</p><p><strong>1</strong><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="keyword">str1 </span>= <span class="string">"abc"</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">System.out.println</span>(<span class="keyword">str1 </span>== <span class="string">"abc"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>步骤：<br>1) 栈中开辟一块空间存放引用str1；<br>2) String池中开辟一块空间，存放String常量”abc”；<br>3) 引用str1指向池中String常量”abc”；<br>4) str1所指代的地址即常量”abc”所在地址，输出为true；</p><p><strong>2</strong><br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(str2 == <span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure></p><p>步骤：<br>1) 栈中开辟一块空间存放引用str2；<br>2) 堆中开辟一块空间存放一个新建的String对象”abc”；<br>3) 引用str2指向堆中的新建的String对象”abc”；<br>4) str2所指代的对象地址为堆中地址，而常量”abc”地址在池中，输出为false；</p><p><strong>3</strong><br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str3 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(str3 == str2);</span><br></pre></td></tr></table></figure></p><p>步骤：<br>1) 栈中开辟一块空间存放引用str3；<br>2) 堆中开辟一块新空间存放另外一个(不同于str2所指)新建的String对象；<br>3) 引用str3指向另外新建的那个String对象 ；<br>4) str3和str2指向堆中不同的String对象，地址也不相同，输出为false；</p><p><strong>4</strong><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="keyword">str4 </span>= <span class="string">"a"</span> + <span class="string">"b"</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">System.out.println</span>(<span class="keyword">str4 </span>== <span class="string">"ab"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>步骤：<br>1) 栈中开辟一块空间存放引用str4；<br>2) 根据编译器合并已知量的优化功能，池中开辟一块空间，存放合并后的String常量”ab”；<br>3) 引用str4指向池中常量”ab”；<br>4) str4所指即池中常量”ab”，输出为true；</p><p><strong>5</strong><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">String</span> s = <span class="string">"a"</span>; <span class="comment">//注意:这里s用final修饰，相当于一个常量</span></span><br><span class="line"><span class="keyword">String</span> str5 = s + <span class="string">"b"</span>;</span><br><span class="line">System.out.<span class="built_in">println</span>(str5 == <span class="string">"ab"</span>);</span><br></pre></td></tr></table></figure></p><p>步骤：<br>同四</p><p><strong>6</strong><br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="built_in">s1</span> = <span class="string">"a"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span><span class="built_in">s2</span> = <span class="string">"b"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span><span class="keyword">str6 </span>= <span class="built_in">s1</span> + <span class="built_in">s2</span><span class="comment">;</span></span><br><span class="line"><span class="symbol">System.out.println</span>(<span class="keyword">str6 </span>== <span class="string">"ab"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>步骤：<br>1) 栈中开辟一块中间存放引用s1，s1指向池中String常量”a”，<br>2) 栈中开辟一块中间存放引用s2，s2指向池中String常量”b”，<br>3) 栈中开辟一块中间存放引用str5，<br>4) s1 + s2通过StringBuilder的最后一步toString()方法还原一个新的String对象”ab”，因此堆中开辟一块空间存放此对象，<br>5) 引用str6指向堆中(s1 + s2)所还原的新String对象，<br>6) str6指向的对象在堆中，而常量”ab”在池中，输出为false</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h3&gt;&lt;p&gt;我们都知道String类的对象是一个典型的不可变对象，我们调用它的subString（），replace（），concat（）这些方法都不会
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java，String" scheme="http://yoursite.com/tags/Java%EF%BC%8CString/"/>
    
  </entry>
  
  <entry>
    <title>Integer用==比较时127相等128不相等的原因</title>
    <link href="http://yoursite.com/2017/09/27/Integer%E7%94%A8==%E6%AF%94%E8%BE%83%E6%97%B6127%E7%9B%B8%E7%AD%89128%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <id>http://yoursite.com/2017/09/27/Integer用==比较时127相等128不相等的原因/</id>
    <published>2017-09-27T02:33:00.000Z</published>
    <updated>2018-07-09T04:13:01.421Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>关于以上问题，我们首先先看如下代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">         Integer a =1;</span><br><span class="line">         Integer b =2;</span><br><span class="line">         Integer c =3;</span><br><span class="line">         Integer d =3;</span><br><span class="line">         Integer e =321;</span><br><span class="line">         Integer f =321;</span><br><span class="line">         Long g = 3L;</span><br><span class="line">         System.out.println(c==d);            //true</span><br><span class="line">         System.out.println(e == f);         </span><br><span class="line">         System.out.println(c == (a+b));      //true</span><br><span class="line">         System.out.println(c.equals(a+b));   //true</span><br><span class="line">         System.out.println(g==(a+b));        //true</span><br><span class="line">         System.out.println(g.equals(a+b));   //false</span><br></pre></td></tr></table></figure><p>运行的结果为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>咱们来看看反编译的代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">         Integer a = Integer.valueOf(1);</span><br><span class="line">         Integer b = Integer.valueOf(2);</span><br><span class="line">         Integer c = Integer.valueOf(3);</span><br><span class="line">         Integer d = Integer.valueOf(3);</span><br><span class="line">         Integer e = Integer.valueOf(321);</span><br><span class="line">         Integer f = Integer.valueOf(321);</span><br><span class="line">         Long g = Long.valueOf(3L);</span><br><span class="line">         System.out.println(c == d);</span><br><span class="line">         System.out.println(e == f);</span><br><span class="line">         System.out.println(c.intValue() == a.intValue() + b.intValue());</span><br><span class="line">          System.out.println(c.equals(Integer.valueOf(a.intValue() + b.intValue())));</span><br><span class="line">         System.out.println(g.longValue() == (long) (a.intValue() + b.intValue()));</span><br><span class="line">          System.out.println(g.equals(Integer.valueOf(a.intValue() + b.intValue())));</span><br></pre></td></tr></table></figure><p>第一个输出语句是true，第二个输出语句出现false主要是加入自动拆装箱而出现的问题，而==比较的是两个对象是不是同一个对象，如果上面的结果推算，也就是e和f经过自动拆装箱之后生成的对象不再是一个，而c和d仍是统一个对象。<br>为什么会出现这种情况呢？<br>我们来看看cdef打印的地址：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印cdef的内存地址</span></span><br><span class="line">          System.out.println(c+"-"+d+":"+System.identityHashCode(c)+"-"+System.identityHashCode(d));</span><br><span class="line">          System.out.println(e+"-"+f+":"+System.identityHashCode(e)+"-"+System.identityHashCode(f));</span><br></pre></td></tr></table></figure><p>结果如下图所示：<br><img src="Image1.png" alt="Class"></p><p> 可以看出与我们推测的一样，cd经过自动装箱后认为同一个对象，而ef经过自动差装箱后不再为通过各对象，这主要是自动拆装箱带来的后果。<br>查看源码：<br>“从0到127不同时候自动装箱得到的是同一个对象”就只能有一种解释：自动装箱并不一定new出新的对象。<br>查看Integer.valueOf()源码如下：<br><img src="Image2.png" alt="Class"><br>其注释里就直接说明了-128到127之间的值都是直接从缓存中取出的。看看是怎么实现的：如果int型参数i在IntegerCache.low和IntegerCache.high范围内，则直接由IntegerCache返回；否则new一个新的对象返回。似乎IntegerCache.low就是-128，IntegerCache.high就是127了。<br>看看IntegerCache的源码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private static class IntegerCache &#123;</span><br><span class="line">        static final int low = -128;</span><br><span class="line">        static final int high;</span><br><span class="line">        static final Integer cache[];</span><br><span class="line">        static &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            int h = 127;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, 127);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">                &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line">            cache = new Integer[(high - low) + 1];</span><br><span class="line">            int j = low;</span><br><span class="line">            for(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = new Integer(j++);</span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            assert IntegerCache.high &gt;= 127;</span><br><span class="line">        &#125;</span><br><span class="line">        private IntegerCache() &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>果然在其static块中就一次性生成了-128到127直接的Integer类型变量存储在cache[]中，对于-128到127之间的int类型，返回的都是同一个Integer类型对象。<br>这下真相大白了，整个工作过程就是：Integer.class在装载（Java虚拟机启动）时，其内部类型IntegerCache的static块即开始执行，实例化并暂存数值在-128到127之间的Integer类型对象。当自动装箱int型值在-128到127之间时，即直接返回IntegerCache中暂存的Integer类型对象。<br>为什么Java这么设计？我想是出于效率考虑，因为自动装箱经常遇到，尤其是小数值的自动装箱；而如果每次自动装箱都触发new，在堆中分配内存，就显得太慢了；所以不如预先将那些常用的值提前生成好，自动装箱时直接拿出来返回。哪些值是常用的？就是-128到127了。<br>我们继续看第5和第6个输出语句，发现两种比较的方式，输出的结果却不同，为什么会这样呢？<br>通过<strong>反编译代码我们发现，第5个输出语句使用了强制类型转换，而第6个却没有</strong>，这又是为什么呢？<br>答：<strong>主要原因是包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱，，equals方法不处理数据转换的关系，所以第6句没有强制类型转换</strong>。<br>注意，<strong>Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的，Double、Float的valueOf方法的实现是类似的。</strong></p><p>我们来试验Double类型，如下代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println("-------Double---------");</span><br><span class="line">Double i1 = 100.0;</span><br><span class="line">Double i2 = 100.0;</span><br><span class="line">Double i3 = 200.0;</span><br><span class="line">Double i4 = 200.0;</span><br><span class="line">System.out.println(i1==i2);</span><br><span class="line">System.out.println(i3==i4);</span><br></pre></td></tr></table></figure><p>结果：<br>false<br>false<br>我们来看Double的valueof方法：<br><img src="Image4.png" alt="Class"><br>然后我们观察Boolean类型，代码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.println("-------Boolean--------");</span><br><span class="line">Boolean b1 = false;</span><br><span class="line">Boolean b2 = false;</span><br><span class="line">Boolean b3 = true;</span><br><span class="line">Boolean b4 = true;</span><br><span class="line">System.out.println(b1==b2);</span><br><span class="line">System.out.println(b3==b4);</span><br></pre></td></tr></table></figure><p>结果：<br>true<br>true<br>我们来看看Boolean的valueof方法<br><img src="Image5.png" alt="Class"></p><table><thead><tr><th>基本类型</th><th>==</th><th>equals</th></tr></thead><tbody><tr><td>字符串变量</td><td>对象的内存地址</td><td>内容</td></tr><tr><td>非字符串变量</td><td>地址</td><td>内容</td></tr><tr><td>基本类型</td><td>值</td><td>不可以（没有强制类型转换，不能使用）</td></tr><tr><td>包装类</td><td>地址（不同的包装类处理方式不同，Integer大小在127前在缓存中取，地址相同）</td><td>比较的是两边的包装类是否为同一个对象</td></tr></tbody></table><p>Integer包装类的equals方法：<br><img src="Image3.png" alt="Class"><br>我们看到包装类的equals方法主要是比较两边是不是同一个对像。</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><p><strong>int和Integer的区别</strong><br>1、Integer是int的包装类，int则是java的一种基本数据类型<br>2、Integer变量必须实例化后才能使用，而int变量不需要<br>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值<br>4、Integer的默认值是null，int的默认值是0</p><p><strong>关于Integer和int的比较</strong><br>1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Integer</span> i = <span class="keyword">new</span> <span class="built_in">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">Integer</span> j = <span class="keyword">new</span> <span class="built_in">Integer</span>(<span class="number">100</span>);</span><br><span class="line">System.<span class="keyword">out</span>.print(i == j); //<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>2、Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Integer</span> i = new <span class="keyword">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">int</span> j = <span class="number">100</span>；</span><br><span class="line">System.<span class="keyword">out</span>.<span class="built_in">print</span>(i == j); //true</span><br></pre></td></tr></table></figure><p>3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Integer</span> i = <span class="keyword">new</span> <span class="built_in">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">Integer</span> j = <span class="number">100</span>;</span><br><span class="line">System.<span class="keyword">out</span>.print(i == j); //<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Integer</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">Integer</span> j = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">System</span>.out.print(i == j); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Integer</span> i = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">Integer</span> j = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">System</span>.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;关于以上问题，我们首先先看如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java，自动拆装箱" scheme="http://yoursite.com/tags/Java%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解JVM】之四：字节码指令简介</title>
    <link href="http://yoursite.com/2017/09/26/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/09/26/字节码指令简介/</id>
    <published>2017-09-26T02:33:00.000Z</published>
    <updated>2017-09-30T06:21:13.994Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>java虚拟机的指令由一个字节长度的，代表着某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需参数（称为操作数）而构成。由于java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。</p><h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p>在java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息，例如，iload指令用于从局部变量表中加载int型的数据到操作数栈，而fload指令加载的则是float类型的数据。<br>对于大部分与数据类型相关的字节码指令，他们的操作码助记符中都有特殊的字符来表明专门为那种数据类型服务：i代表int类型，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference。也有一些指令的助记符中没有明确的指明操作符类型的字母，如arraylengh指令。<br>大部分的指令都没有支持整数类型byte，char和short，甚至没有任何指令支持boolean类型，编译器会在编译期或者运行期将byte和short类型的数据带符号扩展为相应的int类型数据，将boolean和char类型数据零位扩展为相应的int类型数据。与之相似，在处理boolean，byte，short和char类型数组时，也会转换成为使用对应的int类型的字节码指令来处理。</p><h3 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h3><p>加载和存储指令用于将数据在栈帧中的<strong>局部变量表和操作数栈之间</strong>来回传输，指令包括：</p><ul><li>将一个局部变量加载到操作数栈：iload，iload_<n>，lload，lload_<n>,fload，float_<n>,dload，dload_<n>，aload，aload_<n>。</n></n></n></n></n></li><li>将一个数值从操作数栈存储到局部变量表：istore,istore_<n>,lstore,lstore_<n>,fstore,fstore_<n>,dstore,dstore_<n>,astore,astore_<n>.</n></n></n></n></n></li><li>将一个常量加载到操作数栈：bipush,sipush , ldc,ldc_w , ldc2_w, aconst_null, iconst_ml, iconst_<i>,lconst_<l>, fconst_<f>, dconst_<d>.</d></f></l></i></li><li>扩充局部变量表的访问索引的指令：wide</li></ul><h3 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h3><p>运算或算术指令用于对两个操作数栈上的值惊醒某种特定运算，并把结果重新存入到操作数栈。</p><ul><li>加法指令：iadd，ladd，fadd，dadd</li><li>减法指令：isub，lsub，fsub，dsub</li><li>乘法指令：imul，lmul，fmul，dmul</li><li>除法指令：idiv，ldiv，fdiv，ddiv</li><li>求余指令：irem，lrem，frem，drem</li><li>取反指令：ineg，lneg，fneg，dneg</li><li>位移指令：ishl，ishr，iushr，lshl，lshr，lushr</li><li>按位或指令：ior，lor</li><li>按位与指令：iand，land</li><li>按位异或指令：ixor，lxor</li><li>局部变量自增指令：iinc</li><li>比较指令：dcmpg，dcmpl，fcmpg，fcmpl，lcmp</li></ul><h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><hr><blockquote><p>你敢不敢问自己到底要去哪里，<br>背负着恐惧寻找的终点，<br>非要是末路吗，<br>你能听到吗，<br>你还能听到吗，<br>你还有勇气直面你的恐惧吗？</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;java虚拟机的指令由一个字节长度的，代表着某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需参数（称为操作数）而构成
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM，Class类" scheme="http://yoursite.com/tags/JVM%EF%BC%8CClass%E7%B1%BB/"/>
    
  </entry>
  
</feed>

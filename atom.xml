<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Foutin</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-23T07:33:25.991Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Foutlook</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java8新特性</title>
    <link href="http://yoursite.com/2018/11/19/Java8/"/>
    <id>http://yoursite.com/2018/11/19/Java8/</id>
    <published>2018-11-19T01:00:00.000Z</published>
    <updated>2018-11-23T07:33:25.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>没有工作的生活感觉真的无聊</p></blockquote><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>自从毕业进入上家公司，感受到自己的无知和技术更新迭代速度是真的快。Java8中许多新特性都在ZStack中有所使用。故这里对Java8新特性进行总结一下。</p><p>近几年Java的发展的确挺快的，修改了许多令开发人员诟病的特性。正在逐渐吸收着其他语言的优点。我相信Java仍是许多项目中不可或缺的语言。前景仍然看好。</p><hr><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>官网表述：<br>Lambda表达式是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：函数式开发者非常熟悉这些概念。很多JVM平台上的语言（Groovy、Scala等）从诞生之日就支持Lambda表达式，但是早期Java开发者没有选择，只能使用<code>匿名内部类</code>代替Lambda表达式。</p><p>最简单的Lambda表达式可由逗号分隔的参数列表、-&gt;符号和语句块组成，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( e -&gt; System.out.println( e ) );</span><br></pre></td></tr></table></figure><p>在上面这个代码中的参数e的类型是由编译器<code>推理</code>得出的，你也可以显式指定该参数的类型，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( ( String e ) -&gt; System.out.println( e ) );</span><br></pre></td></tr></table></figure><p>如果Lambda表达式需要更复杂的语句块，则可以使用花括号将该语句块括起来，类似于Java中的函数体，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( e -&gt; &#123;</span><br><span class="line">    System.out.print( e );</span><br><span class="line">    System.out.print( e );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>Lambda表达式可以引用类成员和局部变量（会将这些变量隐式得转换成final的），例如下列两个代码块的效果完全相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String separator = <span class="string">","</span>;</span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( </span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String separator = <span class="string">","</span>;</span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( </span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br></pre></td></tr></table></figure><p>Lambda表达式有返回值，返回值的类型也由编译器推理得出。如果Lambda表达式中的语句块只有一行，则可以不用使用return语句，下列两个代码片段效果相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).sort( ( e1, e2 ) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> result = e1.compareTo( e2 );</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>Java8实现Lambda表达式其实就是让<code>行为参数化</code>，就是把一个行为当做方法的参数，以此达到和以前版本进行兼容的目的。</p><blockquote><p><strong>注意：</strong><br>Java 8的Lambda和匿名类和闭包是有一些不同的地方。<br>用科学的说法来说，闭包就是一个函数的实例，且它可以无限制地访问那个函数的非本地变量。例如，闭包可以作为参数传递给另一个函数。它也可以访问和修改其作用域之外的变量。<br>Java 8的Lambda和匿名类可以做类似于闭包的事情：它们可以作为参数传递给方法，并且可以访问其作用域之外的变量。但有一个<code>限制</code>：它们不能修改定义Lambda的方法的局部变量的内容。这些变量必须是<code>隐式最终</code>的。可以认为Lambda是对值封闭，而不是对变量封闭。这种限制存在的原因在于<code>局部变量保存在栈</code>上，并且隐式表示它们仅限于其所在线程。如果允许捕获可改变的局部变量，就会引发造成线程不安全的新的可能性，而这是我们不想看到的。</p></blockquote><hr><h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><p>Lambda的设计者们为了让现有的功能与Lambda表达式良好兼容，考虑了很多方法，于是产生了函数接口这个概念。<br><code>函数接口</code>指的是只有<code>一个函数的接口</code>，这样的接口可以隐式转换为Lambda表达式。java.lang.Runnable和java.util.concurrent.Callable是函数式接口的最佳例子。在实践中，函数式接口非常脆弱：只要某个开发者在该接口中添加一个函数，则该接口就不再是函数式接口进而导致编译失败。为了克服这种代码层面的脆弱性，并显式说明某个接口是函数式接口，Java 8 提供了一个特殊的注解<code>@FunctionalInterface</code>（Java 库中的所有相关接口都已经带有这个注解了），举个简单的函数式接口的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Functional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你用<code>@FunctionalInterface</code>定义了一个接口，而它却不是函数式接口的话，编译器将返回一个提示原因的错误。例如，错误消息可能是“Multiple non-overriding abstract methods found in interface Foo”，表明存在多个抽象方法。<br>看下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cumputer</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">start</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">communication</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demoInterface</span><span class="params">(Cumputer cumputer)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        demoInterface(name -&gt; &#123;</span><br><span class="line">            name += <span class="string">"a"</span>;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个时候 name += “a”这句就会报错，Lambda表达式无法推断出name的参数类型。如果指定name的类型。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        demoInterface((String name)-&gt; &#123;</span><br><span class="line">            name += <span class="string">"a"</span>;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>编译器会提示：<code>Multiple non-overriding abstract methods found in interface Foo</code>错误。函数接口只能允许有一个方法。所以<code>@FunctionalInterface</code>就可以提示开发者在修改接口的时候，这个接口是否允许多个方法行为。</p><p>请注意，<code>@FunctionalInterface</code>不是必需的，但对于为此设计的接口而言，使用它是比较好的做法。它就像是@Override标注表示方法被重写了。并且<code>默认方法</code>和<code>静态方法</code>不会破坏函数式接口的定义，因此如下的代码是合法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FunctionalDefaultMethods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h2><p>默认方法使得接口有点类似traits，不过要实现的目标不一样。默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。</p><p>默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Interfaces now allow default methods, the implementer may or </span></span><br><span class="line">    <span class="comment">// may not implement (override) them.</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">notRequired</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Default implementation"</span>; </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给java.util.Collection接口添加新方法，如stream()、parallelStream()、forEach()和removeIf()等等。</p><hr><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。<br>方法引用可以使用<code>::</code>。<br>定义了4个方法的Car这个类作为例子，区分Java中支持的4种不同的方法引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">create</span><span class="params">( <span class="keyword">final</span> Supplier&lt; Car &gt; supplier )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;              </span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">( <span class="keyword">final</span> Car car )</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Collided "</span> + car.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">( <span class="keyword">final</span> Car another )</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Following the "</span> + another.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repair</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        System.out.println( <span class="string">"Repaired "</span> + <span class="keyword">this</span>.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种方法引用是构造器引用，它的语法是Class::new，或者更一般的Class&lt; T &gt;::new。请注意构造器没有参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Car car = Car.create( Car::<span class="keyword">new</span> );</span><br><span class="line"><span class="keyword">final</span> List&lt; Car &gt; cars = Arrays.asList( car );</span><br></pre></td></tr></table></figure><p>第二种方法引用是静态方法引用，它的语法是Class::static_method。请注意这个方法接受一个Car类型的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.forEach( Car::collide );</span><br></pre></td></tr></table></figure><p>第三种方法引用是特定类的任意对象的方法引用，它的语法是Class::method。请注意，这个方法没有参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.forEach( Car::repair );</span><br></pre></td></tr></table></figure><p>最后，第四种方法引用是特定对象的方法引用，它的语法是instance::method。请注意，这个方法接受一个Car类型的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Car police = Car.create( Car::<span class="keyword">new</span> );</span><br><span class="line">cars.forEach( police::follow );</span><br></pre></td></tr></table></figure><hr><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。</p><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p><code>Stream</code> 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。<br>Stream 就如同一个<code>迭代器（Iterator）</code>，<code>单向</code>，<code>不可往复</code>，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。<br>而和迭代器又不同的是，Stream 可以<code>并行化</code>操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的<code>线程</code>中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的<code>Fork/Join 框架</code>（JSR166y）来拆分任务和加速处理过程。</p><h3 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤：<br>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。</p><p><strong>流管道 (Stream Pipeline) 的构成</strong><br><img src="stream.jpg" alt="1"></p><p><strong>流的操作类型分为三种：</strong></p><blockquote><ul><li>Intermediate（中间）：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li><li>Terminal（终点）：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果。</li><li>Short-Circuiting（短循环）：1.对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。<br>2.对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。<br>3.当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。</li></ul></blockquote><p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = widgets.stream()</span><br><span class="line">.filter(w -&gt; w.getColor() == RED)</span><br><span class="line"> .mapToInt(w -&gt; w.getWeight())</span><br><span class="line"> .sum();</span><br></pre></td></tr></table></figure><p>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。</p><p>流操作有两个重要的特点：</p><blockquote><ul><li>流水线——很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。这让我们下一章中的一些优化成为可能，如延迟和短路。流水线的操作可以看作对数据源进行数据库式查询。</li><li>内部迭代——与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li></ul></blockquote><h3 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h3><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。<br><strong>Intermediate：</strong></p><blockquote><p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、skip、 parallel、 sequential、 unordered</p></blockquote><p><strong>Terminal：</strong></p><blockquote><p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p></blockquote><p><strong>Short-circuiting：</strong></p><blockquote><p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p></blockquote><table><thead><tr><th>操作</th><th>类型</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td><code>map</code></td><td>中间</td><td><code>Stream&lt;R&gt;</code></td><td>map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。</td></tr><tr><td><code>flatMap</code></td><td>中间</td><td><code>Stream&lt;R&gt;</code></td><td>一对多， flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，看下面示例。</td></tr><tr><td><code>filter</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td>filter 对原始 Stream 进行某项过滤，通过过滤的元素被留下来生成一个新 Stream。</td></tr><tr><td><code>limit</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td>limit 返回 Stream 的前面 n 个元素；</td></tr><tr><td><code>skip</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td>skip 则是扔掉前 n 个元素</td></tr><tr><td><code>distinct</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td>找出不重复的单词</td></tr><tr><td><code>sorted</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序</td></tr><tr><td><code>min/max</code></td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)</td></tr><tr><td><code>forEach</code></td><td>终端</td><td><code>void</code></td><td>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。</td></tr><tr><td><code>findFirst</code></td><td>终端</td><td><code>Optional&lt;T&gt;</code></td><td>返回 Stream 的第一个元素，或者空</td></tr><tr><td><code>reduce</code></td><td>终端</td><td><code>Optional&lt;T&gt;</code></td><td>主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。</td></tr><tr><td><code>findAny</code></td><td>终端</td><td><code>Optional&lt;T&gt;</code></td><td>查找到任何一个就返回</td></tr><tr><td><code>collect</code></td><td>终端</td><td><code>R</code></td><td>收集结果</td></tr><tr><td><code>count</code></td><td>终端</td><td><code>long</code></td><td>计算个数</td></tr><tr><td><code>allMatch</code></td><td>终端</td><td><code>boolean</code></td><td>Stream 中全部元素符合传入的断言（ predicate），返回 true</td></tr><tr><td><code>anyMatch</code></td><td>终端</td><td><code>boolean</code></td><td>Stream 中只要有一个元素符合传入的断言predicate，返回 true</td></tr><tr><td><code>noneMatch</code></td><td>终端</td><td><code>boolean</code></td><td>Stream 中没有一个元素符合传入的 断言predicate，返回 true</td></tr></tbody></table><p>flatMap示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class="line"> Arrays.asList(<span class="number">1</span>),</span><br><span class="line"> Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"> );</span><br><span class="line">Stream&lt;Integer&gt; outputStream = inputStream.</span><br><span class="line">flatMap((childList) -&gt; childList.stream());</span><br></pre></td></tr></table></figure><p>reduce 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串连接，concat = "ABCD"</span></span><br><span class="line">String concat = Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>).reduce(<span class="string">""</span>, String::concat); </span><br><span class="line"><span class="comment">// 求最小值，minValue = -3.0</span></span><br><span class="line"><span class="keyword">double</span> minValue = Stream.of(-<span class="number">1.5</span>, <span class="number">1.0</span>, -<span class="number">3.0</span>, -<span class="number">2.0</span>).reduce(Double.MAX_VALUE, Double::min); </span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 有起始值</span></span><br><span class="line"><span class="keyword">int</span> sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 无起始值</span></span><br><span class="line">sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(Integer::sum).get();</span><br><span class="line"><span class="comment">// 过滤，字符串连接，concat = "ace"</span></span><br><span class="line">concat = Stream.of(<span class="string">"a"</span>, <span class="string">"B"</span>, <span class="string">"c"</span>, <span class="string">"D"</span>, <span class="string">"e"</span>, <span class="string">"F"</span>).</span><br><span class="line"> filter(x -&gt; x.compareTo(<span class="string">"Z"</span>) &gt; <span class="number">0</span>).</span><br><span class="line"> reduce(<span class="string">""</span>, String::concat);</span><br></pre></td></tr></table></figure><h3 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h3><p>即Collectors类提供的工厂方法（例如groupingBy）创建的收集器。它们主要提供了三大功能：</p><blockquote><ul><li>将流元素归约和汇总为一个值 </li><li>元素分组 </li><li>元素分区</li></ul></blockquote><p>Collectors类的静态工厂方法:</p><table><thead><tr><th>工厂方法</th><th>返回类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>toList</td><td><code>List&lt;T&gt;</code></td><td>把流中所有项目收集到一个List</td><td><code>List&lt;Dish&gt; dishes = menuStream.collect(toList());</code></td></tr><tr><td>toSet</td><td><code>Set&lt;T&gt;</code></td><td>把流中所有项目收集到一个Set，删除重复项</td><td><code>Set&lt;Dish&gt; dishes = menuStream.collect(toSet());</code></td></tr><tr><td>toCollection</td><td><code>Collection&lt;T&gt;</code></td><td>把流中所有项目收集到给定的供应源创建的集合</td><td><code>Collection&lt;Dish&gt; dishes = menuStream.collect(toCollection(),ArrayList::new);</code></td></tr><tr><td>counting</td><td><code>Long</code></td><td>计算流中元素的个数</td><td><code>long howManyDishes = menuStream.collect(counting());</code></td></tr><tr><td>summingInt</td><td><code>Integer</code></td><td>对流中项目的一个整数属性求和</td><td><code>int totalCalories = menuStream.collect(summingInt(Dish::getCalories));</code></td></tr><tr><td>averagingInt</td><td><code>Double</code></td><td>计算流中项目Integer属性的平均值</td><td><code>double avgCalories =menuStream.collect(averagingInt(Dish::getCalories));</code></td></tr><tr><td>summarizingInt</td><td><code>IntSummaryStatistics</code></td><td>收集关于流中项目Integer属性的统计值，例如最大、最小、总和与平均值</td><td><code>IntSummaryStatistics menuStatistics = menuStream.collect(summarizingInt(Dish::getCalories));</code></td></tr><tr><td>joining</td><td><code>Sring</code></td><td>连接对流中每个项目调用toString方法所生成的字符串</td><td><code>String shortMenu = menuStream.map(Dish::getName).collect(joining(&quot;, &quot;));</code></td></tr><tr><td>groupingBy</td><td><code>Map&lt;K, List&lt;T&gt;&gt;</code></td><td>根据项目的一个属性的值对流中的项目作问组，并将属性值作为结果Map的键</td><td><code>Map&lt;Dish.Type,List&lt;Dish&gt;&gt; dishesByType = menuStream.collect(groupingBy(Dish::getType));</code></td></tr><tr><td>partitioningBy</td><td><code>Map&lt;Boolean,List&lt;T&gt;&gt;</code></td><td>根据对流中每个项目应用谓词的结果来对项目进行分区</td><td><code>Map&lt;Boolean,List&lt;Dish&gt;&gt; vegetarianDishes = menuStream.collect(partitioningBy(Dish::isVegetarian));</code></td></tr></tbody></table><blockquote><p>在Java 7之前，并行处理数据集合非常麻烦。第一，你得明确地把包含数据的数据结构分成若干子部分。第二，你要给每个子部分分配一个独立的线程。第三，你需要在恰当的时候对它们进行同步来避免不希望出现的竞争条件，等待所有线程完成，最后把这些部分结果合并起来。Java 7引入了一个叫作分支/合并的框架，让这些操作更稳定、更不易出错。<br>我们简要地提到了Stream接口可以让你非常方便地处理它的元素：可以通过对收集源调用parallelStream方法来把集合转换为并行流。并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。这样一来，你就可以自动把给定操作的工作负荷分配给多核处理器的所有内核，让它们都忙起来。</p></blockquote><hr><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Java应用中最常见的bug就是空值异常。在Java 8之前，Google Guava引入了Optionals类来解决NullPointerException，从而避免源码被各种null检查污染，以便开发者写出更加整洁的代码。Java 8也将Optional加入了官方库。<br>你现在可以通过一种数据类型表示显式缺失的值——使用空指针的问题在于你无法确切了解出现空指针的原因，它是预期的情况，还是说由于之前的某一次计算出错导致的一个偶然性的空值，有了Optional之后你就不需要再使用之前容易出错的空指针来表示缺失的值了。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>empty</td><td>返回一个空的Optional实例</td></tr><tr><td>filter</td><td>如果值存在并且满足提供的谓词，就返回包含该值的Optional对象；否则返回一个空的Optional对象</td></tr><tr><td>flatMap</td><td>如果值存在，就对该值执行提供的mapping函数调用，返回一个Optional类型的值，否则就返回一个空的Optional对象</td></tr><tr><td>get</td><td>如果该值存在，将该值用Optional封装返回，否则抛出一个NoSuchElementException异常</td></tr><tr><td>ifPresent</td><td>如果值存在，就执行使用该值的方法调用，否则什么也不做</td></tr><tr><td>isPresent</td><td>如果值存在就返回true，否则返回false</td></tr><tr><td>map</td><td>如果值存在，就对该值执行提供的mapping函数调用</td></tr><tr><td>of</td><td>将指定值用Optional封装之后返回，如果该值为null，则抛出一个NullPointerException异常</td></tr><tr><td>ofNullable</td><td>将指定值用Optional封装之后返回，如果该值为null，则返回一个空的Optional对象</td></tr><tr><td>orElse</td><td>如果有值则将其返回，否则返回一个默认值</td></tr><tr><td>orElseGet</td><td>如果有值则将其返回，否则返回一个由指定的Supplier接口生成的值</td></tr><tr><td>orElseThrow</td><td>如果有值则将其返回，否则抛出一个由指定的Supplier接口生成的异常</td></tr></tbody></table><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt; String &gt; fullName = Optional.ofNullable( <span class="keyword">null</span> );</span><br><span class="line">System.out.println( <span class="string">"Full Name is set? "</span> + fullName.isPresent() );        </span><br><span class="line">System.out.println( <span class="string">"Full Name: "</span> + fullName.orElseGet( () -&gt; <span class="string">"[none]"</span> ) ); </span><br><span class="line">System.out.println( fullName.map( s -&gt; <span class="string">"Hey "</span> + s + <span class="string">"!"</span> ).orElse( <span class="string">"Hey Stranger!"</span> )</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Full Name is set? <span class="keyword">false</span></span><br><span class="line">Full Name: [none]</span><br><span class="line">Hey Stranger!</span><br></pre></td></tr></table></figure><hr><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><p>Java 8中引入全新的日期和时间API：<br>日期、时间、时区、Instant（跟日期类似但是精确到纳秒）、duration（持续时间）和时钟操作的类。</p><blockquote><ul><li>LocalDate</li><li>LocalTime</li><li>LocalDateTime</li><li>Instant</li><li>Duration</li><li>Period</li></ul></blockquote><p>在Java8之前的版本中，日期时间API存在很多的问题，比如：</p><blockquote><ul><li>线程安全问题：java.util.Date是非线程安全的，所有的日期类都是可变的；</li><li>设计很差：在java.util和java.sql的包中都有日期类，此外，用于格式化和解析的类在java.text包中也有定义。而每个包将其合并在一起，也是不合理的；</li><li>时区处理麻烦：日期类不提供国际化，没有时区支持，因此Java中引入了java.util.Calendar和Java.util.TimeZone类；</li></ul></blockquote><p>Java8重新设计了日期时间相关的API，Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。在java.util.time包中常用的几个类有：</p><blockquote><p>它通过指定一个时区，然后就可以获取到当前的时刻，日期与时间。Clock可以替换System.currentTimeMillis()与TimeZone.getDefault()<br>Instant:一个instant对象表示时间轴上的一个时间点，Instant.now()方法会返回当前的瞬时点（格林威治时间）；<br>Duration:用于表示两个瞬时点相差的时间量；<br>LocalDate:一个带有年份，月份和天数的日期，可以使用静态方法now或者of方法进行创建；<br>LocalTime:表示一天中的某个时间，同样可以使用now和of进行创建； LocalDateTime：兼有日期和时间；<br>ZonedDateTime：通过设置时间的id来创建一个带时区的时间；<br>DateTimeFormatter：日期格式化类，提供了多种预定义的标准格式；</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Clock clock = Clock.systemUTC();</span><br><span class="line">        Instant instant = clock.instant();</span><br><span class="line">        System.out.println(instant.toString());</span><br><span class="line"></span><br><span class="line">        LocalDate localDate = LocalDate.now();</span><br><span class="line">        System.out.println(localDate.toString());</span><br><span class="line"></span><br><span class="line">        LocalTime localTime = LocalTime.now();</span><br><span class="line">        System.out.println(localTime.toString());</span><br><span class="line"></span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        System.out.println(localDateTime.toString());</span><br><span class="line"></span><br><span class="line">        ZonedDateTime zonedDateTime = ZonedDateTime.now(ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line">        System.out.println(zonedDateTime.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p>Future是Java 5添加的类，用来描述一个异步计算的结果，但是获取一个结果时方法较少,要么通过轮询isDone，确认完成后，调用get()获取值，要么调用get()设置一个超时时间。但是这个get()方法会阻塞住调用线程，这种阻塞的方式显然和我们的异步编程的初衷相违背。<br>为了解决这个问题，JDK吸收了guava的设计思想，加入了Future的诸多扩展功能形成了CompletableFuture。</p><p>请看：</p><blockquote><p><a href="https://www.jianshu.com/p/6f3ee90ab7d3" target="_blank" rel="noopener">CompletableFuture 详解</a></p></blockquote><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java8 的新特性给开发带来了很大的便利性，ZStack中用到了很多Java8的新特性。以前看Java8的新特性都是一知半解，因为没有在项目中应用到，当使用过以后，你会发现理解起来也是挺容易的。</p><blockquote><p>实践才是最快的学习方式</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;没有工作的生活感觉真的无聊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;自从毕业进入上家公司，感受到自己的
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>zstack的自动化测试</title>
    <link href="http://yoursite.com/2018/11/01/zstack%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2018/11/01/zstack的自动化测试/</id>
    <published>2018-10-31T18:09:00.000Z</published>
    <updated>2018-11-15T08:25:20.071Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>把简单的事情做得出人意料的精彩</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>zstack是什么？<br>zstack是一个IaaS软件，可以通过API灵活的管理存储，网络，路由，计算，KVM等资源。<br>什么是自动化测试？<br>我们可以简单的理解为前期通过人工编码完成框架，后期来解放人力并自动完成规定的测试。在测试人员测试之前，开发人员已经完成很大部分的功能测试，测试人员只需要调用后者运行代码就可以看到测试结果。具体实现是：在自动化测试框架下，开发人员对自己负责的模块要达到基本覆盖测试代码。</p><h2 id="zstack的Integration-Test框架"><a href="#zstack的Integration-Test框架" class="headerlink" title="zstack的Integration Test框架"></a>zstack的Integration Test框架</h2><p>作为产品型的IaaS项目，ZStack非常重视测试，我们要求每个功能、用户场景都有对应的测试用例覆盖。ZStack的测试有多种维度，本文介绍后端Java开发人员使用的基于模拟器的Integration Test框架。</p><p>ZStack的运行过程中，实际上是管理节点进程(Java编写)通过HTTP PRC调用控制部署在数据中心各物理设备上的Agent（Python或Golang编写），如下图：<br><img src="test.jpg" alt="1"><br>在Integreation Test中，我们用模拟器（通过内嵌的Jetty Server）实现所有Agent HTTP RPC接口，每个用例的JVM进程就是一个自包含的ZStack环境，如图：<br><img src="Jetty.jpg" alt="1"></p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneVmBasicLifeCycleCase</span> <span class="keyword">extends</span> <span class="title">SubCase</span> </span>&#123;</span><br><span class="line">    EnvSpec env</span><br><span class="line"></span><br><span class="line">    def DOC = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">test a VM's start/stop/reboot/destroy/recover operations </span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        spring &#123;</span><br><span class="line">            sftpBackupStorage()</span><br><span class="line">            localStorage()</span><br><span class="line">            virtualRouter()</span><br><span class="line">            securityGroup()</span><br><span class="line">            kvm()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">environment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        env = OneVmBasicEnv.env()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        env.create &#123;</span><br><span class="line">            testStopVm()</span><br><span class="line">            testStartVm()</span><br><span class="line">            testRebootVm()</span><br><span class="line">            testDestroyVm()</span><br><span class="line">            testRecoverVm()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testRecoverVm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VmSpec spec = env.specByName(<span class="string">"vm"</span>)</span><br><span class="line"></span><br><span class="line">        VmInstanceInventory inv = recoverVmInstance &#123;</span><br><span class="line">            uuid = spec.inventory.uuid</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> inv.state == VmInstanceState.Stopped.toString()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// confirm the vm can start after being recovered</span></span><br><span class="line">        testStartVm()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testDestroyVm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VmSpec spec = env.specByName(<span class="string">"vm"</span>)</span><br><span class="line"></span><br><span class="line">        KVMAgentCommands.DestroyVmCmd cmd = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">        env.afterSimulator(KVMConstant.KVM_DESTROY_VM_PATH) &#123; rsp, HttpEntity&lt;String&gt; e -&gt;</span><br><span class="line">            cmd = JSONObjectUtil.toObject(e.body, KVMAgentCommands.DestroyVmCmd.class)</span><br><span class="line">            <span class="keyword">return</span> rsp</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        destroyVmInstance &#123;</span><br><span class="line">            uuid = spec.inventory.uuid</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> cmd != <span class="keyword">null</span></span><br><span class="line">        <span class="keyword">assert</span> cmd.uuid == spec.inventory.uuid</span><br><span class="line">        VmInstanceVO vmvo = dbFindByUuid(cmd.uuid, VmInstanceVO.class)</span><br><span class="line">        <span class="keyword">assert</span> vmvo.state == VmInstanceState.Destroyed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testRebootVm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// reboot = stop + start</span></span><br><span class="line">        VmSpec spec = env.specByName(<span class="string">"vm"</span>)</span><br><span class="line"></span><br><span class="line">        KVMAgentCommands.StartVmCmd startCmd = <span class="keyword">null</span></span><br><span class="line">        KVMAgentCommands.StopVmCmd stopCmd = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">        env.afterSimulator(KVMConstant.KVM_STOP_VM_PATH) &#123; rsp, HttpEntity&lt;String&gt; e -&gt;</span><br><span class="line">            stopCmd = JSONObjectUtil.toObject(e.body, KVMAgentCommands.StopVmCmd.class)</span><br><span class="line">            <span class="keyword">return</span> rsp</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        env.afterSimulator(KVMConstant.KVM_START_VM_PATH) &#123; rsp, HttpEntity&lt;String&gt; e -&gt;</span><br><span class="line">            startCmd = JSONObjectUtil.toObject(e.body, KVMAgentCommands.StartVmCmd.class)</span><br><span class="line">            <span class="keyword">return</span> rsp</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        VmInstanceInventory inv = rebootVmInstance &#123;</span><br><span class="line">            uuid = spec.inventory.uuid</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> startCmd != <span class="keyword">null</span></span><br><span class="line">        <span class="keyword">assert</span> startCmd.vmInstanceUuid == spec.inventory.uuid</span><br><span class="line">        <span class="keyword">assert</span> stopCmd != <span class="keyword">null</span></span><br><span class="line">        <span class="keyword">assert</span> stopCmd.uuid == spec.inventory.uuid</span><br><span class="line">        <span class="keyword">assert</span> inv.state == VmInstanceState.Running.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testStartVm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VmSpec spec = env.specByName(<span class="string">"vm"</span>)</span><br><span class="line"></span><br><span class="line">        KVMAgentCommands.StartVmCmd cmd = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">        env.afterSimulator(KVMConstant.KVM_START_VM_PATH) &#123; rsp, HttpEntity&lt;String&gt; e -&gt;</span><br><span class="line">            cmd = JSONObjectUtil.toObject(e.body, KVMAgentCommands.StartVmCmd.class)</span><br><span class="line">            <span class="keyword">return</span> rsp</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        VmInstanceInventory inv = startVmInstance &#123;</span><br><span class="line">            uuid = spec.inventory.uuid</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> cmd != <span class="keyword">null</span></span><br><span class="line">        <span class="keyword">assert</span> cmd.vmInstanceUuid == spec.inventory.uuid</span><br><span class="line">        <span class="keyword">assert</span> inv.state == VmInstanceState.Running.toString()</span><br><span class="line"></span><br><span class="line">        VmInstanceVO vmvo = dbFindByUuid(cmd.vmInstanceUuid, VmInstanceVO.class)</span><br><span class="line">        <span class="keyword">assert</span> vmvo.state == VmInstanceState.Running</span><br><span class="line">        <span class="keyword">assert</span> cmd.vmInternalId == vmvo.internalId</span><br><span class="line">        <span class="keyword">assert</span> cmd.vmName == vmvo.name</span><br><span class="line">        <span class="keyword">assert</span> cmd.memory == vmvo.memorySize</span><br><span class="line">        <span class="keyword">assert</span> cmd.cpuNum == vmvo.cpuNum</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> test socketNum, cpuOnSocket</span></span><br><span class="line">        <span class="keyword">assert</span> cmd.rootVolume.installPath == vmvo.rootVolumes.installPath</span><br><span class="line">        <span class="keyword">assert</span> cmd.useVirtio</span><br><span class="line">        vmvo.vmNics.each &#123; nic -&gt;</span><br><span class="line">            KVMAgentCommands.NicTO to = cmd.nics.find &#123; nic.mac == it.mac &#125;</span><br><span class="line">            <span class="keyword">assert</span> to != <span class="keyword">null</span>: <span class="string">"unable to find the nic[mac:$&#123;nic.mac&#125;]"</span></span><br><span class="line">            <span class="keyword">assert</span> to.deviceId == nic.deviceId</span><br><span class="line">            <span class="keyword">assert</span> to.useVirtio</span><br><span class="line">            <span class="keyword">assert</span> to.nicInternalName == nic.internalName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testStopVm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VmSpec spec = env.specByName(<span class="string">"vm"</span>)</span><br><span class="line"></span><br><span class="line">        KVMAgentCommands.StopVmCmd cmd = <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">        env.afterSimulator(KVMConstant.KVM_STOP_VM_PATH) &#123; rsp, HttpEntity&lt;String&gt; e -&gt;</span><br><span class="line">            cmd = JSONObjectUtil.toObject(e.body, KVMAgentCommands.StopVmCmd.class)</span><br><span class="line">            <span class="keyword">return</span> rsp</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        VmInstanceInventory inv = stopVmInstance &#123;</span><br><span class="line">            uuid = spec.inventory.uuid</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> inv.state == VmInstanceState.Stopped.toString()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> cmd != <span class="keyword">null</span></span><br><span class="line">        <span class="keyword">assert</span> cmd.uuid == spec.inventory.uuid</span><br><span class="line"></span><br><span class="line">        def vmvo = dbFindByUuid(cmd.uuid, VmInstanceVO.class)</span><br><span class="line">        <span class="keyword">assert</span> vmvo.state == VmInstanceState.Stopped</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        env.delete()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ZStack的Integreation Test使用groovy编写，通过JUnit运行。运行如下命令可以执行该case：</p><blockquote><p>cd /root/zstack/test<br>mvn test -Dtest=OneVmBasicLifeCycleCase</p></blockquote><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>从代码中可以看到所有Integration Test都继承SubCase类，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneVmBasicLifeCycleCase</span> <span class="keyword">extends</span> <span class="title">SubCase</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>并实现4个抽象函数：</p><blockquote><p>1.setup：配置用例，主要用于加载运行用例需要用到的ZStack服务和组件<br>2.environment： 构造测试环境，例如创建zone、cluster，添加host等操作<br>3.test：执行具体测试代码<br>4.clean：清理环境 （仅当该case在test suite中运行时执行，后文详述</p></blockquote><p>测试用例运行时，上述4个函数依次执行，任何一个环节出现错误则测试终止退出（case在test suite中运行时例外）。</p><p>一般在setup中，会将依赖的Bean按需加载进来。这在前面提到过；而environment则会构建出一个环境。Grovvy对DSL支持较好，所以整个环境的构建代码可读性极强，本质上每个DSL都对应了一个Spec，而Sepc对应了一个ZStack的SDK创建调用——即XXXAction。而XXXAction则通过HTTP调用ZStack的API接口。</p><p>在平时测试中大家可能直接Build一个环境对数据库进行操作，但是这在ZStack中并不是很好的方案。一个Iaas中的资源依赖及状态变动的关系是错综复杂的，因此调用外部的API来创建资源是一个明智的选择。同时也可以测试SDK和API的行为是否是期待的。</p><h3 id="模拟agent行为-灵活测试"><a href="#模拟agent行为-灵活测试" class="headerlink" title="模拟agent行为-灵活测试"></a>模拟agent行为-灵活测试</h3><p>ZStack Integreation Test最核心功能是通过基于Jetty的模拟器模拟真实环境下物理设备上安装的agent，例如模拟物理机上安装的KVM agent。当测试的场景涉及到后端agent调用时，我们需要捕获这些HTTP请求并进行验证，也可以伪造agent返回测试API逻辑。</p><p>如果看过ZStack的Case，可以看到很多类似的方法：</p><blockquote><ul><li>env.afterSimulator </li><li>env.simulator </li><li>env.message</li></ul></blockquote><p>这几个方法用来hook Message和HTTP Request。由于在ZStack中各个组件的通信都由Message来完成，对于Agent的请求则是统一通过HTTP来完成。这样在TestCase就可以任意模拟任何组件及agent的状态，让Case有极强的实用性——也保证了ManagentMent Node的逻辑健壮。</p><blockquote><p>具体的使用方式可以参考官网zstack测试部分的讲解</p></blockquote><h2 id="与Java-Web应用中MockMVC对比"><a href="#与Java-Web应用中MockMVC对比" class="headerlink" title="与Java Web应用中MockMVC对比"></a>与Java Web应用中MockMVC对比</h2><p>ZStack的SDK本质上是包装了一层HTTP Path，利用通用的协议便于开发者进行开发或测试。而在传统的Java WEB应用中，一般会通过MockMvc进行测试。其本质也是通过调用每个API的Path传参来进行测试。如下VMAgent测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySqlIntegrationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext context;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestCloudBus cloudBus;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Platform platform;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String UTF8 = <span class="string">"UTF-8"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mvc = MockMvcBuilders.webAppContextSetup(<span class="keyword">this</span>.context).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testModifyConfig</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String MY_CONF = <span class="string">"my.conf"</span>;</span><br><span class="line">        <span class="keyword">final</span> String APP_YML_FILE = <span class="string">"application.yml"</span>;</span><br><span class="line"></span><br><span class="line">        URL url = MyConfFileUtils.class.getClassLoader().getResource(APP_YML_FILE);</span><br><span class="line">        Assert.assertNotNull(url);</span><br><span class="line">        Path dirPath = Paths.get(url.toURI()).getParent();</span><br><span class="line">        Path currentPath = Paths.get(dirPath.toString(), MY_CONF);</span><br><span class="line"></span><br><span class="line">        String v = <span class="string">"testInsertAndDelete-str"</span>;</span><br><span class="line">        LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        map.put(MyConfConst.LOG_ERROR.getStringValue(), v);</span><br><span class="line"></span><br><span class="line">        ModifyMyConfDTO dto = <span class="keyword">new</span> ModifyMyConfDTO();</span><br><span class="line">        dto.setParams(map);</span><br><span class="line">        dto.setPath(currentPath.toString());</span><br><span class="line"></span><br><span class="line">        String param = JsonUtils.objectToJson(dto);</span><br><span class="line"></span><br><span class="line">        MvcResult result = mvc.perform(MockMvcRequestBuilders.put(<span class="string">"/mysql/conf"</span>)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .content(param))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andReturn();</span><br><span class="line"></span><br><span class="line">        String content = result.getResponse().getContentAsString();</span><br><span class="line">        Result response = JsonUtils.jsonToResult(content);</span><br><span class="line">        Assert.assertTrue(response.isSuccess());</span><br><span class="line">        Assert.assertNull(response.getData());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] fileContent = MyConfFileUtils.getContent();</span><br><span class="line"></span><br><span class="line">        Assert.assertTrue(<span class="keyword">new</span> String(fileContent, UTF8).contains(MyConfConst.LOG_ERROR.getStringValue()));</span><br><span class="line">        Assert.assertTrue(<span class="keyword">new</span> String(fileContent, UTF8).contains(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStartMySQL</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AtomicBoolean isIntercepterMessage = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        AtomicBoolean ishandleMessage = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        cloudBus.installIntercepter((FrontMessageIntercepter) msg -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> StartMySqlMsg) &#123;</span><br><span class="line">                isIntercepterMessage.set(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        cloudBus.hookMessage(StartMySqlMsg.class, msg -&gt; &#123;</span><br><span class="line">            StartMySqlMsg smsg = (StartMySqlMsg) msg;</span><br><span class="line">            ishandleMessage.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            MsgReply reply = <span class="keyword">new</span> MsgReply(smsg);</span><br><span class="line">            reply.setResult(Result.createBySuccess());</span><br><span class="line">            cloudBus.reply(reply);</span><br><span class="line">            <span class="keyword">return</span> reply;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        MvcResult result = mvc.perform(MockMvcRequestBuilders.post(<span class="string">"/mysql/start"</span>)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andReturn();</span><br><span class="line"></span><br><span class="line">        String content = result.getResponse().getContentAsString();</span><br><span class="line">        Result response = JsonUtils.jsonToResult(content);</span><br><span class="line">        Assert.assertTrue(response.isSuccess());</span><br><span class="line">        Assert.assertTrue(isIntercepterMessage.get());</span><br><span class="line">        Assert.assertTrue(ishandleMessage.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">........</span><br><span class="line">........</span><br></pre></td></tr></table></figure><p>从代码中可以看到MockMvc，发送请求到指定路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MvcResult result = mvc.perform(MockMvcRequestBuilders.post(<span class="string">"/mysql/start"</span>)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andReturn();</span><br></pre></td></tr></table></figure><p>后端接收到消息，可以hook其中的Msg，返回假的值。</p><h2 id="为什么使用自动化测试"><a href="#为什么使用自动化测试" class="headerlink" title="为什么使用自动化测试"></a>为什么使用自动化测试</h2><p>自动化测试好处很明显：</p><blockquote><p>保证软件质量，重复的活交给机器来做，避免繁琐重复的手动测试，节省人力；<br>为重构打下良好的基础：软件内部无论如何重构，对外部请求所返回的结果不应该有所变化；<br>保证核心类库的逻辑不遭受破坏，同时也可以作为使用的“样本”，由于没有业务逻辑的耦合，代码显得更加清楚，便于阅读；<br>…..</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;把简单的事情做得出人意料的精彩&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;zstack是什么？&lt;br&gt;zstack
      
    
    </summary>
    
      <category term="zstack" scheme="http://yoursite.com/categories/zstack/"/>
    
    
      <category term="zstack，自动化测试" scheme="http://yoursite.com/tags/zstack%EF%BC%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>facade设计模式和六大设计原则</title>
    <link href="http://yoursite.com/2018/10/24/facade%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2018/10/24/facade设计模式和六大设计原则/</id>
    <published>2018-10-24T01:00:00.000Z</published>
    <updated>2018-11-14T15:14:22.119Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>生活是具体的</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本周我在开发的时候，在补mysql主备搭建测试的时候，发现部分的代码兼容性不好，agent端代码使用的是springboot来管理的，在实际开发中是跑在VM上的，而测试的代码不能在本地运行，因为有些shell命名需要通过ssh发送到远程虚拟机上执行，而ssh连接这部分代码不太适合实际运行环境和开发环境都能测试这个要求，所以动手重构sshUtils代码。</p><h2 id="Facade设计模式"><a href="#Facade设计模式" class="headerlink" title="Facade设计模式"></a>Facade设计模式</h2><p> Facade设计模式：定义了一个高层、统一的接口，外部与通过这个统一的接口对子系统中的一群接口进行访问。通过创建一个统一的类，用来包装子系统中一个或多个复杂的类，客户端可以通过调用外观类的方法来调用内部子系统中所有方法。<br> <img src="facade.jpg" alt="1"></p><h3 id="使用Facade设计模式原因"><a href="#使用Facade设计模式原因" class="headerlink" title="使用Facade设计模式原因"></a>使用Facade设计模式原因</h3><p>1.实现客户类与子系统类的松耦合<br>2.降低原有系统的复杂度<br>3.提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。 </p><blockquote><p>引入外观角色之后，用户只需要与外观角色交互；<br> 用户与子系统之间的复杂逻辑关系由外观角色来实现</p></blockquote><h3 id="第一次重构"><a href="#第一次重构" class="headerlink" title="第一次重构"></a>第一次重构</h3><p>首先想到的不是通过设计模式来解决，而是直接在sshUtils中修改部分代码，把sshUtils中没有的功能添加进去，并创建一个类，ip地址默认是127.0.0.1，测试的代码就可以动态的修改这个ip，而线上环境就使用默认ip。这样就可以完美的解决ip不同的情况。</p><p>可是我后面遇到了两个问题：<br>第一：sshUtils中放入了业务代码<br>第二：如果是oracle也需要使用这个Utils，怎么办，无法复用。</p><h3 id="工具类和管理类的区别"><a href="#工具类和管理类的区别" class="headerlink" title="工具类和管理类的区别"></a>工具类和管理类的区别</h3><p>工具类：作为系统中通用的工具，不会牵扯到业务代码，也就是说工具类是无状态的<br>管理类：作用某一个场景下管理工具，里面会包含很多的业务代码，也就是说管理类是有状态的</p><h3 id="Facade模式的使用"><a href="#Facade模式的使用" class="headerlink" title="Facade模式的使用"></a>Facade模式的使用</h3><p>通过facade设计模式来解决上述问题，因为都是ssh操作，统一写一个外观模式，可以很好的统筹连接ssh的操作。牵扯到业务的功能代码，可以设计针对某一大业务的Impl。</p><p>facadeSsh最终代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SshFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行shell命令</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cmd     shell cmd</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ShellResult</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JSchException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Result <span class="title">execShellCmd</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> IOException, JSchException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行RemoteHostDTO ssh</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vo  vo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cmd cmd</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JSchException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Result <span class="title">execCmdOnRemote</span><span class="params">(RemoteHostDTO vo, String cmd)</span> <span class="keyword">throws</span> IOException, JSchException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取文件内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remotePath path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JSchException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SftpException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">readFile</span><span class="params">(String remotePath)</span> <span class="keyword">throws</span> JSchException, SftpException, IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到userInfo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> UserInfo</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><p>针对mysql业务的代码，首先想到的是继承SshFacade的实现类来设计，最后通过同事的指点，发现如果使用继承便会违反<code>依赖倒置原则</code>。如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySqlSshFacadeImpl</span> <span class="keyword">extends</span> <span class="title">SshFacadeImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SPEACE = <span class="string">"\t"</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SshInfo info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remotePath path 比如：/opt/exec/my.cnf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map        map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JSchException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SftpException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coverConfigFile</span><span class="params">(String remotePath, LinkedHashMap&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        Session session;</span><br><span class="line">        ChannelSftp sftp;</span><br><span class="line">        InputStream stream;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            session = JSCH.getSession(info.getSshUser(), info.getSshIp(), info.getSshPort());</span><br><span class="line">            session.setPassword(info.getSshPwd());</span><br><span class="line">            UserInfo ui = getUserInfo();</span><br><span class="line">            session.setUserInfo(ui);</span><br><span class="line">            session.connect(<span class="number">30000</span>);</span><br><span class="line">            sftp = (ChannelSftp) session.openChannel(<span class="string">"sftp"</span>);</span><br><span class="line">            sftp.connect();</span><br><span class="line">....................</span><br><span class="line">....................</span><br></pre></td></tr></table></figure><p>这里直接继承SshFacadeImpl，这样会导致高层次模块依赖了低层次模块，<strong>高层模块就是调用端，低层模块就是具体实现类。</strong>通过继承的方式<code>MySqlSshFacadeImpl</code>便无法继承其他的功能模块，而且当SshFacade接口发生改变的时候，对MySQLSshFacade不在适用的时候，便要修改MySQL这部分的代码。如果通过接口的方式，则不会这些这部分的问题。</p><h2 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h2><ul><li><p>单一职责（Single Responsibility），类或者对象最好是只有单一职责，在程序设计中如果发现某个类承担着多种义务，可以考虑进行拆分。</p></li><li><p>开关原则（Open-Close, Open for extension, close for modification），设计要对扩展开放，对修改关闭。换句话说，程序设计应保证平滑的扩展性，尽量避免因为新增同类功能而修改已有实现，这样可以少产出些回归（regression）问题。</p></li><li><p>里氏替换（Liskov Substitution），这是面向对象的基本要素之一，进行继承关系抽象时，凡是可以用父类或者基类的地方，都可以用子类替换。</p></li><li><p>接口隔离（Interface Segregation），我们在进行类和接口设计时，如果在一个接口里定义了太多方法，其子类很可能面临两难，就是只有部分方法对它是有意义的，这就破坏了程序的内聚性。<br>对于这种情况，可以通过拆分成功能单一的多个接口，将行为进行解耦。在未来维护中，如果某个接口设计有变，不会对使用其他接口的子类构成影响。</p></li><li><p>依赖反转（Dependency Inversion），或者<code>称依赖倒置</code>实体应该依赖于抽象而不是实现。也就是说高层次模块，不应该依赖于低层次模块，而是应该基于抽象。实践这一原则是保证产品代码之间适当耦合度的法宝。</p></li><li><p>迪米特法则（Law of Demeter），类间解耦，一个类对自己依赖的类知道的越少越好。自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。</p></li></ul><p><strong>一句话概括:</strong> <code>单一职责原则</code>告诉我们实现类要职责单一；<code>里氏替换原则</code>告诉我们不要破坏继承体系；<code>依赖倒置原则</code>告诉我们要面向接口编程；<code>接口隔离原则</code>告诉我们在设计接口的时候要精简单一；<code>迪米特法则</code>告诉我们要降低耦合。而<code>开闭原则</code>是总纲，他告诉我们要对扩展开放，对修改关闭。</p><blockquote><p>注意：现代语言发展很快，很多时候并不是完全准守前面的原则。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;生活是具体的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;本周我在开发的时候，在补mysql主备搭建测试的时候，发现
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，Java" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>IO与NIO</title>
    <link href="http://yoursite.com/2018/10/13/IO%E4%B8%8ENIO/"/>
    <id>http://yoursite.com/2018/10/13/IO与NIO/</id>
    <published>2018-10-13T01:00:00.000Z</published>
    <updated>2018-11-14T13:38:15.175Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>成功才是成功之母</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。</p><p>首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p><p>java.io 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。</p><p>第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p><p>第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续工作。</p><h2 id="java-NIO组成"><a href="#java-NIO组成" class="headerlink" title="java NIO组成"></a>java NIO组成</h2><p><code>通道</code> 和 <code>缓冲区</code> 是 NIO 中的核心对象，几乎在每一个 I/O 操作中都要使用它们。<br><strong>通道</strong>是对原 I/O 包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 <strong>Buffer</strong> 实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。</p><h3 id="什么是缓冲区"><a href="#什么是缓冲区" class="headerlink" title="什么是缓冲区"></a>什么是缓冲区</h3><p>Buffer 是一个对象， 它包含一些要写入或者刚读出的数据。 <strong>在 NIO 中加入 Buffer 对象，体现了新库与原 I/O 的一个重要区别。在面向流的 I/O 中，您将数据直接写入或者将数据直接读到 Stream 对象中。</strong><br>在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，您都是将它放到缓冲区中。<br>缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 仅仅 是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p><h3 id="缓冲区类型"><a href="#缓冲区类型" class="headerlink" title="缓冲区类型"></a>缓冲区类型</h3><p>最常用的缓冲区类型是 ByteBuffer。一个 ByteBuffer 可以在其底层字节数组上进行 get/set 操作(即字节的获取和设置)。<br>ByteBuffer 不是 NIO 中唯一的缓冲区类型。事实上，对于每一种基本 Java 类型都有一种缓冲区类型：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><h3 id="什么是通道"><a href="#什么是通道" class="headerlink" title="什么是通道"></a>什么是通道</h3><p>Channel是一个对象，可以通过它读取和写入数据。拿 NIO 与原来的 I/O 做个比较，通道就像是流。<br>正如前面提到的，所有数据都通过 Buffer 对象来处理。您永远不会将字节直接写入通道中，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p><p><strong>通道与流的不同之处</strong>在于通道是双向的。而流只是在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)， 而 通道 可以用于读、写或者同时用于读写。因为它们是双向的，所以通道可以比流更好地反映底层操作系统的真实情况。</p><h2 id="NIO中的读写"><a href="#NIO中的读写" class="headerlink" title="NIO中的读写"></a>NIO中的读写</h2><p>读和写是 I/O 的基本过程。从一个通道中读取很简单：只需创建一个缓冲区，然后让通道将数据读到这个缓冲区中。写入也相当简单：创建一个缓冲区，用数据填充它，然后让通道用这些数据来执行写入操作。<br>如下示例：我们以读取一个文件内容为示例，从文件中读文件需要三步：</p><blockquote><p>(1) 从 FileInputStream 获取 Channel<br>(2) 创建 Buffer<br> (3) 将数据从 Channel 读到Buffer 中。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从 FileInputStream 获取通道</span></span><br><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream( <span class="string">"fan.txt"</span> );</span><br><span class="line">FileChannel fc = fin.getChannel();</span><br><span class="line"><span class="comment">//创建缓冲区</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );</span><br><span class="line"><span class="comment">//将数据从通道读到缓冲区</span></span><br><span class="line">fc.read( buffer );</span><br></pre></td></tr></table></figure><p>写入文件过程类似：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从 FileOutputStream 获取通道</span></span><br><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream( <span class="string">"kai.txt"</span> );</span><br><span class="line">FileChannel fc = fout.getChannel();</span><br><span class="line"><span class="comment">//创建缓冲区</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );</span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="comment">//将数据从通道读到缓冲区</span></span><br><span class="line">fc.write( buffer );</span><br></pre></td></tr></table></figure></p><p>上面两个例子是读与写进行分开的，下面介绍读写结合：<br>三个基本操作：首先创建一个 <code>Buffer</code>，然后从源文件中将数据读到这个缓冲区中，然后将缓冲区写入目标文件。这个程序不断重复 ― 读、写、读、写 ― 直到源文件结束。<br>读写结合操作会使用到使用<code>clear()</code> 和 <code>flip()</code> 方法重设缓冲区，使它可以接受读入的数据。<code>flip()</code>方法让缓冲区可以将新读入的数据写入另一个通道。在从输入通道读入缓冲区之前，我们调用<code>clear()</code> 方法。同样，在将缓冲区写入输出通道之前，我们调用<code>flip()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream( <span class="string">"fan.txt"</span> );</span><br><span class="line">FileChannel fcin = fin.getChannel();</span><br><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream( <span class="string">"kai.txt"</span> );</span><br><span class="line">FileChannel fcout = fout.getChannel();</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">     buffer.clear();</span><br><span class="line">     <span class="keyword">int</span> r = fcin.read( buffer );</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span> (r==-<span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     buffer.flip();</span><br><span class="line">     fcout.write( buffer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓冲区详解"><a href="#缓冲区详解" class="headerlink" title="缓冲区详解"></a>缓冲区详解</h2><p><strong>本节将介绍 NIO 中两个重要的缓冲区组件：状态变量和访问方法 (accessor)。</strong><br>状态变量是前一节中提到的”内部统计机制”的关键。每一个读/写操作都会改变缓冲区的状态。通过记录和跟踪这些变化，缓冲区就可能够内部地管理自己的资源。<br>在从通道读取数据时，数据被放入到缓冲区。在有些情况下，可以将这个缓冲区直接写入另一个通道，但是在一般情况下，您还需要查看数据。这是使用 访问方法 get() 来完成的。同样，如果要将原始数据放入缓冲区中，就要使用访问方法 put()。</p><h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p>三个值指定缓冲区在任意时刻的状态：</p><ul><li>position</li><li>limit</li><li>capacity</li></ul><h4 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h4><p>缓冲区实际上就是美化了的数组。在从通道读取时，您将所读取的数据放到底层的数组中。 position 变量跟踪已经写了多少数据。更准确地说，它指定了下一个字节将放到数组的哪一个元素中。因此，如果您从通道中读三个字节到缓冲区中，那么缓冲区的 position 将会设置为3，指向数组中第四个元素。<br>同样，在写入通道时，您是从缓冲区中获取数据。 position 值跟踪从缓冲区中获取了多少数据。更准确地说，它指定下一个字节来自数组的哪一个元素。因此如果从缓冲区写了5个字节到通道中，那么缓冲区的 position 将被设置为5，指向数组的第六个元素。</p><h4 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h4><p>limit 变量表明还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。<br>position 总是小于或者等于 limit。</p><h4 id="Capacity"><a href="#Capacity" class="headerlink" title="Capacity"></a>Capacity</h4><p>缓冲区的 capacity 表明可以储存在缓冲区中的最大数据容量。实际上，它指定了底层数组的大小 ― 或者至少是指定了准许我们使用的底层数组的容量。<br>limit 决不能大于 capacity。</p><h3 id="状态变量的变化"><a href="#状态变量的变化" class="headerlink" title="状态变量的变化"></a>状态变量的变化</h3><p>出于本例子的需要，我们假设这个缓冲区的 总容量 为8个字节。<br>那么一开始的时候，limit和capacity应该在同一位置，都只想数组的尾部，如图：<br><img src="first.jpg" alt="1"><br>position 设置为0。如果我们读一些数据到缓冲区中，那么下一个读取的数据就进入 slot 0 。如果我们从缓冲区写一些数据，从缓冲区读取的下一个字节就来自 slot 0 。 position 设置如下所示：<br><img src="2.jpg" alt="1"><br><strong>第一次读取：</strong><br>现在我们可以开始在新创建的缓冲区上进行读/写操作。首先从输入通道中读一些数据到缓冲区中。第一次读取得到三个字节。它们被放到数组中从 position 开始的位置，这时 position 被设置为 0。读完之后，position 就增加到 3，如下所示：<br><img src="3.jpg" alt="1"><br><strong>第二次读取：</strong><br>在第二次读取时，我们从输入通道读取另外两个字节到缓冲区中。这两个字节储存在由 position 所指定的位置上， position 因而增加 2：<br><img src="4.jpg" alt="1"></p><p><strong>将数据写到输出通道中：</strong><br>在这之前，我们必须调用 flip() 方法。这个方法做两件非常重要的事：</p><blockquote><p>1.它将 limit 设置为当前 position。<br>2.它将 position 设置为 0。</p></blockquote><p>下面是在 flip 之后的缓冲区：<br><img src="5.jpg" alt="1"><br>我们现在可以将数据从缓冲区写入通道了。 position 被设置为 0，这意味着我们得到的下一个字节是第一个字节。 limit 已被设置为原来的 position。</p><p><strong>写入：</strong><br>limit在我们调用 flip() 时被设置为 5，并且 position 不能超过 limit。一次读取五个字节时，这使得 position 增加到 5，并保持 limit 不变，如下所示：<br><img src="6.jpg" alt="1"></p><p><strong>clear：</strong><br>最后一步是调用缓冲区的 clear() 方法。这个方法重设缓冲区以便接收更多的字节。 Clear 做两种非常重要的事情：</p><blockquote><p>1.它将 limit 设置为与 capacity 相同。<br>2.它设置 position 为 0。</p></blockquote><p>下图显示了在调用 clear() 后缓冲区的状态：<br><img src="7.jpg" alt="1"></p><h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><p>到目前为止，我们只是使用缓冲区将数据从一个通道转移到另一个通道。然而，程序经常需要直接处理数据。例如，您可能需要将用户数据保存到磁盘。在这种情况下，您必须将这些数据直接放入缓冲区，然后用通道将缓冲区写入磁盘。<br>或者，您可能想要从磁盘读取用户数据。在这种情况下，您要将数据从通道读到缓冲区中，然后检查缓冲区中的数据。<br>在本节的最后，我们将详细分析如何使用 ByteBuffer 类的 get() 和 put() 方法直接访问缓冲区中的数据。</p><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><p><strong>ByteBuffer 类中有四个 get() 方法：</strong></p><blockquote><p>1.byte get();<br>2.ByteBuffer get( byte dst[] );<br>3.ByteBuffer get( byte dst[], int offset, int length );<br>4.byte get( int index );</p></blockquote><p>第一个方法获取单个字节。第二和第三个方法将一组字节读到一个数组中。第四个方法从缓冲区中的特定位置获取字节。那些返回 ByteBuffer 的方法只是返回调用它们的缓冲区的 <code>this</code> 值。</p><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h4><p><strong>ByteBuffer 类中有五个 put() 方法：</strong></p><blockquote><p>1.ByteBuffer put( byte b );<br>2.ByteBuffer put( byte src[] );<br>3.ByteBuffer put( byte src[], int offset, int length );<br>4.ByteBuffer put( ByteBuffer src );<br>5.ByteBuffer put( int index, byte b );</p></blockquote><p>第一个方法 写入（put） 单个字节。第二和第三个方法写入来自一个数组的一组字节。第四个方法将数据从一个给定的源 ByteBuffer 写入这个 ByteBuffer。第五个方法将字节写入缓冲区中特定的 位置 。那些返回 ByteBuffer 的方法只是返回调用它们的缓冲区的 <code>this</code>值。</p><p><strong>关于缓存区的更多内容这里就不多介绍了，可以网上搜一些关于缓冲区的内容。</strong></p><h2 id="使用NIO进行网络连接"><a href="#使用NIO进行网络连接" class="headerlink" title="使用NIO进行网络连接"></a>使用NIO进行网络连接</h2><p>以前实现socket服务器方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  serverSocket.getLocalPort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                RequestHandler requestHandler = <span class="keyword">new</span> RequestHandler(socket);</span><br><span class="line">                requestHandler.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        DemoServer server = <span class="keyword">new</span> DemoServer();</span><br><span class="line">        server.start();</span><br><span class="line">        <span class="keyword">try</span> (Socket client = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), server.getPort())) &#123;</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span>                   InputStreamReader(client.getInputStream()));</span><br><span class="line">            bufferedReader.lines().forEach(s -&gt; System.out.println(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 简化实现，不做读取，直接发送字符串</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    RequestHandler(Socket socket) &#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());) &#123;</span><br><span class="line">            out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>在接收到客户端请求之前，服务器端都是阻塞的，如果是单线程的，每次只能处理单个请求，虽然可以通过加入线程池的方式解决，但是连接数不是很多时，这种方式可以工作的很好，但是如果连接数量急剧上升，这种方式就无法很好的工作了。因为线程上下文切换开销会在高并发时变得很明显，这是同步阻塞方式的低扩展性劣势。</strong></p><p><img src="socket.jpg" alt="1"></p><h3 id="为什么使用NIO连网"><a href="#为什么使用NIO连网" class="headerlink" title="为什么使用NIO连网"></a>为什么使用NIO连网</h3><p>关于这点不得不说，NIO的特性之一：<strong>多路复用机制</strong>。<br>首先我们先了解下面几个概念：</p><h4 id="Selectors"><a href="#Selectors" class="headerlink" title="Selectors"></a>Selectors</h4><p>NIO中连网核心对象名为<code>Selector</code>，Selector 就是您注册对各种 I/O 事件的兴趣的地方，而且当那些事件发生时，就是这个对象告诉您所发生的事件。<code>Selector</code>是 NIO 实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在 Selector 上的多个 <code>Channel</code>中，是否有 Channel 处于就绪状态，进而实现了单线程对多 Channel 的高效管理。<br><strong>我们需要做的第一件事就是创建一个 Selector：</strong></p><blockquote><p>Selector selector = Selector.open();</p></blockquote><p>然后，我们将对不同的通道对象调用 register() 方法，以便注册我们对这些对象中发生的 I/O 事件的兴趣。register() 的第一个参数总是这个 Selector。</p><h4 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h4><p>为了接收连接，我们需要一个 <code>ServerSocketChannel</code>。事实上，我们要监听的每一个端口都需要有一个 ServerSocketChannel 。对于每一个端口，我们打开一个 ServerSocketChannel，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">ssc.configureBlocking( <span class="keyword">false</span> );</span><br><span class="line">InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress( ports[i] );</span><br><span class="line">ss.bind( address );</span><br></pre></td></tr></table></figure><p>第一行创建一个新的 ServerSocketChannel ，最后三行将它绑定到给定的端口。第二行将 ServerSocketChannel 设置为 非阻塞的 。我们必须对每一个要使用的套接字通道调用这个方法。</p><h4 id="选择键"><a href="#选择键" class="headerlink" title="选择键"></a>选择键</h4><p>下一步是将新打开的 ServerSocketChannels 注册到 Selector上。为此我们使用 <code>ServerSocketChannel.register()</code> 方法，如下所示：</p><blockquote><p>SelectionKey key = ssc.register( selector, SelectionKey.OP_ACCEPT );</p></blockquote><p>register() 的第一个参数总是这个 Selector。第二个参数是 OP_ACCEPT，这里它指定我们想要监听 accept 事件，也就是在新的连接建立时所发生的事件。这是适用于 ServerSocketChannel 的唯一事件类型。</p><p>请注意对 register() 的调用的返回值。 SelectionKey 代表这个通道在此 Selector 上的这个注册。当某个 Selector 通知您某个传入事件时，它是通过提供对应于该事件的 SelectionKey 来进行的。SelectionKey 还可以用于取消通道的注册。</p><p><strong>下面将进入主循环</strong>。使用 Selectors 的几乎每个程序都像下面这样使用内部循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = selector.select();</span><br><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator it = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">     SelectionKey key = (SelectionKey)it.next();</span><br><span class="line">     <span class="comment">// ... deal with I/O event ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们调用 Selector 的<code>select()</code> 方法。这个方法会阻塞，直到至少有一个已注册的事件发生。当一个或者更多的事件发生时， select() 方法将返回所发生的事件的数量。<br>接下来，我们调用 Selector 的 <code>selectedKeys()</code> 方法，它返回发生了事件的 SelectionKey 对象的一个 集合 。<br>我们通过迭代 SelectionKeys 并依次处理每个 SelectionKey 来处理事件。对于每一个 SelectionKey，您必须确定发生的是什么 I/O 事件，以及这个事件影响哪些 I/O 对象。</p><h4 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Selector selector = Selector.open();</span><br><span class="line">             ServerSocketChannel serverSocket = ServerSocketChannel.open();) &#123;<span class="comment">// 创建 Selector 和 Channel</span></span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(), <span class="number">8888</span>));</span><br><span class="line">            serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 注册到 Selector，并说明关注点</span></span><br><span class="line">            serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                selector.select();<span class="comment">// 阻塞等待就绪的 Channel，这是关键点之一</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                   <span class="comment">// 生产系统中一般会额外进行就绪状态检查</span></span><br><span class="line">                    sayHelloWorld((ServerSocketChannel) key.channel());</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHelloWorld</span><span class="params">(ServerSocketChannel server)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (SocketChannel client = server.accept();) &#123;          client.write(Charset.defaultCharset().encode(<span class="string">"Hello world!"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        NIOServer server = <span class="keyword">new</span> NIOServer();</span><br><span class="line">        server.start();</span><br><span class="line">        <span class="keyword">try</span> (Socket client = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), server.getPort())) &#123;</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span>                   InputStreamReader(client.getInputStream()));</span><br><span class="line">            bufferedReader.lines().forEach(s -&gt; System.out.println(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤总结：</strong></p><blockquote><p>首先，通过 Selector.open() 创建一个 Selector，作为类似调度员的角色。<br>然后，创建一个 ServerSocketChannel，并且向 Selector 注册，通过指定SelectionKey.OP_ACCEPT，告诉调度员，它关注的是新的连接请求。注意，为什么我们要明确配置非阻塞模式呢？这是因为阻塞模式下，注册操作是不允许的，会抛出IllegalBlockingModeException 异常。<br>Selector 阻塞在 select 操作，当有 Channel 发生接入请求，就会被唤醒。</p></blockquote><h2 id="NIO与IO相比有什么优点"><a href="#NIO与IO相比有什么优点" class="headerlink" title="NIO与IO相比有什么优点"></a>NIO与IO相比有什么优点</h2><p>先看张图：<br><img src="selector.jpg" alt="1"></p><p><strong>NIO利用单线程轮询事件的机制</strong>，通过高效地定位就绪的Channel，来决定做什么，仅仅select阶段是阻塞的，可以有效避免大量客户端连接时，频繁切换带来的问题，应用的扩展能力有了非常大的提高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。<br>NIO 与原来的 I/O 有同样的作用和目的，但是它使用不同的方式 块 I/O。正如您将在本教程中学到的，块 I/O 的效率可以比流 I/O 高许多。</p><blockquote><p>NIO还有很多新的功能，比如文件的拷贝，零拷贝的特性等。这些功能放在下篇介绍。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;成功才是成功之母&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Java IO 方式有很多种，基于不同的 IO 抽象模
      
    
    </summary>
    
      <category term="NIO" scheme="http://yoursite.com/categories/NIO/"/>
    
    
      <category term="NIO，IO" scheme="http://yoursite.com/tags/NIO%EF%BC%8CIO/"/>
    
  </entry>
  
  <entry>
    <title>Java枚举</title>
    <link href="http://yoursite.com/2018/09/15/java%E6%9E%9A%E4%B8%BE/"/>
    <id>http://yoursite.com/2018/09/15/java枚举/</id>
    <published>2018-09-15T09:33:00.000Z</published>
    <updated>2018-11-13T09:59:47.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>所有的无能好像都来自于自我否定的借口</p></blockquote><p>枚举在开发中用到的地方颇多，今天就来总结一下。</p><h2 id="Enum定义"><a href="#Enum定义" class="headerlink" title="Enum定义"></a>Enum定义</h2><p>Enum是java 1.5引入的，枚举的引入给开发带来很大的便利性。<br>在没有Enum之前，我们定义一些常量时会用如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Constant</span> </span>&#123;</span><br><span class="line">    String CHECK_CODE = <span class="string">"check"</span>;</span><br><span class="line">    String DELETE_CODE = <span class="string">"delete"</span>;</span><br><span class="line">    String FORCE_DELETE_CODE = <span class="string">"forceDelete"</span>;</span><br><span class="line">    String CLEANUP_CODE = <span class="string">"cleanup"</span>;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码我们一般称之为常量接口(constant interface)——这种接口不包含任何方法，它只包含静态的final域，每个域都导出一个常量。<br>接口的定义，是为了通过实现，来表名某个类需要具体实现具体功能的细节，表明客户端对这个类的实例可以实现某些动作，为了其他的目的去定义接口不是接口设计的初衷。<br>常量接口是对接口的一种不良使用。</p><p>还有偶尔会在项目中看到如下风格的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DayDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MONDAY =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TUESDAY=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WEDNESDAY=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THURSDAY=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRIDAY=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SATURDAY=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUNDAY=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的代码一般被叫做int枚举模式。</p><p>类在内部使用某些常量，纯粹是实现细节，实现常量接口，会导致把这样的实现细节泄露到该类的导出API中，因为接口中所有的域都是及方法public的。类实现常量接口，这对于这个类的用户来讲并没有实际的价值。<br>那既然不适合存在全部都是导出常量的常量接口，那么如果需要导出常量，它们应该放在哪里呢？<strong>如果这些常量与某些现有的类或者接口紧密相关，就应该把这些常量添加到这个类或者接口中，注意，这里说添加到接口中并不是指的常量接口</strong>。在Java平台类库中所有的数值包装类都导出MIN_VALUE和MAX_VALUE常量。如果这些常量最好被看作是枚举类型成员，那就应该用枚举类型来导出。否则，应该使用不可实例化的工具类来导出这些常量。</p><p>使用enum定义常量，如下定义周一到周日的常量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举类型，使用关键字enum</span></span><br><span class="line"><span class="keyword">enum</span> Day &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY,</span><br><span class="line">    THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="枚举实现原理"><a href="#枚举实现原理" class="headerlink" title="枚举实现原理"></a>枚举实现原理</h2><p>实际上在使用关键字enum创建枚举类型并编译后，编译器会为我们生成一个相关的类，这个类继承了Java API中的java.lang.Enum类，也就是说通过关键字enum创建枚举类型在编译后事实上也是一个类类型而且该类继承自java.lang.Enum类。<br>看看反编译Day.class文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反编译Day.class</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Day</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//编译器为我们添加的静态的values()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Day[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Day[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum也类的valueOf方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Day <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Day)Enum.valueOf(com/zejian/enumdemo/Day, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//前面定义的7种枚举实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day MONDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day TUESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day WEDNESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day THURSDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day FRIDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SATURDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SUNDAY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Day $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//实例化枚举实例</span></span><br><span class="line">        MONDAY = <span class="keyword">new</span> Day(<span class="string">"MONDAY"</span>, <span class="number">0</span>);</span><br><span class="line">        TUESDAY = <span class="keyword">new</span> Day(<span class="string">"TUESDAY"</span>, <span class="number">1</span>);</span><br><span class="line">        WEDNESDAY = <span class="keyword">new</span> Day(<span class="string">"WEDNESDAY"</span>, <span class="number">2</span>);</span><br><span class="line">        THURSDAY = <span class="keyword">new</span> Day(<span class="string">"THURSDAY"</span>, <span class="number">3</span>);</span><br><span class="line">        FRIDAY = <span class="keyword">new</span> Day(<span class="string">"FRIDAY"</span>, <span class="number">4</span>);</span><br><span class="line">        SATURDAY = <span class="keyword">new</span> Day(<span class="string">"SATURDAY"</span>, <span class="number">5</span>);</span><br><span class="line">        SUNDAY = <span class="keyword">new</span> Day(<span class="string">"SUNDAY"</span>, <span class="number">6</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> Day[] &#123;</span><br><span class="line">            MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从反编译的代码可以看出编译器确实帮助我们<strong>生成了一个Day类(注意该类是final类型的，将无法被继承)而且该类继承自java.lang.Enum类</strong>，该类是一个抽象类(稍后我们会分析该类中的主要方法)，除此之外，编译器还帮助我们生成了7个Day类型的实例对象分别对应枚举中定义的7个日期，这也充分说明了我们前面使用关键字enum定义的Day类型中的每种日期枚举常量也是实实在在的Day实例对象，只不过代表的内容不一样而已。注意编译器还为我们生成了两个静态方法，分别是values()和 valueOf()，稍后会分析它们的用法，到此我们也就明白了，使用关键字enum定义的枚举类型，在编译期后，也将转换成为一个实实在在的类，而在该类中，会存在每个在枚举类型中定义好变量的对应实例对象，如上述的MONDAY枚举类型对应public static final Day MONDAY;，同时编译器会为该类创建两个方法，分别是values()和valueOf()。</p><h2 id="枚举的进阶用法"><a href="#枚举的进阶用法" class="headerlink" title="枚举的进阶用法"></a>枚举的进阶用法</h2><p>重新定义一个日期枚举类，带有desc成员变量描述该日期的对于中文描述，同时定义一个getDesc方法，返回中文描述内容，自定义私有构造函数，在声明枚举实例时传入对应的中文描述，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Day2 &#123;</span><br><span class="line">    MONDAY(<span class="string">"星期一"</span>),</span><br><span class="line">    TUESDAY(<span class="string">"星期二"</span>),</span><br><span class="line">    WEDNESDAY(<span class="string">"星期三"</span>),</span><br><span class="line">    THURSDAY(<span class="string">"星期四"</span>),</span><br><span class="line">    FRIDAY(<span class="string">"星期五"</span>),</span><br><span class="line">    SATURDAY(<span class="string">"星期六"</span>),</span><br><span class="line">    SUNDAY(<span class="string">"星期日"</span>);<span class="comment">//记住要用分号结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//中文描述</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造,防止被外部调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> desc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day2</span><span class="params">(String desc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc=desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义方法,返回描述,跟常规类的定义没区别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上述代码可知，在enum类中确实可以像定义常规类一样声明变量或者成员方法。</p><h2 id="关于StringValue的较佳实践"><a href="#关于StringValue的较佳实践" class="headerlink" title="关于StringValue的较佳实践"></a>关于StringValue的较佳实践</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SourceDiskType &#123;</span><br><span class="line"></span><br><span class="line">    SYSTEM(<span class="string">"system"</span>),</span><br><span class="line">    DATA(<span class="string">"data"</span>),;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String stringValue;</span><br><span class="line"></span><br><span class="line">    SourceDiskType(String stringValue) &#123;</span><br><span class="line">        setStringValue(stringValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStringValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStringValue</span><span class="params">(String stringValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stringValue = stringValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SourceDiskType <span class="title">getEnum</span><span class="params">(String stringValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == stringValue) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (SourceDiskType sourceDiskType : SourceDiskType.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sourceDiskType.getStringValue().equals(stringValue)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sourceDiskType;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是阿里云早期版本SDK中的一段代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;所有的无能好像都来自于自我否定的借口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;枚举在开发中用到的地方颇多，今天就
      
    
    </summary>
    
    
      <category term="Java，Enum" scheme="http://yoursite.com/tags/Java%EF%BC%8CEnum/"/>
    
  </entry>
  
  <entry>
    <title>Spring小记</title>
    <link href="http://yoursite.com/2018/09/09/Spring%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/09/09/Spring小记/</id>
    <published>2018-09-09T01:00:00.000Z</published>
    <updated>2018-11-23T07:33:11.884Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人生而迷茫吗？</p></blockquote><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>学了Spring框架那么久，也没有很好总结过，很长时间不用有马上都忘了，今天来总结一下。无论什么框架，<code>一切皆源于Java最底层的设计</code>。</p><hr><h2 id="为什么使用Spring"><a href="#为什么使用Spring" class="headerlink" title="为什么使用Spring"></a>为什么使用Spring</h2><p>Spring是最近最火的框架，是快速开发项目最不可或缺的。<br>Spring主要两个有功能为我们的业务对象管理提供了非常便捷的方法：</p><blockquote><ul><li>DI（Dependency Injection，依赖注入） </li><li>AOP（Aspect Oriented Programming，面向切面编程）</li></ul></blockquote><h2 id="Java-Bean"><a href="#Java-Bean" class="headerlink" title="Java Bean"></a>Java Bean</h2><p>每一个类实现了Bean的规范才可以由Spring来接管，那么Bean的规范是什么呢？</p><blockquote><ul><li>必须是个公有(public)类 </li><li>有无参构造函数 </li><li>用公共方法暴露内部成员属性(getter,setter)</li></ul></blockquote><p>实现这样规范的类，被称为Java Bean。即是一种可重用的组件。</p><hr><h2 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h2><p>简单来说，一个系统中可能会有成千上万个对象。如果要手工维护它们之间的关系，这是不可想象的。我们可以在Spring的XML文件描述它们之间的关系，由Spring自动来注入它们——比如A类的实例需要B类的实例作为参数set进去。</p><p>以前这种管理对象的方式称为：Inversion of Control, 简称IoC。 但是IoC这个词不能让人更加直观和清晰的理解背后所代表的含义， 于是Martin Flower先生就创造了一个新词 : 依赖注入 (Dependency Injection，简称DI)。</p><p>通过Spring容器管理的对象默认是单例的，基本过程是：</p><blockquote><ol><li>解析xml或通过注解, 获取各种元素</li><li>通过Java反射把各个bean 的实例创建起来。</li><li>通过Java反射调用类的两个方法：set/get，把实例注入进来</li></ol></blockquote><p>其实Spring的处理方式和上面说的非常类似， 当然Spring 处理了更多的细节，例如不仅仅是setter方法注入， 还可以构造函数注入，init 方法， destroy方法等等， 基本思想是一致的。<br><img src="DI.jpg" alt="DI"></p><p><strong>既然对象的创建过程和装配过程都是Spring做的， 那Spring 在这个过程中就可以玩很多把戏了， 比如对你的业务类做点字节码级别的增强， 搞点AOP什么的， 这都不在话下了。</strong></p><h2 id="面向切面编程（AOP）"><a href="#面向切面编程（AOP）" class="headerlink" title="面向切面编程（AOP）"></a>面向切面编程（AOP）</h2><p>在分布式开发中，把不同的模块进行解耦分离，但是分解以后就会发现有些很有趣的东西， 这些东西是通用的，或者是跨越多个模块的：</p><blockquote><p>日志： 对特定的操作输出日志来记录<br>安全：在执行操作之前进行操作检查<br>性能：要统计每个方法的执行时间<br>事务：方法开始之前要开始事务，<br>结束后要提交或者回滚事务<br>等等….</p></blockquote><p>这些可以称为是非功能需求， 但他们是多个业务模块都需要的， 是<code>跨越模块</code>的， 把他们放到什么地方呢？<br>就以日志系统为例。在执行某个操作前后都需要输出日志，如果手工加代码，那简直太可怕了。而且等代码庞大起来，也是非常难维护的一种情况。<br>最简单的办法就是把这些通用模块的<code>接口</code>写好， 让程序员在实现业务模块的时候去调用就可以了。</p><p><strong>也许你会想到通过以下两种设计模式可以暂时解决：</strong></p><blockquote><ol><li>模版方法</li><li>装饰者模式</li></ol></blockquote><h3 id="模版方法"><a href="#模版方法" class="headerlink" title="模版方法"></a>模版方法</h3><p>用设计模式在某些情况下可以部分解决上面的问题，如模版方法伪代码如下：<br><strong>以订单管理和支付管理为例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseCommand</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Logger logger = Logger.getLog(xxx);</span><br><span class="line">        <span class="comment">//记录日志</span></span><br><span class="line">        logger.debug(<span class="string">"xxx"</span>);</span><br><span class="line">        <span class="comment">//权限检查</span></span><br><span class="line">        PerformanceUtil.startTimer(xxx);</span><br><span class="line">        <span class="comment">//开始事务</span></span><br><span class="line">        beginTransaction();</span><br><span class="line">        <span class="comment">//这是一个需要子类实现的抽象方法</span></span><br><span class="line">        doBusiness();</span><br><span class="line">        </span><br><span class="line">        commitTransaction();</span><br><span class="line">        PerformanceUtil.endTimer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doBusiness</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderCommand</span> <span class="keyword">extends</span> <span class="title">BaseCommand</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBusiness</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行订单逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentCommand</span> <span class="keyword">extends</span> <span class="title">BaseCommand</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBusiness</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行支付逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在父类（BaseCommand）中已经把那些“乱七八糟“的非功能代码都写好了， 只是留了一个口子（<code>抽象方法</code>doBusiness()）让子类去实现。</p><p>子类变的清爽， 只需要关注业务逻辑就可以了。调用也很简单，例如：<br>BaseCommand  cmd = …  获得PlaceOrderCommand的实例…<br>cmd.execute();</p><p><strong>缺点：</strong></p><blockquote><ul><li>这样方式的巨大缺陷就是父类会定义一切： 要执行哪些非功能代码， 以什么顺序执行等等 子类只能无条件接受，完全没有反抗余地。</li><li>如果有个子类， 根本不需要事务， 但是它也没有办法把事务代码去掉。</li></ul></blockquote><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>如果利用装饰者模式， 针对上面的问题，可以带来更大的灵活性：如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerDecorate</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    Command cmd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoggerDecorate</span><span class="params">(Command cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cmd = cmd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录日志</span></span><br><span class="line">        logger.debug(xxxx);</span><br><span class="line">        <span class="keyword">this</span>.cmd.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerformanceDecorator</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    Command cmd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PerformanceDecorator</span><span class="params">(Command cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cmd = cmd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PerformanceUtil.startTimer(xxx);</span><br><span class="line">        <span class="keyword">this</span>.cmd.execute();</span><br><span class="line">        PerformanceUtil.endTimer(xxx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderCommand</span> <span class="keyword">extends</span> <span class="title">BaseCommand</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBusiness</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行订单逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentCommand</span> <span class="keyword">extends</span> <span class="title">BaseCommand</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBusiness</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//执行支付逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺点：</strong></p><blockquote><p>如果仔细思考一下就会发现装饰者模式的不爽之处:<br>(1)  一个处理日志/性能/事务 的类为什么要实现 业务接口（Command）呢?<br>(2) 如果别的业务模块，没有实现Command接口，但是也想利用日志/性能/事务等功能，该怎么办呢？</p></blockquote><p>最好把日志/安全/事务这样的代码和业务代码完全隔离开来，因为他们的关注点和业务代码的关注点完全不同 ，他们之间应该是正交的，他们之间的关系<br>应该是这样的：</p><p><img src="AOP.jpg" alt="AOP"></p><p>如果把这个业务功能看成一层层面包的话， 这些日志/安全/事务 像不像一个个“切面”<code>(Aspect)</code> ？<br>如果我们能让这些“<code>切面</code>“能和业务独立，  并且能够非常灵活的“<code>织入</code>”到业务方法中， 那就实现了<code>面向切面编程</code>(AOP)！</p><h3 id="实现AOP"><a href="#实现AOP" class="headerlink" title="实现AOP"></a>实现AOP</h3><p>在用代码使用AOP之前，我们先了解其中的一些名词概念：</p><h4 id="通知（Advice）"><a href="#通知（Advice）" class="headerlink" title="通知（Advice）"></a>通知（Advice）</h4><p>通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？<br>Spring切面可以应用5种类型的通知：</p><blockquote><ul><li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li><li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li><li>返回通知（After-returning）：在目标方法成功执行之后调用通知；</li><li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li><li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li></ul></blockquote><table><thead><tr><th>注解</th><th>通知</th></tr></thead><tbody><tr><td>@After</td><td>通知方法会在目标方法返回或抛出异常后调用</td></tr><tr><td>@Before</td><td>通知方法会在目标方法调用之前执行</td></tr><tr><td>@AfterReturning</td><td>通知方法会在目标方法返回后调用</td></tr><tr><td>@AfterThrowing</td><td>通知方法会在目标方法抛出异常后调用</td></tr><tr><td>@Around</td><td>通知方法会将目标方法封装起来</td></tr></tbody></table><h4 id="连接点（Join-point）"><a href="#连接点（Join-point）" class="headerlink" title="连接点（Join point）"></a>连接点（Join point）</h4><p>连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。(<code>被拦截到的点</code>，因为Spring只支持<code>方法类型</code>的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器)</p><h4 id="切点（Pointcut）"><a href="#切点（Pointcut）" class="headerlink" title="切点（Pointcut）"></a>切点（Pointcut）</h4><p>如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处” 。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。（对连接点进行<code>拦截</code>的定义）。</p><h4 id="切面（Aspect）"><a href="#切面（Aspect）" class="headerlink" title="切面（Aspect）"></a>切面（Aspect）</h4><p>通知+切点=切面</p><h4 id="引入（Introduction）"><a href="#引入（Introduction）" class="headerlink" title="引入（Introduction）"></a>引入（Introduction）</h4><p>引入允许我们向现有的类添加新方法或属性</p><h4 id="织入（Weaving）"><a href="#织入（Weaving）" class="headerlink" title="织入（Weaving）"></a>织入（Weaving）</h4><p>织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：</p><blockquote><ul><li><strong>编译期：</strong>切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li><li><strong>类加载期：</strong>切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。</li><li><strong>运行期：</strong>切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个<code>代理对象</code>。<strong>Spring AOP就是以这种方式织入切面的。</strong></li></ul></blockquote><p><strong>Spring对AOP的支持:</strong></p><blockquote><p>1.基于代理的经典Spring AOP；<br>2.纯POJO切面（4.x版本需要XML配置）；<br>3.@AspectJ注解驱动的切面；<br>4.注入式AspectJ切面（适用于Spring各版本）。</p></blockquote><p>前三种都是Spring AOP实现的变体，Spring AOP构建在<code>动态代理</code>基础之上，因此，Spring对AOP的支持局限于方法拦截。也就是说，AspectJ才是王道。</p><p><strong>XML中声明切面</strong></p><table><thead><tr><th>AOP配置元素</th><th>用途</th></tr></thead><tbody><tr><td><code>&lt;aop:advisor&gt;</code></td><td>定义AOP通知器</td></tr><tr><td><code>&lt;aop:after&gt;</code></td><td>定义AOP后置通知（不管被通知的方法是否执行成功）</td></tr><tr><td><code>&lt;aop:after-returning&gt;</code></td><td>定义AOP返回通知</td></tr><tr><td><code>&lt;aop:after-throwing&gt;</code></td><td>定义AOP异常通知</td></tr><tr><td><code>&lt;aop:around&gt;</code></td><td>定义AOP环绕通知</td></tr><tr><td><code>&lt;aop:aspect&gt;</code></td><td>定义一个切面</td></tr><tr><td><code>&lt;aop:aspectj-autoproxy&gt;</code></td><td>启用@AspectJ注解驱动的切面</td></tr><tr><td><code>&lt;aop:before&gt;</code></td><td>定义一个AOP前置通知</td></tr><tr><td><code>&lt;aop:config&gt;</code></td><td><code>顶层的AOP配置元素。大多数的&lt;aop:*&gt;元素必须包含在&lt;aop:config&gt;元素内</code></td></tr><tr><td><code>&lt;aop:declare-parents&gt;</code></td><td>以透明的方式为被通知的对象引入额外的接口</td></tr><tr><td><code>&lt;aop:pointcut&gt;</code></td><td>定义一个切点</td></tr></tbody></table><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">Performance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来写一个切点表达式，这个表达式能够设置当perform()方法执行时触发通知的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">execution(* concert.Performance.perform(..))</span><br><span class="line"><span class="comment">//execution：在方法执行时触发</span></span><br><span class="line"><span class="comment">//*：返回任意类型</span></span><br><span class="line"><span class="comment">//concert.Performance：方法所属类</span></span><br><span class="line"><span class="comment">//perform：方法名</span></span><br><span class="line"><span class="comment">//(..)：使用任意参数</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhones</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Silencing cell phones"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">taskSeats</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Talking seats"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applause</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"CLAP CLAP CLAP!!!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandRefund</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Demanding a refund"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过XML将无注解的Audience声明为切面:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">  &lt;aop:aspect ref=<span class="string">"audience"</span>&gt;</span><br><span class="line">    &lt;aop:before</span><br><span class="line">      pointcut =<span class="string">"execution(** concert.Performance.perform(..))"</span></span><br><span class="line">      method=<span class="string">"sillenceCellPhones"</span>/&gt;</span><br><span class="line">    &lt;aop:before</span><br><span class="line">      pointcut =<span class="string">"execution(** concert.Performance.perform(..))"</span></span><br><span class="line">      method=<span class="string">"taskSeats"</span>/&gt;</span><br><span class="line">    &lt;aop:after-returning</span><br><span class="line">      pointcut =<span class="string">"execution(** concert.Performance.perform(..))"</span></span><br><span class="line">      method=<span class="string">"applause"</span>/&gt;</span><br><span class="line">    &lt;aop:After-throwing</span><br><span class="line">        pointcut =<span class="string">"execution(** concert.Performance.perform(..))"</span></span><br><span class="line">        method=<span class="string">"demanRefund"</span>/&gt;</span><br><span class="line">  &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><h2 id="关于Spring-Bean"><a href="#关于Spring-Bean" class="headerlink" title="关于Spring Bean"></a>关于Spring Bean</h2><p>Spring的ioc容器功能非常强大，负责Spring的Bean的创建和管理等功能。而Spring 的bean是整个Spring应用中很重要的一部分，了解Spring Bean的生命周期对我们了解整个spring框架会有很大的帮助。<br>BeanFactory和ApplicationContext是Spring两种很重要的容器,前者提供了最基本的依赖注入的支持，而后者在继承前者的基础进行了功能的拓展，例如增加了事件传播，资源访问和国际化的消息访问等功能。</p><h3 id="Bean的声明周期"><a href="#Bean的声明周期" class="headerlink" title="Bean的声明周期"></a>Bean的声明周期</h3><p>首先看下生命周期图：<br><img src="bean.jpg" alt="bean"></p><p>再谈生命周期之前有一点需要先明确：</p><blockquote><p>Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p></blockquote><p>如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。我们对图进行详细描述：</p><blockquote><ol><li>Spring对bean进行实例化； </li><li>Spring将值和bean的引用注入到bean对应的属性中；</li><li>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</li><li>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</li><li>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</li><li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</li><li>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用init-method声明了初始化方法，该方法也会被调用；</li><li>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</li><li>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</li><li>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</li></ol></blockquote><h3 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><p>Spring定义了多种Bean作用域，可以基于这些作用域创建bean，包括：</p><blockquote><ul><li>单例（Singleton）：在整个应用中，只创建bean的一个实例。</li><li>原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。</li><li>会话（Session）：在Web应用中，为每个会话创建一个bean实例。</li><li>请求（Rquest）：在Web应用中，为每个请求创建一个bean实例。</li></ul></blockquote><p>在默认情况下，Spring应用上下文中所有bean都是作为以<code>单例（singleton）</code>的形式创建的。也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。</p><p>在<code>大多数</code>情况下，<code>单例bean</code>是很理想的方案。初始化和垃圾回收对象实例所带来的成本只留给一些小规模任务，在这些任务中，让对象保持无状态并且在应用中反复重用这些对象可能并不合理。</p><p>有时候，可能会发现，你所使用的类是<code>易变的</code>（mutable），它们会保持一些状态，因此<code>重用</code>是不安全的。在这种情况下，将class声明为单例的bean就不是什么好主意了，因为对象会被<code>污染</code>，稍后重用的时候会出现意想不到的问题。</p><h3 id="声明Bean"><a href="#声明Bean" class="headerlink" title="声明Bean"></a>声明Bean</h3><p>以下是声明Bean的注解：</p><blockquote><ul><li>@Component 组件，没有明确的角色</li><li>@Service 在业务逻辑层使用</li><li>@Repository 在数据访问层使用</li><li>@Controller 在展现层使用(MVC -&gt; Spring MVC)使用</li></ul></blockquote><p>在这里，可以指定bean的id名：<code>Component(&quot;yourBeanName&quot;)</code><br>同时，Spring支持将<code>@Named</code>作为<code>@Component</code>注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，它们是可以<code>互相替换</code>的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用Spring框架中，对于源码的分析还是过少，在以后的工作中要学习Spring的代码设计。增强自己对架构的理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;人生而迷茫吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;学了Spring框架那么久，也没有很好总结过，
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>怕</title>
    <link href="http://yoursite.com/2018/08/31/%E6%80%95/"/>
    <id>http://yoursite.com/2018/08/31/怕/</id>
    <published>2018-08-31T01:00:00.000Z</published>
    <updated>2018-09-19T15:40:36.899Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>抬起头，又底下</p></blockquote><p>当我遇到自己的理想和行为不一致的时候，我就会审视自己的内心，拷问自己的灵魂，你是否还记的那些理想，是否还记得曾经的誓言。</p><p>当我胆小怕事的时候，我总是问自己，你到底在害怕什么？</p><blockquote><p>你和我一样背负着与众不同的秘密在活着。你的眼睛告诉我，仇恨和恐惧，那是什么样的经历造就的！而后再用杀人来掩盖这种感受吗！你敢不敢问自己，到底要去哪里！背负着恐惧寻找的终点，非要是末路吗！你能听到吗！你还能听到吗！你还有勇气直面你的恐惧吗！</p></blockquote><p>每个人的发展都是首先从单维度开始的，如果一开始对单维度的技能没有达到极致，就暂时不要进行多维度的发展，不但不能起到快速进步的地步，还会影响到原来单维度的发展。</p><hr><p>环境的改变自己才会在这个环境中学的更好。可以说环境是最影响进步的一个助力，在符合的环境中学习才会让你学有所用所得。</p><hr><p>每个人都会鄙视自己，因为鄙视自己，所以才会想要进步，想要努力。不满足源于内心无尽的鄙视。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;抬起头，又底下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当我遇到自己的理想和行为不一致的时候，我就会审视自己的内心，拷问自己的灵魂，你是否还记的那些理想，是否还记得曾经的誓言。&lt;/p&gt;
&lt;p&gt;当我胆小怕事的时候，我总是问自己，你到底在害怕什么？&lt;
      
    
    </summary>
    
      <category term="所思" scheme="http://yoursite.com/categories/%E6%89%80%E6%80%9D/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JMM和volatile与synchronized</title>
    <link href="http://yoursite.com/2018/08/26/JMM%E5%92%8Cvolatile%E4%B8%8Esynchronized/"/>
    <id>http://yoursite.com/2018/08/26/JMM和volatile与synchronized/</id>
    <published>2018-08-26T04:00:00.000Z</published>
    <updated>2018-11-21T09:24:30.892Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>好的习惯可以影响人一生</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在一开始的学习java的时候，一直认为<code>JMM（Java Memory Model）</code>和<code>Java内存区域</code>是一个东西。后面深入学习后，<code>Java内存区域</code>是JVM在运行程序时会把其自动管理的内存划分为以上几个区域，每个区域都有的用途以及创建销毁的时机。<code>JMM</code>则是本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p><h2 id="JMM-Java-Memory-Model"><a href="#JMM-Java-Memory-Model" class="headerlink" title="JMM(Java Memory Model)"></a>JMM(Java Memory Model)</h2><p>Java内存区域就不在过多的介绍，有兴趣可以看我以前写的关于深入理解JVM的内容。<br>在执行程序时JVM运行程序的实体是<code>线程</code>，而每个线程创建时JVM都会为其创建一个<code>工作内存</code>(有些地方称为<code>栈空间</code>)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在<code>主内存</code>，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，<strong>首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存</strong>，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:<br><img src="JMM.jpg" alt="1"><br>JMM与Java内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，<strong>JMM是围绕原子性，有序性、可见性展开的</strong>。这也是我们在并发操作，或者使用多线程执行的时候围绕这三个原则来保证数据的同步。</p><p>对于一个实例对象中的成员方法而言，如果<code>方法中</code>包含本地变量是<code>基本数据类型</code>（boolean,byte,short,char,int,long,float,double），将直接存储在工作内存的<code>帧栈</code>结构中，但倘若<code>本地变量是引用类型</code>，那么该变量的<code>引用</code>会存储在功能内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。但对于<code>实例对象的成员变量</code>，不管它是<code>基本数据类型</code>或者<code>包装类型</code>(Integer、Double等)还是<code>引用类型</code>，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存，</p><p>总结来说一句话：<strong>方法中的局部变量是基本类型就直接操作个线程的栈中，引用变量值存在主内存中。而对象成员变量都存放在主内存中。</strong></p><h3 id="为什么需要JMM，它试图解决什么问题"><a href="#为什么需要JMM，它试图解决什么问题" class="headerlink" title="为什么需要JMM，它试图解决什么问题"></a>为什么需要JMM，它试图解决什么问题</h3><p>Java 是最早尝试提供内存模型的语言，这是简化多线程编程、保证程序可移植性的一个飞跃。早期类似 C、C++ 等语言，并不存在内存模型的概念（C++ 11 中也引入了标准内存模型），其行为依赖于处理器本身的内存一致性模型，但不同的处理器可能差异很大，所以一段 C++ 程序在处理器 A 上运行正常，并不能保证其在处理器 B 上也是一致的。</p><p>即使如此，最初的 Java 语言规范仍然是存在着缺陷的，当时的目标是，希望 Java 程序可以充分利用现代硬件的计算能力，同时保持“书写一次，到处执行”的能力。</p><p>但是，显然问题的复杂度被低估了，随着 Java 被运行在越来越多的平台上，人们发现，过于泛泛的内存模型定义，存在很多模棱两可之处，对 synchronized 或 volatile 等，类似指令重排序时的行为，并没有提供清晰规范。这里说的指令重排序，既可以是编译器优化行为，也可能是源自于现代处理器的乱序执行等。</p><p>换句话说：</p><blockquote><ul><li><p>既不能保证一些多线程程序的正确性，例如最著名的就是双检锁（Double-Checked Locking，DCL）的失效问题，双检锁可能导致未完整初始化的对象被访问，理论上这叫并发编程中的安全发布（Safe Publication）失败。</p></li><li><p>也不能保证同一段程序在不同的处理器架构上表现一致，例如有的处理器支持缓存一致性，有的不支持，各自都有自己的内存排序模型。</p></li></ul></blockquote><p>所以，Java 迫切需要一个完善的 <code>JMM</code>，能够让普通 Java 开发者和编译器、JVM 工程师，能够清晰地达成共识。换句话说，可以<code>相对简单并准确地判断出，多线程程序什么样的执行序列是符合规范的</code>。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile在并发编程中很常见，但也容易被滥用，现在我们就进一步分析volatile关键字的语义。volatile是Java虚拟机提供的轻量级的同步机制。volatile关键字有如下两个作用</p><blockquote><ul><li>保证被volatile修饰的共享变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总数可以被其他线程立即得知。</li><li>禁止指令重排序优化。</li></ul></blockquote><h2 id="volatile和synchronized特点"><a href="#volatile和synchronized特点" class="headerlink" title="volatile和synchronized特点"></a>volatile和synchronized特点</h2><p>首先需要理解线程安全的两个方面：<strong>执行控制和内存可见</strong>。<br><code>执行控制</code>的目的是控制代码执行（顺序）及是否可以并发执行。<br><code>内存可见</code>控制的是线程执行结果在内存中对其它线程的可见性。根据Java内存模型的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完成后再把结果从线程本地刷到主存。</p><p>synchronized关键字解决的是<code>执行控制</code>的问题，它会阻止其它线程获取当前对象的监控锁，这样就使得当前对象中被synchronized关键字保护的代码块无法被其它线程访问，也就无法并发执行。更重要的是，synchronized还会创建一个<code>内存屏障</code>，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得先获得这个锁的线程的所有操作，都happens-before于随后获得这个锁的线程的操作。</p><p>volatile关键字解决的是<code>内存可见性</code>的问题，会使得所有对volatile变量的读写都会直接刷到主存，即保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序没有要求的需求。<br>使用volatile关键字仅能实现对原始变量(如boolen、 short 、int 、long等)操作的原子性，但需要特别注意， volatile不能保证复合操作的原子性，即使只是i++，实际上也是由多个原子操作组成：read i; inc; write i，假如多个线程同时执行i++，volatile只能保证他们操作的i是同一块内存，但依然可能出现写入脏数据的情况。<br>在Java 5提供了原子数据类型atomic wrapper classes，对它们的increase之类的操作都是原子操作，不需要使用sychronized关键字。<br>对于volatile关键字，当且仅当满足以下所有条件时可使用：</p><blockquote><ol><li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li><li>该变量没有包含在具有其他变量的不变式中。</li></ol></blockquote><h2 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h2><blockquote><p>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。<br>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的<br>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性<br>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。<br>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>volatile无法保证原则性。可以使用并发包提供的Atomic* 。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;好的习惯可以影响人一生&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在一开始的学习java的时候，一直认为&lt;code
      
    
    </summary>
    
      <category term="线程" scheme="http://yoursite.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="JMM，volatile，synchronized" scheme="http://yoursite.com/tags/JMM%EF%BC%8Cvolatile%EF%BC%8Csynchronized/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://yoursite.com/2018/08/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/08/19/线程池/</id>
    <published>2018-08-19T01:00:00.000Z</published>
    <updated>2018-11-21T11:13:04.237Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最好是更好的敌人</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>多线程的软件设计可以最大限度地发挥现代多核处理器的计算能力，提高生产系列的吞吐量和性能。但是，线程过多的话，不但不能达到提高性能的目的，还会是性能严重下降，因为过多的线程是CPU忙于进行线程之间的<code>切换</code>，而没有时间执行其他的任务。</p><p><strong>为了避免系统频繁地创建和销毁线程，我们可以让创建的线程进行复用。</strong>如果有同学有过数据库开发的经验，对数据库连接池这个概念应该不会陌生。为了避免每次数据库查询都重新建立和销毁数据库连接，我们可以使用数据库连接池维护一些数据库连接，使其长期保持在一个激活的状态。当系统需要使用数据库时，并不是创建一个新的连接，而是从连接池中获得一个可用的连接即可。反之，当需要关闭连接时，并不真的把连接关闭，而是将这个连接“还”给连接池即可。</p><p>为了方便我们使用线程池，jdk提供了一套Executor框架，如下图所示：<br><img src="线程池.jpg" alt="1"></p><p>以上成员均在java.util.concurrent包中，是JDK并发包的核心类。其中ThreadPoolExecutor表示一个线程池。Executors类则扮演线程池工厂角色，通过Executors可以取得一个具有特定功能的线程池。从UML图中亦可知，ThreadPoolExecutor实现了Executor接口，因此通过这个接口，任何Runnable对象都可以被ThreadPoolExecutor线程池调度。</p><p>Java提供了ExecutorService的两种实现：</p><blockquote><ul><li>ThraedPoolExecutor:标准线程池</li><li>ScheduledThreadPoolExecutor:支持延时任务的线程池</li><li>ForkJoinPool:类似于ThraedPoolExecutor，但是使用work-stealing模式，其会为线程池中的每个线程创建一个队列，从而使用work-stealing（任务窃取）算法使得线程可以从其他线程队列里窃取任务来执行。即如果自己的任务处理完成了，则可以去忙碌的工作线程那里去窃取任务执行。</li></ul></blockquote><p>Executor框架提供了各种类型的线程池，主要有以下工厂方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br></pre></td></tr></table></figure><p><strong>Executors 目前提供了 5 种不同的线程池创建配置：</strong></p><blockquote><ul><li><p>newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。</p></li><li><p>newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。</p></li><li><p>newSingleThreadExecutor()，它的特点在于工作线程数目被限制为1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</p></li><li><p>newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)，创建的是个ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。</p></li><li><p>newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。</p></li></ul></blockquote><h2 id="线程池的内部实现"><a href="#线程池的内部实现" class="headerlink" title="线程池的内部实现"></a>线程池的内部实现</h2><p>无论是newFixedThreadPool()、newSingleThreadExecutor()还是newCacheThreadPool方法，虽然看起来创建的线程具有完全不同的功能特点，但其内部均使用了ThreadPoolExecutor实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,  <span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由以上线程池的实现可以看到，它们都只是ThreadPoolExecutor类的封装。我们看下ThreadPoolExecutor最重要的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            //指定了线程池中的线程数量</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">            //指定了线程池中的最大线程数量</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">            //当前线程池数量超过corePoolSize时，多余的空闲线程的存活时间，即多次时间内会被销毁。</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">            //keepAliveTime的单位</span></span></span><br><span class="line"><span class="function"><span class="params">            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            //任务队列，被提交但尚未被执行的任务。</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            //线程工厂，用于创建线程，一般用默认的即可</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            //拒绝策略，当任务太多来不及处理，如何拒绝任务。</span></span></span><br><span class="line"><span class="function"><span class="params">            RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><h2 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h2><p>workQueue指提交但未执行的任务队列，它是一个BlockingQueue接口的对象，仅用于存放Runnable对象，根据队列功能分类，在ThreadPoolExecutor的构造函数中可使用以下几种BlockingQueue。</p><ol><li>直接提交的队列：</li></ol><p>该功能由synchronousQueue对象提供，synchronousQueue对象是一个特殊的BlockingQueue。synchronousQueue没有容量，每一个插入操作都要等待一个响应的删除操作，反之每一个删除操作都要等待对应的插入操作。如果使用synchronousQueue，提交的任务不会被真实的保存，而总是将新任务提交给线程执行，如果没有空闲线程，则尝试创建线程，如果线程数量已经达到了最大值，则执行拒绝策略，因此，使用synchronousQueue队列，通常要设置很大的maximumPoolSize值，否则很容易执行拒绝策略。</p><ol start="2"><li>有界的任务队列：</li></ol><p>有界任务队列可以使用ArrayBlockingQueue实现。ArrayBlockingQueue构造函数必须带有一个容量参数，表示队列的最大容量。<br>当使用有界任务队列时，若有新任务需要执行时，如果线程池的实际线程数量小于corePoolSize，则会优先创建线程。若大于corePoolSize，则会将新任务加入等待队列。若等待队列已满，无法加入，则在总线程数不大于maximumPoolSize的前提下，创建新的线程执行任务。若大于maximumPoolSize，则执行拒绝策略。可见有界队列仅当在任务队列装满后，才可能将线程数量提升到corePoolSize以上，换言之，除非系统非常繁忙，否则确保核心线程数维持在corePoolSize。</p><ol start="3"><li>无界的任务队列：</li></ol><p>无界队列可以通过LinkedBlockingQueue类实现。与有界队列相比，除非系统资源耗尽，无界队列的任务队列不存在任务入队失败的情况。若有新任务需要执行时，如果线程池的实际线程数量小于corePoolSize，则会优先创建线程执行。但当系统的线程数量达到corePoolSize后就不再创建了，这里和有界任务队列是有明显区别的。若后续还有新任务加入，而又没有空闲线程资源，则任务直接进入队列等待。若任务创建和处理的速度差异很大，无界队列会保持快速增长，知道耗尽系统内存。</p><ol start="4"><li>优先任务队列：</li></ol><p>带有优先级别的队列，它通过PriorityBlokingQueue实现，可以控制任务执行的优先顺序。它是一个特殊的无界队列。无论是ArrayBlockingQueue还是LinkedBlockingQueue实现的队列，都是按照先进先出的算法处理任务，而PriorityBlokingQueue根据任务自身优先级顺序先后执行，在确保系统性能同时，也能很好的质量保证（总是确保高优先级的任务优先执行）。</p><h2 id="自定义线程创建：ThreadFactory"><a href="#自定义线程创建：ThreadFactory" class="headerlink" title="自定义线程创建：ThreadFactory"></a>自定义线程创建：ThreadFactory</h2><p>ThreadFactory是一个接口，它只有一个方法，用来创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br></pre></td></tr></table></figure><p>当线程池需要新建线程时，就会调用这个方法。</p><p>自定义线程池可以帮我们做不少事情。我们可以跟踪线程池在何时创建了多少线程，也可以自定义线程的名称、组以及优先级等信息，甚至可以任性地将所有的线程设置为守护线程。总之，使用自定义线程可以让我们更加自由地设置池中所有的线程的状态。下面的案例使用自定义ThreadFactory，一方面记录了线程的创建，另一方面将所有的线程都设置为守护线程，这样，当主线程退出后，将会强制销毁线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadFactoryExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" coming..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a )</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyTask myTask = <span class="keyword">new</span> MyTask();</span><br><span class="line">        ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>)</span><br><span class="line">                , <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">                        t.setName(<span class="string">"T "</span> + t.getId() + <span class="string">"_"</span> +System.currentTimeMillis());</span><br><span class="line">                        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                        System.out.println(<span class="string">"Create a Thread Name is : "</span>+t.getName());</span><br><span class="line">                        <span class="keyword">return</span> t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            es.submit(myTask);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h2><p>ThreadPoolExecutor是可扩展的，它提供了几个“钩子”方法可以在子类化中改写：beforeExecute、afterExecute和terminated，这些方法可以用于扩展ThreadPoolExecutor的行为。</p><p>在执行任务的线程中将调用beforeExecute和afterExecute等方法，在这些方法中还可以添加日志、计时、监视或统计信息收集的功能。无论任务是从run中正常返回，还是抛出一个异常而返回，afterExecute都会被调用。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这里比较粗糙的研究了一下线程池的一些基本的概念和功能。并发的路上还有很多路要走。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最好是更好的敌人&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;多线程的软件设计可以最大限度地发挥现代多核处理器的计算
      
    
    </summary>
    
      <category term="线程" scheme="http://yoursite.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://yoursite.com/2018/08/13/%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/08/13/线程/</id>
    <published>2018-08-13T01:00:00.000Z</published>
    <updated>2018-11-20T03:19:48.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>深感自己的能力的不足，此处仅仅是对知识的记录和总结，许多地方都是借鉴他人的语句</p></blockquote><hr><h2 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h2><p><strong>想要了解线程，必须首先知道进程，并知道他与线程的区别是什么？</strong></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong>进程</strong></h3><p>通常，我们把一个程序的执行称为一个进程。反过来讲，进程用于描述程序的执行过程。因此，程序和进程是一对概念，它们分別描述了一个程序的静态和动态特征：除此之外，进程还操作系统进行资源分配的一个基本单位。</p><h4 id="进程的衍生"><a href="#进程的衍生" class="headerlink" title="进程的衍生"></a><strong>进程的衍生</strong></h4><p>进程使用<code>fork</code>（）系统调用来创建。父进程调用<code>fork</code>创建子进程。每个子进程都是源自它的父进程的一个副本，它会获得父进程的数据段、堆和栈的副本，并与父进程共享代码段。每一份副本都是独立的，子进程对属于它的副本的修改对其父进程和兄弟进程（同父进程）都是不可见的，反之亦然。全盘复制父进程的数据是一种相当低效的做法。 Linux操作系统内核使用写时复制（Copy on Write,常简称为COW，<strong>也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</strong>)等技术来提高进程创建的效率。当然，刚创建的子进程也可以通过系统调用exec把一个新的程序加载到自己的内存中，而原先在内存中的数据段、堆、栈以及代码段就会被替换掉，在这之后，子进程执行的就会是那个刚刚加载进来的新程序（意思就是当传入的参数或者变量不同的时候，子进程就相当于在做自己的事情）。</p><p><strong>父进程被如果优先于子进程结束，那么子进程就会被原来父进程的父进程“收养”（也就是子进程的爷爷）。</strong></p><p>为了管理进程，内核必须对每个进程的数据和行为进行详细的记录，包括进程的优先级、状态、虚拟地址范围以及各种访问权限等等。更具体地说，这些信息都会被记在每个进程的进程描述符中。进程描述符并不是一个简单的符号，而是一个非常复杂的数据结构。保存在进程描述符中的进程ID (常称为PID )是进程在操作系统中的唯一标识，其中<strong>进程ID为1的进程就是之前提到的内核启动进程</strong>。进程id是一个非负整数且总是顺序的编号，新创建的进程ID总是前一个进程ID递增的结果。此外，进程ID也可以重复使用。当进程ID达到其最大限值时，内核会从头开始查找闲置的进程ID并使用M先找到的那一个作为新进程的ID。另外，进程描述符中还会包含当前进程的父进程的ID (常称为PPID )。</p><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><p>进程通信叫做IPC(Inter-Process Communication)，Linux中通信的方式大致可分成三种：</p><ol><li>基于通信的IPC</li><li>基于信号的IPC</li><li>基于同步的IPC</li></ol><p><strong>通信IPC</strong></p><ul><li>以数据为传送手段的IPC</li></ul><blockquote><p>管道(pipe)：用于传输字节流<br>消息队列(message queue)：用来传输结构化的对象</p></blockquote><ul><li>以共享内存为手段的IPC</li></ul><blockquote><p>共享内存区（share memory)：最快的IPC方法</p></blockquote><p> <strong>信号IPC</strong></p><blockquote><p>操作系统的信号（signal）机制：唯一一种异步IPC方法。通过kill -l查看。</p></blockquote><p><strong>同步IPC</strong></p><blockquote><p>信号量（semaphore）</p></blockquote><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程可以视为进程中的控制流。一个进程至少包含一个线程，因为其他至少会有一个控制流持续运行。因而，<strong>一个进程的第一个线程会随着这个进程的启动而创建</strong>，这个线程被称为该进程的主线程。当然，一个进程可以包含多个线程。这些线程都是由当前线程中已经存在的线程创建出来的，创建的方法就是系统调用（pthread_create）。<strong>拥有多个线程的进程可以并发执行多个任务，并且即时某个或某些任务被阻塞，也不会影响其他任务执行，这可以大大改善程序的响应时间和吞吐量</strong>。另一方面，线程不可能独立于进程存在。它的生命周期不可能逾越所属进程的生命周期。</p><p>一个进程中的所有线程都拥有自己线程栈，并以此存储自己的私有数据。这些线程的线程栈都包含在其所属进程的虚拟内存地址中。不过要注意，一个进程中的很多资源都会被其中的所有线程共享，这些被线程共享的资源包含当前进程所持有文件描述符，等等。正因为如此，同一个进程的多个线程运行的一定是同一个程序，只不过具体的控制流程的执行函数可能有所不同。在同一个进程的多个线程之间共享数据也是一件非常轻松和自然的事情。另外，创建一个新线程，也不会像创建一个新进程那样耗时费力，因为在其所属进程的虚拟内存地址中存储的代码、数据和资源都不需要被复制。</p><p>和进程一样，每个线程都有自己的ID（由内核分配），叫做线程ID或者TID。但是在操作系统范围内不唯一，在所属进程的范围内唯一。</p><h3 id="多线程的三大特性"><a href="#多线程的三大特性" class="headerlink" title="多线程的三大特性"></a>多线程的三大特性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个人操作一旦开始，就不会被其他的线程干扰。</p><h4 id="可见性（Visibility）"><a href="#可见性（Visibility）" class="headerlink" title="可见性（Visibility）"></a>可见性（Visibility）</h4><p>可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。显然，对于串行程序来说，可见性问题是不存在的。因为你在任何一个操作步骤中修改了某个变量，那么在后续的步骤中，读取这个变量的值，一定是修改后的新值。</p><h4 id="有序性（Ordering）"><a href="#有序性（Ordering）" class="headerlink" title="有序性（Ordering）"></a>有序性（Ordering）</h4><p>有序性问题是三个问题中最难理解的。对于一个线程的执行代码而言，我们总是习惯地认为代码的执行是从先往后，依次执行。这么理解也不是说完全错误，因为就一个线程内而言，确实会表现成这样。但是，在并发时，程序的执行可能就会出现乱序。给人直观的感觉就是：写在前面的代码，会在后面执行。然而有序性的问题的原因因为是程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。</p><h3 id="哪些指令不能重排——Happen-Before规则"><a href="#哪些指令不能重排——Happen-Before规则" class="headerlink" title="哪些指令不能重排——Happen-Before规则"></a>哪些指令不能重排——Happen-Before规则</h3><blockquote><p>1.程序顺序原则：一个线程内保证语义的串行性<br>2.volatile规则：volatile变量的写，先发生与读，这保证了volatile变量的可见性。一般用volatile修饰的都是经常修改的对象。<br>3.锁规则：解锁（unlock）必然发生在随后的加锁（lock）前<br>4.传递性：A先于B，B先于C，那么A必然先于C<br>5.线程的start（）方法先于它的每一个动作<br>6.线程的所有操作先于线程的终结（Thread.join()）<br>7.线程的中断（interrupt()）先于被中断线程的代码<br>8.对象的构造函数执行、结束先于finalize()方法</p></blockquote><hr><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><h3 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h3><p>在线程的生命周期中，它要经过<strong>新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态</strong>。尤其是当线程启动以后，它不可能一直”霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换</p><p><img src="./attachments/1535250738191.drawio.html" alt="Diagram"></p><p><img src="生命周期.jpg" alt="生命周期"></p><ol><li>新建状态，当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值</li><li>就绪状态，当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行</li><li>运行状态，如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态</li><li>阻塞状态，当处于运行状态的线程失去所占用资源之后，便进入阻塞状态</li><li>死亡状态，线程终止</li></ol><h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>线程可以通过多种方式来终结同一个进程中的其他线程。其他一种方式就是调用系统调用pthread_cancel，其作用是取消掉给定线程ID代表的那个线程。更确切地讲，它会向目标线程发送一个请求，要求它立刻终止执行。但是该函数只是发送请求并即可返回。但是，该函数只是发送请求并立刻返回，而不会等待目标线程对该请求做出响应。至于目标线程什么时候对此做出线程、怎么样的响应，则取决与另外的因素（比如线程目标的取消状态及类型）。在默认情况下，目标线程总是会接受线程取消请求，不过等到时机成熟（执行到某个取消点）的时候，目标线程才会响应线程的取消请求。</p><h3 id="连接已终止的线程"><a href="#连接已终止的线程" class="headerlink" title="连接已终止的线程"></a>连接已终止的线程</h3><p>此操作由系统调用pthread_join来执行，该函数会一直等待与给定的线程ID对应的那个线程终止，并把线程执行的pthread_create函数的返回值告知调用线程。如果目标线程已经处于终止状态，那么该函数会立即返回。这就像是把调用线程放置在了目标线程的后面，当目标线程把线程控制权交出时，调用线程会接过流程控制权并继续执行pthread_join函数调用之后的代码。这也把这一操作称为连接的缘由之一。实际上，如果一个线程可被连接，那么在它终止之前就必须连接，否则就会变成一个僵尸线程。僵尸线程不但会导致系统资源浪费，还会无意义减少其进程的可创建线程数量。</p><h3 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h3><p>将一个线程分离后那么它将变得不可连接。而在默认情况下，一个线程总是可以被连接的。分离操作的另一个作用是让操作系统内核在目标线程终止时自行进行清理和销毁工作。注意，分离操作是不可逆的。也就是说，我们无法使一个不可连接的线程变回可连接的状态。不过，对于一个已处于分离状态的线程，执行终止操作仍然会起作用。分离操作由系统调用pthread_detach来执行，它接受一个代表了线程ID的参数值。</p><blockquote><p>一个线程对自身也可以进行两种控制：<strong>终止和分离</strong>。线程终止自身的方式有很多种。在线程执行的start函数中执行return语句，会使该线程随着start函数的结束而终止。需要注意的是，如果在主线程中执行了return语句，那么当前进程中的所有线程都会终止。另外，在任意线程中调用系统调用exit也会达到这种效果。还有一种终止自身的方式就是显示调用pthread_exit。而分离pthread_detach函数则是传入自己的TID。</p></blockquote><hr><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>主线程在其所属进程启动时创建。其他线程可以通过别的线程用pthread_create来创建——要传入新线程将要执行的函数以及传入该函数的参数值。在创建成功的时候，该函数会返回线程的TID。</p><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><p>线程创建的方式有三种，在我至今使用的经历中从来没有使用到过第三种方法：所以今天只介绍两种，第一种是继承<code>Thread</code>类，第二种是实现<code>Runnable</code>接口。两种方法的优缺点就和继承和接口优缺点有关了，其实底层都是一样的。<br>具体的代码这里不再进行详述，基本上都是见过的。</p><hr><h2 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h2><p>在多个线程之间交换线程是非常简单和自然的事，而在多个进程之间只能通过一些额外的手段（比如管道、消息队列、信号量和共享内存区）传递数据。显然，使用这些额外手段会增加开发成本。不过，<strong>线程间交换数据虽然简单但却由于可能发生竞态条件而不得不使用一些同步工具（比如互斥量和条件变量）加以保护</strong>。这些与业务逻辑无关的代码会增加程序的复杂度，尤其在使用不当的情况下还会引起灾难。</p><blockquote><p>互斥量可以理解为我们常见的锁。而条件变量所做的就是保证线程间共享的数据状态改变时通知到其他因此而被阻塞的线程。条件变量总是与互斥量组合使用。当线程成功锁定互斥量并访问到共享数据时，共享数据的状态并不一定满足它的要求。</p></blockquote><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>使用synchronize的可以加载方法，代码块，类上，以此实现多线同步。</p><ol><li>同步代码块：<br>即有synchronized关键字修饰的语句块。 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">代码如： </span><br><span class="line"><span class="keyword">synchronized</span>(object)&#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注：同步是一种高开销的操作，因此应该尽量减少同步的内容。 </span><br><span class="line">通常没有必要同步整个方法，使用<span class="keyword">synchronized</span>代码块同步关键代码即可。</span><br></pre></td></tr></table></figure><ol start="2"><li>同步方法<br>即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码如： </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类</p><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>使用volatile修饰共享变量可以实现线程同步。<strong>其中的原理与synchronized区别会在JMM文章中讲到。</strong><br>a.volatile关键字为域变量的访问提供了一种免锁机制，<br>b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，<br>c.因此每次使用该域就要重新计算，而不是使用寄存器中的值<br>d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量</p><h4 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h4><p>什么是重入呢？它是表示当一个线程试图获取一个它已经获取的锁时，这个获取动作就自动成功，这是对锁获取粒度的一个概念，也就是锁持有的是以线程为单位而不是基于调用次数。<br>再入锁可以设置公平性(fairness)，我们可以创建重入锁时选择是否是公平的。<br>ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。<br>ReentrantLock相比synchronize，因为可以像普通对象一样使用，所以可以利用其提供的各种便利方法，进行精细的同步操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> account = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">//需要声明这个锁</span></span><br><span class="line">            <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> account;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里不再需要synchronized </span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    account += money;</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        ｝</span><br></pre></td></tr></table></figure><p>ReenreantLock类的常用方法有：</p><blockquote><p> ReentrantLock() : 创建一个ReentrantLock实例<br> lock() : 获得锁<br> unlock() : 释放锁</p></blockquote><p>从性能的角度，synchronize早起的实现比较低效，对比ReentrantLock大多数场景性能都相差较大，但是在java6 中对其进行了非常多的改进，在高竞争情况下ReentrantLock仍然有一定优势。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>与互斥锁不同，条件变量是用来等待而不是用来上锁的。<strong>条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用</strong>。条件变量分为两部分:<code>条件和变量</code>。条件本身是由互斥量保护的。线程在改变条件状态前先要锁住互斥量。条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。条件的检测是在<code>互斥锁</code>的保护下进行的。如果一个条件为假，一个线程自动阻塞，并释放等待状态改变的<code>互斥锁</code>。如果另一个线程改变了条件，它发信号给关联的条件变量，唤醒一个或多个等待它的线程，重新获得<code>互斥锁</code>，重新评价条件。<strong>如果两进程共享可读写的内存，条件变量可以被用来实现这两进程间的线程同步。</strong></p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，<br>副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。<br>ThreadLocal 类的常用方法</p><blockquote><p>ThreadLocal() : 创建一个线程本地变量  get() : 返回此线程局部变量的当前线程副本中的值<br>initialValue() : 返回此线程局部变量的当前线程的”初始值”<br>set(T value) :将此线程局部变量的当前线程副本中的值设置为value</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">           <span class="comment">//使用ThreadLocal类管理共享变量account</span></span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; account = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">               account.set(account.get()+money);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAccount</span><span class="params">()</span></span>&#123;</span><br><span class="line">               <span class="keyword">return</span> account.get();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>ThreadLocal下面单独讲</strong></p><hr><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>一句话概括：Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。所以ThreadLocal的应用场合，最适合的是按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。</p><p>数据隔离的秘诀其实是这样的，Thread有个TheadLocalMap类型的属性，叫做threadLocals，该属性用来保存该线程本地变量。这样每个线程都有自己的数据，就做到了不同线程间数据的隔离，保证了数据安全。</p><p>具体看这篇博客：<br><a href="https://blog.csdn.net/lufeng20/article/details/24314381" target="_blank" rel="noopener">https://blog.csdn.net/lufeng20/article/details/24314381</a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>并发（Concurrency）和并行（Parallelism）</strong></p><blockquote><p>并发和并行往往被人所混淆。它们都可以表示两个或多个任务一起执行，但是偏重点有些不同。并发偏重于多个任务交替执行，而多个任务有可能还是串行。而并行则是真正意义上的“同时执行”。</p><p>严格来说，<strong>并行的多个任务是真实的同时执行</strong>，<strong>而对并发来说，这个过程这是交替的，一会儿运行任务A一会儿执行任务B，系统会不停地在两者间切换</strong>。但对于外部观察者来说，即使多个任务之间是串行并发的，也会造成多任务间是并行执行的错觉。</p></blockquote><p><strong>临界区</strong></p><blockquote><p>临界区(criticalsection)用来表示一种公共资源或者共享数据，可以被多个线程使用。但是每一次，只有一个线程可以使它，一旦临界区资源被占用，其他线程要想使用资源，就必须等待，即串行化访问或执行。</p></blockquote><p><strong>死锁（DeadLock）、饥饿（Starvation）和活锁（Livelock）</strong></p><blockquote><p>死锁、饥饿和活锁都属于多线程的活跃性问题，如果发生上述情况，那么相关线程可能就不再活跃，也就是说它可能很难继续往下执行了。<br>死锁应该是最糟糕的一种情况了，虽然别的情况也没有好到哪儿去。</p><ul><li>死锁：多个线程互相等待多方释放资源而一直没有执行。</li><li>饥饿：一个或多个线程因为种种原因无法获取所得的需要资源，导致一直无法执行。导致的原因往往是当前线程优先级不高导致没有资源，或某线程一直占着关键资源不放。</li><li>活锁：多个线程都释放资源给别的线程使用，导致没有线程拿到资源而正常执行。</li></ul></blockquote><p><strong>阻塞和非阻塞</strong></p><blockquote><p>描述的是用户线程调用内核 I/O 操作的方式：</p><ul><li>阻塞（Blocking）是指 I/O 操作需要彻底完成后才返回到用户空间；</li><li>非阻塞（Non-Blocking）是指 I/O 操作被调用后立即返回给用户一个状态值，无需等到 I/O 操作彻底完成。</li></ul><p>一个 I/O 操作其实分成了两个步骤：</p><ol><li>发起 I/O 请求</li><li>实际的 I/O 操作。</li></ol><p><strong>阻塞 I/O 和非阻塞 I/O 的区别在于第一步，发起 I/O 请求是否会被阻塞</strong>。如果阻塞直到完成那么就是传统的阻塞 I/O，如果不阻塞，那么就是非阻塞 I/O 。 <strong>同步 I/O 和异步 I/O 的区别就在于第二个步骤是否阻塞</strong>，如果实际的 I/O 读写阻塞请求进程，那么就是同步 I/O 。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;深感自己的能力的不足，此处仅仅是对知识的记录和总结，许多地方都是借鉴他人的语句&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="线程" scheme="http://yoursite.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务--原子性</title>
    <link href="http://yoursite.com/2018/08/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1-%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    <id>http://yoursite.com/2018/08/12/数据库事务-原子性/</id>
    <published>2018-08-12T01:00:00.000Z</published>
    <updated>2018-08-12T16:17:15.188Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据库看似简单，却是个十分复杂的东西</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>ACID：</strong> 指数据库事务正确执行的四个基本要素的缩写。包含：<strong>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</strong>。一个支持事务（Transaction）的数据库，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。 </p><p><strong>如果没有没有正确执行便会出现以下问题：</strong><br>1，脏读（dirtyRead）<br>脏读是指的一个事物正在访问数据，并且对数据进行了修改，而且这种修改还没有提交到数据库中，这时，另一个事物也访问这个数据<br>，然后使用了这个数据。因为这个数据还没有提交数据，那么另外一个事物读到的这个数据就是脏数据。</p><p>2，不可重复读<br>不可重复读，就是在同一事务中，两次读取同一数据（同一主键），得到内容不同。不可重复读和脏读的区别是，不可重复读读取到的都是已经提交的数据，而不是脏数据。</p><p>3，虚读(幻读)<br>幻读指的是，同一事务中，用同样的操作读取两次，得到的记录数不相同。幻读和不可重复读都是读取到了另一条已经提交的事物，这一点和脏读不同。<br>看似幻读和不可重复读都是一样的，但是区别在于不可重复读针对的是同一个主键的数据。而幻读针对的是一批数据两次读取中，有新增或者减少。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>了解了数据库的四大特性，那么今天就来讲讲数据库特性之一 —–<strong>原子性</strong><br>首先：原子性一说大家都明白，那你能说说在<strong>执行的操作过程中，如果还没做完系统就崩溃了，或者断电了，你怎么办啊？ 你怎么保证原子性？如果我还没做完，系统就崩溃了，那系统重启以后我就得做恢复操作？</strong></p><p>下面我们就来讲讲这个问题的答案。<br>首先以<strong>旺财有200块钱， 小强有50 块钱，现在旺财要给小强转账，假设转100块</strong>为例。如果按照事务完整进行则会有一下四步：<br>(1)  开始事务 T1 （假设T1是个事务的内部编号）<br>(2)  旺财余额 = 旺财余额 -100<br>(3)  小强余额 = 小强余额 + 100<br>(4)  提交事务 T1<br>我们知道所有的计算操作都是在内存中进行的，这个时候被计算的数据首先放入缓冲区中：如下图<br><img src="原子性.jpg" alt="原子"><br>因为硬盘的速度太慢，所以不会经常性的操作硬盘，而是把数据放入到缓冲区中，然后一次性保存到硬盘中。</p><h2 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h2><p>这里先假定数据缓冲区能和硬盘的数据文件同步。<br>问题：旺财在给小强转账， 第二步执行完了，旺财的余额变成了100块 （200-100）， 假设已经写入了硬盘文件， 现在断电了， 小强的余额有没有加上，系统的钱白白消失了100块， 数据已经不一致了，  你怎么办？<br>而这个叫做Undo的日志文件，就是为了解决这个问题的。<br><strong>分析：</strong><br>按照上面的情况，会在日志文件中记录下事务开始之前他俩账号余额：</p><blockquote><p>[事务T1,  旺财原有余额 ， 200]<br>   [事务T1, 小强原有余额， 50 ] </p></blockquote><p>如果事务执行到一半，就断电了，那数据库重启以后我就根据undo的日志文件来恢复。</p><p><strong>问题：恢复数据的时候， 那你怎么才能知道一个事务没有完成呢？</strong></p><blockquote><p>[开始事务 T1]<br>   [事务T1, 旺财原有余额，200]<br>    [事务T1, 小强原有余额，50]<br>    [提交事务 T1]</p></blockquote><p>Undo日志文件中不仅仅只有余额， 事务的开始和结束也会记录，如果我在日志文件中看到了<strong>提交事务 T1</strong>, 或者 <strong>回滚事务 T1</strong>, 我就知道这个事务已经结束，不用再去理会它了， 更不用去恢复。 如果我只看到 <strong>开始事务 T1</strong>, 而找不到提交或回滚，那我就得恢复。比如下面这个：</p><blockquote><p>[开始事务 T1]<br>   [事务T1, 旺财原有余额，200]<br>   [事务T1, 小强原有余额，50]</p></blockquote><p>如果已经恢复了，就在日志文件中加上一行 <strong>回滚事务 T1</strong> ， 这样下一次恢复我就不用再考虑T1这个事务了。</p><p><strong>问题：那我们应该什么时候记录Undo日志呢？什么时候把Undo日志写入文件呢？</strong></p><p>把日志记录也放到了内存的Undo日志缓冲区，伺机写入硬盘。<br><img src="日志.jpg" alt="日志"></p><p>我们来看看下面的分析：</p><ol><li>如果系统在第4步和第5步之间崩溃，旺财的余额写入了硬盘，但是小强的还没写入， 那Undo日志看起来是这样的：</li></ol><blockquote><p>[开始事务 T1]<br>   [事务T1, 旺财原有余额，200]</p></blockquote><p>由于找不到事务结束的日志， 你会进行恢复操作， 把旺财的原有余额给恢复了。</p><ol start="2"><li>如果是在第7步和第8步之间系统崩溃，旺财和小强的最新余额都写入了硬盘，但是没有提交事务， 那Undo日志看起来是这样的：</li></ol><blockquote><p>[开始事务 T1]<br>  [事务T1, 旺财原有余额，200]<br>  [事务T1, 小强原有余额，50]</p></blockquote><p>由于没有事务结束的日志，你也需要进行恢复，把旺财和小强的原有余额恢复成200和50 ”</p><ol start="3"><li>如果是在第8步和第9步之间系统崩溃， 旺财和小强的最新余额都写入了硬盘， 也提交了事务， 但是提交事务的操作没有写入Undo 日志， 所以Undo日志还是这样：</li></ol><blockquote><p>[开始事务 T1]<br>   [事务T1, 旺财原有余额，200]<br>   [事务T1, 小强原有余额，50]</p></blockquote><p>由于没有事务结束的日志，你还得需要进行恢复，把旺财和小强的原有余额恢复成200和50。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这里面是有规律的，如果实现了这个规律便可以解决所有的问题：</p><ol><li><p>在你把最新余额写入硬盘之前， <strong>一定要先把相关的Undo日志记录写入硬盘</strong>。 例如 <strong>[事务T1, 旺财原有余额，200]</strong> 一定要在旺财的新余额=100写入硬盘之前写入。</p></li><li><p><strong>[提交事务 T1]</strong> 这样的<strong>Undo日志记录一定要在所有的新余额写入硬盘之后再写入</strong>。  有了这两条的保证，我就可以高枕无忧了！， 比如说，换个操作次序也没有问题：<br><img src="日志2.jpg" alt="日志"></p></li></ol><h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665514001&amp;idx=1&amp;sn=17b72c3e69db6c4277e3045c699b7b6b&amp;chksm=80d67c52b7a1f5446020826841869221873f4578524181384592839d19c4810dc68807117e13&amp;mpshare=1&amp;scene=1&amp;srcid=0311ddHdl0tOCk3XkUy6l8lA#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665514001&amp;idx=1&amp;sn=17b72c3e69db6c4277e3045c699b7b6b&amp;chksm=80d67c52b7a1f5446020826841869221873f4578524181384592839d19c4810dc68807117e13&amp;mpshare=1&amp;scene=1&amp;srcid=0311ddHdl0tOCk3XkUy6l8lA#rd</a></p><blockquote><p>我所向往的不过是如此简单而已</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;数据库看似简单，却是个十分复杂的东西&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;ACID：&lt;/st
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库，事务" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>策略模式和观察者模式</title>
    <link href="http://yoursite.com/2018/07/31/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/07/31/策略模式和观察者模式/</id>
    <published>2018-07-31T14:09:00.000Z</published>
    <updated>2018-08-12T14:07:44.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>哪里会有人喜欢孤独，不过是不喜欢失望罢了。</p></blockquote><p>在学习Zstack时候看到了系统中多处使用策略模式和观察者模式，学习发现这两种模式在开发中经常用到，故在此记录下来。</p><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</strong><br>策略模式是一种对象行为型模式。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以<strong>根据环境或者条件的不同选择不同的策略来完成该项任务</strong>。</li><li>在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。</li><li>在软件系统中，<strong>有许多算法可以实现某一功能</strong>，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。</li></ol><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="策略模式.jpg" alt="策略"><br>对照类图可以看到，<strong>策略模式</strong>与模版方法模式的区别仅仅是多了一个单独的<strong>封装类Context</strong>，它与模版方法模式的区别在于：在模版方法模式中，调用算法的主体在抽象的父类中，而在策略模式中，调用算法的主体则是封装到了封装类Context中，<strong>抽象策略Strategy一般是一个接口，目的只是为了定义规范</strong>，里面一般不包含逻辑。其实，这只是通用实现，而在实际编程中，因为各个具体策略实现类之间难免存在一些相同的逻辑，为了避免重复的代码，我们常常使用抽象类来担任Strategy的角色，在里面封装公共的代码。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><ol><li>创建一个接口</li></ol><p><strong>Strategy.java</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">   public int doOperation(int num1, int num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>创建实现接口的实体类</li></ol><p><strong>OperationAdd.java</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class OperationAdd implements Strategy&#123;</span><br><span class="line">   @Override</span><br><span class="line">   public int doOperation(int num1, int num2) &#123;</span><br><span class="line">      return num1 + num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>创建 Context 类</li></ol><p><strong>Context.java</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">   private Strategy strategy;</span><br><span class="line"> </span><br><span class="line">   public Context(Strategy strategy)&#123;</span><br><span class="line">      this.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public int executeStrategy(int num1, int num2)&#123;</span><br><span class="line">      return strategy.doOperation(num1, num2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出：创建Context时，传入不同的Strategy的子类会执行不同的功能方法。使用到java<strong>父类的引用指向子类对象</strong>。</p><h2 id="优缺点和注意事项"><a href="#优缺点和注意事项" class="headerlink" title="优缺点和注意事项"></a>优缺点和注意事项</h2><p>优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。<br>缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。</p><h2 id="Zstack中的体现"><a href="#Zstack中的体现" class="headerlink" title="Zstack中的体现"></a>Zstack中的体现</h2><p><img src="zstack中体现.jpg" alt="策略"><br>Zstack中充斥着大量的回调函数，如上图所示。CloudBusCallBack是一个接口，通过在方法中实现匿名类重写接口中定义的方法，方法中的功能可以根据上层类要实现的功能去灵活的定义。 这种方式就和传入一个子类对象一样，不过这个子类对象没有名字。因为Zstack所有功能的模块都是通过异步通信的，对策略模式了解可以有效的加深对整个Zstack的了解。</p><hr><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。<br><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p><h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ol><blockquote><p>注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p></blockquote><h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2><p>创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。<br><img src="观察者.jpg" alt="观察"></p><h2 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h2><p>观察者模式，我理解的就是<strong>观察者订阅被观察者的状态，当被观察者状态改变的时候会通知所有订阅的观察者的过程。</strong></p><ol><li>创建观察者接口</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Observer &#123;    </span><br><span class="line">    public abstract void update(String msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>观察者的实现类</li></ol><p>第一个观察者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class F_Observer extends Observer &#123;</span><br><span class="line">    public void update(String msg) &#123;</span><br><span class="line">        System.out.println(F_Observer.class.getName() + &quot; : &quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二个观察者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">S_Observer</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">void</span> update(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">        System.out.println(S_Observer.class.getName() + <span class="string">" : "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三个观察者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">T_Observer</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">void</span> update(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">        System.out.println(T_Observer.class.getName() + <span class="string">" : "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>被观察者</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;        </span><br><span class="line">    private List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();    <span class="comment">//状态改变    </span></span><br><span class="line">    public <span class="keyword">void</span> setMsg(<span class="built_in">String</span> msg) &#123;        </span><br><span class="line">        notifyAll(msg);    </span><br><span class="line">    &#125;   </span><br><span class="line">     <span class="comment">//订阅    </span></span><br><span class="line">    public <span class="keyword">void</span> addAttach(Observer observer) &#123;        </span><br><span class="line">        observers.add(observer);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//通知所有订阅的观察者    </span></span><br><span class="line">    private <span class="keyword">void</span> notifyAll(<span class="built_in">String</span> msg) &#123;        </span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;            </span><br><span class="line">            observer.update(msg);        </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>运行</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;    </span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;        </span><br><span class="line">        F_Observer fObserver = <span class="keyword">new</span> F_Observer();        </span><br><span class="line">        S_Observer sObserver = <span class="keyword">new</span> S_Observer();        </span><br><span class="line">        T_Observer tObserver = <span class="keyword">new</span> T_Observer();                </span><br><span class="line">        Subject subject = <span class="keyword">new</span> Subject();        </span><br><span class="line">        subject.addAttach(fObserver);        </span><br><span class="line">        subject.addAttach(sObserver);        </span><br><span class="line">        subject.addAttach(tObserver);                </span><br><span class="line">        subject.setMsg(<span class="string">"msg change"</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>从上面的代码中可以看出，当被观察者的行为改变的时候就可以通知观察者，观察者可以依据不同的变现做出不同的反应，<strong>我猜想：</strong>MQ有一种模式是消息订阅模式，其中必用到观察者模式，不过MQ使用的必然是异步的方式。</p><h2 id="Zstack中的体现-1"><a href="#Zstack中的体现-1" class="headerlink" title="Zstack中的体现"></a>Zstack中的体现</h2><p><strong>观察者模式</strong>在Zstack中的体现就要和<strong>Zstack的三驾马车（后面会讲到）</strong>联系到一起了。三驾马车分别对应着三层：<strong>应用层，业务层和领域层。</strong><br><strong>应用层（可以被调用的API）</strong>：就是界面定义的一些功能。<br><strong>业务层（一个Impl）</strong>：一个服务的入口，对功能的分发，不会处理底层很具体功能。<br><strong>领域层（base）</strong>：这层主要是一些行为的逻辑，对某一个功能具体的操作。</p><blockquote><p>我们知道各个层之间是需要<strong>通信</strong>的，那么层与层之间只能是单向的。上层可以直接使用或操作下层元素，方法是通过调用下层元素的公共接口，保持对下层元素的引用（至少是暂时的），以及采用常规的交互手段。而如果下层元素需要与上层元素通信，则需要采用另一种<strong>通信机制</strong>——比如<strong>回调或者Observers模式</strong>（在ZStack中即是ExtensionPoint）。</p></blockquote><p>这里以PrimaryStorageBase为例：在PrimaryStorageBase中，其中handle APIAttachPrimaryStorageToClusterMsg的地方会做事件发送：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extpEmitter.preAttach(self, msg.getClusterUuid());</span><br></pre></td></tr></table></figure><p>其会发送向：<br><img src="connectHook.jpg" alt="connect"><br>在抽象等级上，PrimaryStorageBase是比图中的这些Base高的。而<strong>这类具象Base可以使Message返回Success或者Fail使高层Base做出不同的决策</strong>。这里是通过回调函数的形式来对上层的Base进行通知的。具体对象的Base执行失败或者成功会回调上层的fail或者success，这样上层就知道下面的方法是否执行成功。因为系统中都是通过异步的方式来实现的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;哪里会有人喜欢孤独，不过是不喜欢失望罢了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在学习Zstack时候看到了
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，Java" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8CJava/"/>
    
  </entry>
  
  <entry>
    <title>1688开放平台对接</title>
    <link href="http://yoursite.com/2018/06/19/1688%E5%AF%B9%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/06/19/1688对接/</id>
    <published>2018-06-19T09:33:00.000Z</published>
    <updated>2018-06-27T13:16:24.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>什么是1688开放平台（ <a href="https://open.1688.com" target="_blank" rel="noopener">https://open.1688.com</a>  ）？</p><blockquote><p>依托B2B海量用户资源以及强大的平台优势，是为阿里巴巴商家提供基础服务的重要开放途径，帮助商家提升经营能力、拓宽生意渠道、提高办公效率。从今年开始，阿里巴巴开放平台将向合作伙伴和广大第三方开发者逐步开放会员、公司库、类目、产品、交易、咨讯等一系列接口。为合作伙伴提供快捷的提交通路，多入口最优展现的同时，共享商机，互利双赢。</p></blockquote><hr><h3 id="对接过程"><a href="#对接过程" class="headerlink" title="对接过程"></a>对接过程</h3><p>以下演示是以对接1688采购订单为例。</p><h4 id="1-注册开发者"><a href="#1-注册开发者" class="headerlink" title="1 注册开发者"></a>1 注册开发者</h4><p>如果想使用1688开放平台，必须首先要注册成为开发者，需要同时具备以下两个条件：</p><ol><li>具备一个阿里巴巴中国站帐号；</li><li>必须绑定了通过个人实名（公司企业）认证的支付宝帐号；个人开发者必须绑定通过个人实名认证的支付宝账号，企业开发者必须绑定通过商家认证的支付宝账号；</li></ol><p>开发者身份绑定的支付宝账户用于产品分成结算的收款账户。因此为了确认您的身份和安全考虑，必须通过支付宝认证。</p><h4 id="2-获取证书"><a href="#2-获取证书" class="headerlink" title="2 获取证书"></a>2 获取证书</h4><p>一、什么是应用证书：<br>证书指的是开发者在阿里巴巴开放平台创建应用是默认给开发者的应用开发证书。想要调用1688开放平台上的API必须申请证书。证书包含四个内容：</p><p><strong>证书编号：App Key</strong></p><p><strong>证书密钥：App Secret</strong></p><p>接口权限：开发者可以调用的API权限，包含基础开放与增值包</p><p>证书流量：应用可以调用API的流量限制</p><p>也就是“权限+流量+appkey+app secret=证书”，每个应用都有对应的应用开发证书，在应用创建时开发者获得证书。<br>二、什么是App Key？</p><p>App Key是应用的唯一标识，阿里巴巴开放平台通过App Key来鉴别应用的身份。<br>三、什么是App Secret？</p><p>AppSecret是阿里巴巴开放平台给应用分配的密钥，开发者需要妥善保存这个密钥，这个密钥用来保证应用来源的可靠性，防止被伪造。</p><h5 id="获取证书过程"><a href="#获取证书过程" class="headerlink" title="获取证书过程"></a>获取证书过程</h5><blockquote><p><a href="https://open.1688.com/developer/serviceType.htm?spm=a260s.8209130.sidebar.2.4fbb55edhIdo07#/?_k=l6b00o" target="_blank" rel="noopener">https://open.1688.com/developer/serviceType.htm?spm=a260s.8209130.sidebar.2.4fbb55edhIdo07#/?_k=l6b00o</a></p></blockquote><p>1.<strong>创建应用</strong>：根据自己公司的业务需求可以选择不同的应用类型，如下图所示：</p><p><img src="创建应用.jpg" alt="1688"><br>选择采购对接<br><img src="采购对接.jpg" alt="1688"><br>企业对接面向的是从1688网站上采购的数据信息拉取到公司自己的管理软件中进行统一的管理。点击<strong>采购对接</strong>后填写必要的一些信息提交申请就可以了。<br>在填写信息的时候，<strong>应用类目</strong>选择企业采购，大企业采购一般是通过不了的；<strong>授权用户数</strong>可以选择<strong>单用户授权</strong>也可以选择<strong>多用户授权</strong>，他们其中的区别放到下面讲。<br><img src="信息填写.jpg" alt="1688"></p><p>提交成功后便可在<strong>应用列表</strong>中看到申请到的对接应用。可以点击查看，就会看到应用详情，里面便包括了App Key和App Secret。如下图：<br><img src="查看应用详情.jpg" alt="1688"></p><p>2.<strong>申请解决方案</strong>：即针对你申请到的账户需要申请调用对应API的权限</p><p><strong>申请解决方案</strong>一般在48小时之内会反馈方案是否给予通过。所以开发的时候如果急于上线，需要提前申请。通过的解决方案便可以使用。<br><img src="申请解决方案.jpg" alt="1688"></p><p>3.<strong>测试账号</strong></p><p>当你在解决方案列表看到已经通过的账号，下一步就需要在线测试账号的可用性。<br>在API文档中点击<strong>API TOOLS 在线测试工具</strong>，输入App Key和App Secret便可以测试账号是否可用。<br><img src="测试.jpg" alt="1688"></p><p>4.<strong>下载jar包进行开发</strong></p><p><img src="sdk下载.jpg" alt="1688"></p><p>5.<strong>编程</strong></p><p>具体代码请看我的github上的项目，里面有完整的授权流程代码，地址：<a href="https://github.com/Foutlook/Docking-1688-Interface" target="_blank" rel="noopener">多用户授权下调用1688接口API授权流程</a>。</p><h4 id="3-关于单用户授权和多用户授权的说明"><a href="#3-关于单用户授权和多用户授权的说明" class="headerlink" title="3 关于单用户授权和多用户授权的说明"></a>3 关于单用户授权和多用户授权的说明</h4><p>我们首先看一下官方给的不同授权方式的定义：<br><img src="授权.jpg" alt="1688"></p><blockquote><p><strong>单用户授权和多用户授权</strong>的区别是：<br>1.单用户授权在调用API的时候不需要传access_token，而多用户授权需要传access_token ,不然的话无法调用1688的API。<br>2.单用户授权在申请上线的时候一个公司只能有一个账户，而多用户授权在上线的时候可以有多个账户。<br>3.多用户授权可以关联其他的账户，通过一个账户拉去多个账户的信息。</p></blockquote><p>虽然多用户授权有很多的好处，不过它开发起来要比单用户授权麻烦很多，主要是处理access_token 的问题。<br>首先我们先看看多用户授权下access_token 的授权流程，也就是获取access_token 的流程（<a href="https://open.1688.com/api/sysAuth.htm?spm=a260s.8208024.0.0.9f0e55edLOgOy1&amp;ns=cn.alibaba.open" target="_blank" rel="noopener">官网授权解释地址</a>）：</p><p><img src="流程.jpg" alt="1688"><br>首先通过code即<strong>临时令牌</strong>得到<strong>access_token</strong>，第一次授权后会得到<strong>refresh_token</strong>，等下次access_token过期的时候就可以通过refresh_token来得到。授权的流程图如下所示：<br><img src="授权流程.jpg" alt="1688"></p><p>具体代码请看我的github，地址：<a href="https://github.com/Foutlook/Docking-1688-Interface" target="_blank" rel="noopener">多用户授权下调用1688接口API授权流程</a>。</p><hr><p><strong>END</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;什么是1688开放平台（ &lt;a href=&quot;https://open.1688.com&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
    
      <category term="1688,1688开放平台,阿里巴巴" scheme="http://yoursite.com/tags/1688-1688%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"/>
    
  </entry>
  
  <entry>
    <title>初次提交代码总结</title>
    <link href="http://yoursite.com/2018/05/26/%E5%88%9D%E6%AC%A1%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/05/26/初次提交代码总结/</id>
    <published>2018-05-26T01:00:00.000Z</published>
    <updated>2018-11-14T13:40:55.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>自己空白的还有很多，记录一下本周所感所想</p></blockquote><p>本周算是经历了第一次的merge request，虽然是在我师傅写好的代码下填补一些小功能，不过感觉学到的东西还是挺多的。无论是对开发中的细节，还是良好习惯的培养都让我受益颇多。</p><hr><h2 id="从前"><a href="#从前" class="headerlink" title="从前"></a>从前</h2><p>前面的一个月基本上都是在学习zstack的基本知识，架构还有里面的实现原理。这次也是我真正去读别人的代码，跟着别人代码的思想去理解整个结构，去添加一些需求。可以说这周的开发过程也是对我一次深刻的提醒。<br>意识到其实在以前学习zstack的时候许多重要的点并没有深刻的去理解，以前的心态就是能看懂就行，不需要问原因和原理，所以遇到一些不是特别清晰的并没有过于的深刻探究其中主要原理。像Inner Msg在zstack中处理的过程，CloudBus怎么处理去拦截和收集这些消息的，FlowChain的调用过程，回调实现的方式，一些类的继承实现有的时候居然不知道为什么。以前在学校的时候就接触过回调函数这方面的知识点，也从未认真看过。这次要不是我师傅的指点，我恐怕陷得很深。</p><hr><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>本周主要是对审计模块一些简单功能的添加，实现用户自定义operation name，并且添加一些基本的测试。这两个功能前前后后花了一周的时间。接到需求的第一天，我大概浏览了各个问题的要求，然后开始添加自己的代码，在做的过程中，我发现我面临许多的问题，我对问题并不是很理解。比如添加用户自定义operation name，我理解的就是把某一个属性写到配置文件中，加载新来而已。还有添加inner  msg的case，我以为Inner Msg实现审计模块会有人帮我写好。一切都源于对问题的不清晰然后就开始干，第一天就踩了不少的坑。辛亏我师父救场，问我有哪些不懂的问题，不然我还在按照自己的思路在写。还有后面看代码十分的不认真，有一个问题是set集合的泛型问题，在创建HashSet集合的时候，泛型放在前面和后面有着不同的意义。<br>其实开始的我以为这部分功能最多三天就搞完了，最终还是在我师父帮助下，五天勉勉强强的完成。我总结这次主要原因如下：</p><ol><li>zstack部分功能理解不深入</li><li>没有搞清楚需求是怎么样的就急于入手</li><li>不善于提问，总认为自己可以解决，思维逻辑混乱</li><li>过于浮躁，不认真</li></ol><hr><h2 id="以后"><a href="#以后" class="headerlink" title="以后"></a>以后</h2><p>踩坑真的是能让人进步的过程，如果不真的接触代码，真的很少能够意识到那么多的问题。<br><strong>现阶段我不足的部分：</strong></p><ol><li>回调方面的部分，我总是感觉有些地方不是特别理解，但是又说不上来。</li><li>FlowChain部分也是有点模糊</li><li>… 等待发现</li></ol><p>也许这几部分也要通过写代码的方式来锻炼，来理解。后面的工作我会尽力去做。不能解决的问题，我会尽量的问我的师傅，不会自己再闷头苦想（虽然自己是应届生，不过遇到弱智的问题，感觉还是挺丢人的）。</p><p>后面再写一段代码，我会把我学到的zstack知识尽量做一个总结，写几篇博客，把zstack的原理自己总结一下。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>跟着QB团队学到不少的东西，有着中国第一的PM孙总，zstack的高级开发者和精通Java的我师傅，python和java都精通的伟嘉，打得过PM的高级开发工程师强哥，受益匪浅。比在上海那三个月的实习学到的多得多。不过感觉赶上他们的步伐还是好难。这段时间也听到了很多陌生的词，像比特币，区域块，股票方面的知识还有他们对中国经济和政府投资的分析。我有的时候真的明天为什么有些人可以赚那么多钱了。<br>很感谢我师傅的指导，很有耐心，知道我缺什么，然后认真提出方法来解决。还有我师傅认真起来真的很吓人。<br>最后：</p><blockquote><p>不要把不会当成一个负担，不会就问。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;自己空白的还有很多，记录一下本周所感所想&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本周算是经历了第一次的merg
      
    
    </summary>
    
      <category term="所思" scheme="http://yoursite.com/categories/%E6%89%80%E6%80%9D/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>jdk动态代理</title>
    <link href="http://yoursite.com/2018/01/20/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2018/01/20/jdk动态代理/</id>
    <published>2018-01-20T09:33:00.000Z</published>
    <updated>2018-06-26T11:52:00.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h3><p>代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。<strong>代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理</strong>。<br>为了保持行为的一致性，<strong>代理类和委托类</strong>通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。</p><hr><h3 id="动态代理类"><a href="#动态代理类" class="headerlink" title="动态代理类"></a>动态代理类</h3><p>Java动态代理类位于<strong>java.lang.reflect</strong>包下，一般主要涉及到以下两个类：<br>(1) Interface InvocationHandler：该接口中仅定义了一个方法</p><ul><li>publicobject invoke(Object obj,Method method, Object[] args)</li><li>在实际使用时，第一个参数obj一般是<strong>指代理类</strong>，method是被代理的方法，args为该方法的参数数组，这个抽象方法在代理类中动态实现。</li></ul><p>(2) Proxy：该类即为动态代理类，其中主要包含以下内容：    </p><ul><li>protected Proxy(InvocationHandler h)：构造函数，用于给内部的h赋值。</li><li>static InvocationHandler getInvocationHandler(Object proxy) :返回指定代理实例的调用处理程序</li><li>static Class&lt;?&gt; getProxyClass (ClassLoaderloader, Class[] interfaces)：返回代理类的 java.lang.Class 对象，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。</li><li>static boolean isProxyClass(Class&lt;?&gt; cl) //当且仅当指定的类通过 getProxyClass 方法或 newProxyInstance 方法动态生成为代理类时，返回 true。 </li><li><p>static Object newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h):/返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。</p><p><strong>所谓DynamicProxy是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些interface。你当然可以把该class的实例当作这些interface中的任何一个来用。当然，这个DynamicProxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。</strong><br>在使用动态代理类时，我们必须<strong>实现InvocationHandler接口</strong>，通过这种方式，被代理的对象(RealPerson)可以在运行时动态改变，需要控制的接口(Person接口)可以在运行时改变，控制的方式(DynamicSubject类)也可以动态改变，从而实现了非常灵活的动态代理关系。</p></li></ul><hr><h3 id="动态代理的步骤"><a href="#动态代理的步骤" class="headerlink" title="动态代理的步骤"></a>动态代理的步骤</h3><p>1.创建一个实现接口InvocationHandler的类，它必须实现invoke方法<br>2.创建被代理的类以及接口<br>3.通过Proxy的静态方法<br>newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)创建一个代理<br>4.通过代理调用方法</p><hr><h3 id="动态代理的实现"><a href="#动态代理的实现" class="headerlink" title="动态代理的实现"></a>动态代理的实现</h3><p>1：创建动态代理的接口</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.Proxy_one;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态代理接口</span></span><br><span class="line">public interface Person &#123;</span><br><span class="line">String SayHello(String name);</span><br><span class="line">String SayGoodBye();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2：创建需要代理的对象</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.Proxy_one;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际对象</span></span><br><span class="line">public class RealPerson implements Person &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String SayHello(String name) &#123;</span><br><span class="line">return "Hello "+name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String SayGoodBye() &#123;</span><br><span class="line">return "Bye";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3：实现InvocationHandler类，重写invoke方法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.Proxy_one;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用处理类实现类</span></span><br><span class="line"><span class="comment">//每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象</span></span><br><span class="line">public class InvocationHandlerImpl implements InvocationHandler &#123;</span><br><span class="line"><span class="comment">//我们要代理的真是对象</span></span><br><span class="line">private Person person;</span><br><span class="line">public InvocationHandlerImpl(Person person) &#123;</span><br><span class="line">this.person = person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法负责集中处理动态代理类上的所有方法调用</span></span><br><span class="line"><span class="comment"> * 调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"><span class="comment">//在代理真实对象方法前可以添加自己的操作</span></span><br><span class="line">System.out.println("在调用方法之前，我正在走路！");</span><br><span class="line">System.out.println("Method:"+method);</span><br><span class="line"><span class="comment">/*当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler</span></span><br><span class="line"><span class="comment"> *对象的invoke方法进行调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object returnValue = method.invoke(person, args);</span><br><span class="line"><span class="comment">//调用真实的代理对象的方法后，我们可以添加自己的方法</span></span><br><span class="line">System.out.println("调用之后，我继续向前走！");</span><br><span class="line"></span><br><span class="line">return returnValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4：测试jdk动态代理</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.Proxy_one;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class DynamicProxyTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"><span class="comment">//代理的真实对象</span></span><br><span class="line">Person realperson = new RealPerson();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能</span></span><br><span class="line"><span class="comment">         * 实现方法调用从代理类到委托类的分派转发</span></span><br><span class="line"><span class="comment">         * 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.</span></span><br><span class="line"><span class="comment">         * 即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">InvocationHandler ih = new InvocationHandlerImpl(realperson);</span><br><span class="line">Person proxy = (Person) Proxy.newProxyInstance(realperson.getClass().getClassLoader(),</span><br><span class="line">realperson.getClass().getInterfaces(), ih);</span><br><span class="line">System.out.println("动态代理对象的类型："+proxy.getClass().getName());</span><br><span class="line">String hello = proxy.SayHello("樊兴凯");</span><br><span class="line">System.out.println(hello);</span><br><span class="line">String bye = proxy.SayGoodBye();</span><br><span class="line">System.out.println(bye);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5：输出结果</p><blockquote><p>动态代理对象的类型：com.sun.proxy.$Proxy0<br>在调用方法之前，我正在走路！<br>Method:public abstract java.lang.String com.fan.Proxy_one.Person.SayHello(java.lang.String)<br>调用之后，我继续向前走！<br>Hello 张三<br>在调用方法之前，我正在走路！<br>Method:public abstract java.lang.String com.fan.Proxy_one.Person.SayGoodBye()<br>调用之后，我继续向前走！<br>Bye</p></blockquote><hr><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>使用匿名内部类的方式来实现 InvocationHandlerImpl</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.Proxy_two;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class DynamicProxyTest2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Person person = new RealPerson();</span><br><span class="line">Person proxy = (Person)Proxy.newProxyInstance(person.getClass().getClassLoader(), person.getClass().getInterfaces(),</span><br><span class="line">new InvocationHandler() &#123;</span><br><span class="line"><span class="comment">//使用匿名内部类的方式</span></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"><span class="comment">//在方法调用前，添加自己的动作</span></span><br><span class="line">System.out.println("打招呼之前-");</span><br><span class="line">System.out.println("Method:"+method);</span><br><span class="line">Object obj = method.invoke(person, args);</span><br><span class="line">System.out.println("打招呼之后----");</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println("动态代理对象的类型："+proxy.getClass().getName());</span><br><span class="line">String hello = proxy.SayHello("张三");</span><br><span class="line">System.out.println(hello);</span><br><span class="line">String goodbye = proxy.SayGoodBye();</span><br><span class="line">System.out.println(goodbye);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><blockquote><p>动态代理对象的类型：com.sun.proxy.$Proxy0<br>打招呼之前-<br>Method:public abstract java.lang.String com.fan.Proxy_two.Person.SayHello(java.lang.String)<br>打招呼之后—-<br>Hello 张三<br>打招呼之前-<br>Method:public abstract java.lang.String com.fan.Proxy_two.Person.SayGoodBye()<br>打招呼之后—-<br>Bye</p></blockquote><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>一个典型的动态代理创建对象过程可分为以下四个步骤：<br>1、通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = new InvocationHandlerImpl(…);<br>2、通过为Proxy类指定ClassLoader对象和一组interface创建动态代理类<br>Class clazz = Proxy.getProxyClass(classLoader,new Class[]{…});<br>3、通过反射机制获取动态代理类的构造函数，其参数类型是调用处理器接口类型<br>Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});<br>4、通过构造函数创建代理类实例，此时需将调用处理器对象作为参数被传入<br>Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler));<br>为了简化对象创建过程，Proxy类中的newInstance方法封装了2~4，只需两步即可完成代理对象的创建。<br>生成的RealPerson继承Proxy类实现Person接口，实现的Person的方法实际调用处理器的invoke方法，而invoke方法利用反射调用的是被代理对象的的方法（Object result=method.invoke(proxied,args)）</strong></p><hr><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>Proxy已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。<br>Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。有很多条理由，人们可以否定对 class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。如果只从方法的声明以及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。但是，不完美并不等于不伟大，伟大是一种本质，Java动态代理就是佐例。<br><strong>jdk给目标类提供动态要求目标类必须实现接口，当一个目标类不实现接口时，jdk是无法为其提供动态代理的。cglib 却能给这样的类提供动态代理。</strong>cglib在接下来的时间里将会介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;动态代理&quot;&gt;&lt;a href=&quot;#动态代理&quot; class=&quot;headerlink&quot; title=&quot;动态代理&quot;&gt;&lt;/a&gt;动态代理&lt;/h2&gt;&lt;h3 id=&quot;什么是代理&quot;&gt;&lt;a href=&quot;#什么是代理&quot; class=&quot;headerlink&quot; title=&quot;什么是代理&quot;&gt;
      
    
    </summary>
    
    
      <category term="java,动态代理" scheme="http://yoursite.com/tags/java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Eclipse中git的使用</title>
    <link href="http://yoursite.com/2018/01/16/Egit%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/01/16/Egit的使用/</id>
    <published>2018-01-16T09:33:00.000Z</published>
    <updated>2018-06-26T11:51:57.068Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>git在eclipse中的配置和远程仓库中关联，这里不再累述，如果有问题可以参考下面博客：这里有详细的说明。</strong></p><blockquote><p><a href="http://blog.csdn.net/hhhccckkk/article/details/10458159" target="_blank" rel="noopener">http://blog.csdn.net/hhhccckkk/article/details/10458159</a></p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>下面主要是我在使用中遇到的问题：rejected - non-fast-forward<br><img src="rejected.jpg" alt="git"><br>我在网上查找原因的时候，并没有一个很完整的文档，总结的都是挺乱的。故我对使用方式给予详细总结，以帮助更多的人。</p><hr><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p><strong>出现此问题的原因主要是：</strong></p><blockquote><p>我们平时使用eclipse开发的时候，主要是用git的commit和push，如果你的github库没有初始化，第一次push是可以正确提交的，但是当你已经push过一次后，会遇到无法提交到master分支（因为master分支是在服务器已经初始化好了，在服务器上已经存在了一个master分支，你在本地初始化的master分支和服务器的有冲突，并不是一个分支，就会提示rejected - non-fast-forward），如果你此时非要想提交到主分支，必须先要把服务器的初始化的git主分支pull到本地。只有这样才能正确的提交。</p></blockquote><hr><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><strong>1，点window—preference–team—git–configuration————-Repository Settings，Repository选择你的项目的本地仓库，然后点右边的open，</strong>视图如下：</p><p><img src="configuration2.jpg" alt="git"></p><p>open后会看到如下的config信息<br><img src="config.jpg" alt="git"></p><p><strong>2，然后在上面的基础上填上如下信息</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[branch <span class="string">"master"</span>]</span><br><span class="line">   remote = origin</span><br><span class="line">   merge = refs/heads/master</span><br><span class="line"></span><br><span class="line">[remote <span class="string">"origin"</span>]</span><br><span class="line">   url = git@github<span class="selector-class">.com</span>:xxxx/xx                    -----&gt;你自己的仓库ssh的url</span><br><span class="line">   fetch = +refs/heads<span class="comment">/*:refs/remotes/origin/*</span></span><br><span class="line"><span class="comment">   push = refs/heads/master:refs/heads/master</span></span><br></pre></td></tr></table></figure><p><img src="gitRepositories.jpg" alt="git"></p><p><strong>3，配置好后选择项目Team–&gt; pull ，会看到项目会变成如下效果：</strong></p><p><img src="pull.jpg" alt="git"></p><p>查看本地仓库目录：<br><img src="readme.jpg" alt="git"></p><p><strong>4，push本地项目到远程仓库</strong></p><p><img src="destination.jpg" alt="git"></p><p>过程和第一次push的过程相同，填写信息然后push就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;git在eclipse中的配置和远程仓库中关联，这里不再累述，如果有问题可以参考下面博客：这里有详细的说明。&lt;/strong
      
    
    </summary>
    
    
      <category term="eclipse,git,github" scheme="http://yoursite.com/tags/eclipse-git-github/"/>
    
  </entry>
  
  <entry>
    <title>装饰者模式</title>
    <link href="http://yoursite.com/2017/12/30/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/12/30/装饰者模式/</id>
    <published>2017-12-30T09:33:00.000Z</published>
    <updated>2018-06-26T11:51:58.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设置模式之装饰者模式"><a href="#设置模式之装饰者模式" class="headerlink" title="设置模式之装饰者模式"></a>设置模式之装饰者模式</h2><p><strong>装饰者模式(Decorator)是一种结构式模式。动态地给一个对象添加一些额外的职责。就增加功能来说，装饰者模式相比生成子类更为灵活。同时还可以让这些装饰类互相装饰。</strong><br> <img src="装饰者模式.jpg" alt="设计模式"></p><hr><h3 id="1-装饰者设计模式的步骤："><a href="#1-装饰者设计模式的步骤：" class="headerlink" title="1: 装饰者设计模式的步骤："></a>1: 装饰者设计模式的步骤：</h3><p>a.在装饰类的内部维护一个被装饰类的引用。<br>b.让装饰类有一个共同的父类或者是父接口</p><hr><h3 id="2-具体过程："><a href="#2-具体过程：" class="headerlink" title="2:具体过程："></a>2:具体过程：</h3><p>Component : 定义一个对象接口，可以给这些对象动态地添加职责。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line">public interface Component &#123;</span><br><span class="line">void operation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteComponent:实现Component定义的接口</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Component定义的接口</span></span><br><span class="line">public class ConcreteComponent implements Component &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void operation() &#123;</span><br><span class="line">System.out.println("初始化");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Decorator : 装饰抽象类，继承了 Component， 从外类来扩展 Component 类的功能，但对于 Component 来说，是无需知道 Decorator 的存在的。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line">public class Decorator implements Component &#123;</span><br><span class="line"><span class="comment">//维护一个Component对象，和Component形成聚合关系</span></span><br><span class="line">private Component component;</span><br><span class="line">public Decorator(Component component) &#123;</span><br><span class="line">this.component = component;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用要修饰对象的原方法</span></span><br><span class="line">@Override</span><br><span class="line">public void operation() &#123;</span><br><span class="line">component.operation();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteDecoratorA : 具体的装饰对象，起到给 Component 添加职责A的功能。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line">public class ConcreteDecoretorA extends Decorator &#123;</span><br><span class="line"></span><br><span class="line">public ConcreteDecoretorA(Component component) &#123;</span><br><span class="line">super(component);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void operation()&#123;</span><br><span class="line">super.operation();</span><br><span class="line">System.out.println("添加属性：性属性1");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteDecoratorB : 具体的装饰对象，起到给 Component 添加职责B的功能。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line">public class ConcreteDecoratorB extends Decorator &#123;</span><br><span class="line"></span><br><span class="line">public ConcreteDecoratorB(Component component) &#123;</span><br><span class="line">super(component);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void operation() &#123;</span><br><span class="line">super.operation();</span><br><span class="line">System.out.println("添加行为");</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.fan.DecoratorPattern;</span><br><span class="line"></span><br><span class="line">public class DecoratorPattern &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Component component = new ConcreteComponent();</span><br><span class="line">component.operation();</span><br><span class="line">System.out.println("++++++++++++++++++++++");</span><br><span class="line"></span><br><span class="line">Decorator decoratorA = new  ConcreteDecoretorA(component);</span><br><span class="line">decoratorA.operation();     //通过super向上级层层调用</span><br><span class="line">System.out.println("++++++++++++++++++++++");</span><br><span class="line">Decorator decoratorB = new ConcreteDecoratorB(decoratorA);</span><br><span class="line">decoratorB.operation();//B调用A的 --A调用父类的，父类调用接口的实现类operation方法</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><blockquote><p>初始化<br>++++++++++++++++++<br>初始化<br>添加属性：性属性1<br>++++++++++++++++++<br>初始化<br>添加属性：性属性1<br>添加行为</p></blockquote><hr><h3 id="3-装饰者模式的应用场景"><a href="#3-装饰者模式的应用场景" class="headerlink" title="3:装饰者模式的应用场景"></a>3:装饰者模式的应用场景</h3><p>a.需要动态的、透明的为一个对象添加职责，即不影响其他对象。<br>b.需要动态的给一个对象添加功能，这些功能可以再动态的撤销。<br>c.需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。<br>d.当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</p><hr><h3 id="4-要点："><a href="#4-要点：" class="headerlink" title="4:要点："></a>4:要点：</h3><ul><li>装饰者和被装饰对象有相同的超类型。</li><li>可以用一个或多个装饰者包装一个对象。</li><li>装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的。</li><li>对象可以在任何时候被装饰，所以可以在运行时动态的，不限量的用你喜欢的装饰者来装饰对象。</li><li>装饰模式中使用继承的关键是想达到装饰者和被装饰对象的类型匹配，而不是获得其行为。</li><li>装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。在实际项目中可以根据需要为装饰者添加新的行为，做到“半透明”装饰者。</li></ul><hr><h3 id="5-继承实现的增强类和修饰模式实现的增强类有和区别？"><a href="#5-继承实现的增强类和修饰模式实现的增强类有和区别？" class="headerlink" title="5:继承实现的增强类和修饰模式实现的增强类有和区别？"></a>5:继承实现的增强类和修饰模式实现的增强类有和区别？</h3><blockquote><p>继承实现的增强类： 优点：代码结构清晰，而且实现简单.<br>缺点：对于每一个的需要增强的类都要创建具体的子类来帮助其增强，这样会导致继承体系过于庞大。</p><p>装饰者设计模式实现的增强类： 优点：内部可以通过多态技术对多个需要增强的类进行增强，可以使这些装饰类达到互相装饰的效果，使用比较灵活。<br>缺点：需要内部通过多态技术维护需要被增强的类的实例。进而使得代码稍微复杂。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设置模式之装饰者模式&quot;&gt;&lt;a href=&quot;#设置模式之装饰者模式&quot; class=&quot;headerlink&quot; title=&quot;设置模式之装饰者模式&quot;&gt;&lt;/a&gt;设置模式之装饰者模式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;装饰者模式(Decorator)是一种结构式模式。动态地给一
      
    
    </summary>
    
    
      <category term="设计模式,java" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-java/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装Vundle管理vim插件</title>
    <link href="http://yoursite.com/2017/11/20/Ubuntu%E5%AE%89%E8%A3%85Vundle/"/>
    <id>http://yoursite.com/2017/11/20/Ubuntu安装Vundle/</id>
    <published>2017-11-20T09:33:00.000Z</published>
    <updated>2017-12-09T08:50:51.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>我在学习Linux这段时间里，使用vim编程，为了提高自己的逼格，也为了提高自己的效率，就尝试着安装了2个插件。感觉逼格高了很多。</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装其他插件之前，我们首先需要安装一个管理插件的插件，它就是Vundle，Vundle可以帮助我们管理和安装其他的插件，非常好用。</p><h3 id="安装Vundle插件"><a href="#安装Vundle插件" class="headerlink" title="安装Vundle插件"></a>安装Vundle插件</h3><p>Vundle可以在GitHub上找到，地址：<a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="noopener">https://github.com/VundleVim/Vundle.vim</a> </p><p>1、  如果在你的Linux或者Ubuntu中没有暗转git，首先请先安装git</p><blockquote><p>sudo apt-get install git</p></blockquote><p>2、 使用git安装Vundle ，可以安装到~/.vim/bundle/Vundle.vim下</p><blockquote><p>git clone <a href="https://github.com/VundleVim/Vundle.vim.git" target="_blank" rel="noopener">https://github.com/VundleVim/Vundle.vim.git</a> ~/.vim/bundle/Vundle.vim</p></blockquote><p>3、 添加官方文档提供的配置信息到  ~/.vimrc 中(.vimrc 如果不存在就创建一个【vi  ~/.vimrc】)：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">set nocompatible              <span class="string">" be iMproved, required</span></span><br><span class="line"><span class="string">filetype off                      "</span> required</span><br><span class="line"></span><br><span class="line"><span class="string">" set the runtime path to include Vundle and initialize</span></span><br><span class="line"><span class="string">set rtp+=~/.vim/bundle/Vundle.vim</span></span><br><span class="line"><span class="string">call vundle#begin()</span></span><br><span class="line"><span class="string">"</span> alternatively, pass <span class="selector-tag">a</span> path where Vundle should install plugins</span><br><span class="line"><span class="string">"call vundle#begin('~/some/path/here')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> let Vundle manage Vundle, required</span><br><span class="line">Plugin <span class="string">'VundleVim/Vundle.vim'</span></span><br><span class="line"></span><br><span class="line"><span class="string">" The following are examples of different formats supported.</span></span><br><span class="line">" Keep Plugin commands between vundle#begin/end.</span><br><span class="line"><span class="string">" plugin on GitHub repo</span></span><br><span class="line"><span class="string">Plugin 'tpope/vim-fugitive'</span></span><br><span class="line"><span class="string">"</span> plugin from http:<span class="comment">//vim-scripts.org/vim/scripts.html</span></span><br><span class="line"><span class="string">" Plugin 'L9'</span></span><br><span class="line"><span class="string">"</span> Git plugin not hosted on GitHub</span><br><span class="line">Plugin <span class="string">'git://git.wincent.com/command-t.git'</span></span><br><span class="line"><span class="string">" git repos on your local machine (i.e. when working on your own plugin)</span></span><br><span class="line"><span class="string">Plugin 'file:///home/gmarik/path/to/plugin'</span></span><br><span class="line"><span class="string">"</span> The sparkup vim script is <span class="keyword">in</span> <span class="selector-tag">a</span> subdirectory of this repo called vim.</span><br><span class="line"><span class="string">" Pass the path to set the runtimepath properly.</span></span><br><span class="line"><span class="string">Plugin 'rstacruz/sparkup', &#123;'rtp': 'vim/'&#125;</span></span><br><span class="line"><span class="string">"</span> Install L9 and avoid <span class="selector-tag">a</span> Naming conflict <span class="keyword">if</span> you<span class="string">'ve already installed a</span></span><br><span class="line"><span class="string">" different version somewhere else.</span></span><br><span class="line"><span class="string">" Plugin '</span>ascenator/L9<span class="string">', &#123;'</span>name<span class="string">': '</span>newL9<span class="string">'&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">" All of your Plugins must be added before the following line</span></span><br><span class="line"><span class="string">call vundle#end()            " required</span></span><br><span class="line"><span class="string">filetype plugin indent on    " required</span></span><br><span class="line"><span class="string">" To ignore plugin indent changes, instead use:</span></span><br><span class="line"><span class="string">"filetype plugin on</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">" Brief help</span></span><br><span class="line"><span class="string">" :PluginList       - lists configured plugins</span></span><br><span class="line"><span class="string">" :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate</span></span><br><span class="line"><span class="string">" :PluginSearch foo - searches for foo; append `!` to refresh local cache</span></span><br><span class="line"><span class="string">" :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">" see :h vundle for more details or wiki for FAQ</span></span><br><span class="line"><span class="string">" Put your non-Plugin stuff after this line</span></span><br></pre></td></tr></table></figure><blockquote><p> <strong>注意：如果按这个文件配置，我在进行安装的时候回报错：</strong><br> 提示说  Plugin ‘file:///home/gmarik/path/to/plugin’   找不到，文档中说：git repos on your local machine (i.e. when working on your own plugin)  意思是这个安装本地插件的一个目录，我这没有本地插件，所以我就把这句注释掉了。</p></blockquote><p>4、  打开vim ，安装默认插件：</p><blockquote><p>只在终端键入 vim，后面什么都不加<br>    sudo  vim    –sudo临时提高权限，如果不加sudo，可能会遇到权限不够。<br>   然后键入下面的命令<br>    :PluginInstall<br>   之后等待安装完成，[ :q ] 来退出即可</p></blockquote><p> 安装成功如下图所示：<br> <img src="安装语句.png" alt="Ubuntu"></p><h3 id="安装2个常用插件"><a href="#安装2个常用插件" class="headerlink" title="安装2个常用插件"></a>安装2个常用插件</h3><p>1、  tagbar</p><p>这个插件可以浏览当前文件的标签，如果想更深的了解，GitHub地址为:   <a href="https://github.com/majutsushi/tagbar" target="_blank" rel="noopener">https://github.com/majutsushi/tagbar</a><br>效果图如下：<br><img src="vim-tagbar.png" alt="Ubuntu"></p><ul><li>该插件安装之前需要先安装 ctags</li></ul><blockquote><p>  sudo apt-get install ctags</p></blockquote><ul><li>添加插件和其他配置信息到   ~/.vimrc 中</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">进入 ~/.vimrc</span><br><span class="line"></span><br><span class="line"># 添加以下  tagbar  插件</span><br><span class="line">Plugin <span class="string">'majutsushi/tagbar'</span></span><br><span class="line"></span><br><span class="line"># 配置 tagbar 插件</span><br><span class="line">let g:tagbar_ctags_bin=<span class="string">'ctags'</span>     <span class="string">"ctags 程序的路径</span></span><br><span class="line"><span class="string">let g:tagbar_width=30                   "</span>窗口宽度设置为 <span class="number">30</span></span><br><span class="line">let g:tagbar_left=<span class="number">1</span>                         <span class="string">"设置在 vim 左边显示</span></span><br><span class="line"><span class="string">let g:tagbar_map_openfold = "</span>zv<span class="string">"   "</span>按 zv 组合键打开标签，默认 zc 关闭标签</span><br><span class="line"></span><br><span class="line"><span class="string">"如果是 C 语言的程序的话，tagbar 自动开启</span></span><br><span class="line"><span class="string">autocmd BufReadPost *.cpp,*.c,*.h,*.hpp,*.cc,*.cxx call tagbar#autoopen() </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>我设置 F2 为打开或者关闭的快捷键，根据你的习惯更改</span><br><span class="line">nnoremap &lt;silent&gt; &lt;F2&gt; :TagbarToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure><ul><li>然后通过命令进行安装，语句和安装Vundle 第4步相同</li></ul><p>2、  安装 vim-airline 插件<br>    这个插件没有很大的实用性，但能增加逼格，增加vim的有趣性。<br>    <strong>第一步，我们先把下面的需要配置的文件添加到 ~/.vimrc 中</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" ------------------------安装 vim-airline------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set laststatus=2   "</span> 永远显示状态栏</span><br><span class="line">set t_Co=<span class="number">256</span>       <span class="string">" 在windows中用xshell连接打开vim可以显示色彩</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>Vim 在与屏幕/键盘交互时使用的编码(取决于实际的终端的设定)        </span><br><span class="line">:set encoding=utf-<span class="number">8</span></span><br><span class="line">:set langmenu=zh_CN.UTF-<span class="number">8</span></span><br><span class="line">:set fileencodings=utf-<span class="number">8</span></span><br><span class="line">:set fileencoding=utf-<span class="number">8</span></span><br><span class="line">:set termencoding=utf-<span class="number">8</span></span><br><span class="line"></span><br><span class="line">Plugin <span class="string">'vim-airline'</span>    </span><br><span class="line">let g:airline_theme=<span class="string">"molokai"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"这个是安装字体后 必须设置此项"</span> </span><br><span class="line">let g:airline_powerline_fonts = <span class="number">1</span>  </span><br><span class="line"><span class="string">"打开tabline功能,方便查看Buffer和切换,省去了minibufexpl插件</span></span><br><span class="line"><span class="string"> let g:airline#extensions#tabline#enabled = 1</span></span><br><span class="line"><span class="string"> let g:airline#extensions#tabline#buffer_nr_show = 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>设置切换Buffer快捷键<span class="string">"</span></span><br><span class="line"><span class="string">nnoremap &lt;F4&gt; :bn&lt;CR&gt;</span></span><br><span class="line"><span class="string">"</span> 关闭状态显示空白符号计数</span><br><span class="line"> let g:airline#extensions#whitespace<span class="selector-id">#enabled</span> = <span class="number">0</span></span><br><span class="line"> let g:airline#extensions#whitespace<span class="selector-id">#symbol</span> = <span class="string">'!'</span></span><br><span class="line"></span><br><span class="line"> <span class="string">" 设置consolas字体"</span>前面已经设置过</span><br><span class="line"> <span class="string">"set guifont=Consolas\ for\ Powerline\ FixedD:h11</span></span><br><span class="line"><span class="string"> if !exists('g:airline_symbols')</span></span><br><span class="line"><span class="string">let g:airline_symbols = &#123;&#125;</span></span><br><span class="line"><span class="string"> endif</span></span><br><span class="line"><span class="string"> "</span> old vim-powerline symbols</span><br><span class="line"> let g:airline_left_sep = <span class="string">'⮀'</span></span><br><span class="line"> let g:airline_left_alt_sep = <span class="string">'⮁'</span></span><br><span class="line"> let g:airline_right_sep = <span class="string">'⮂'</span></span><br><span class="line"> let g:airline_right_alt_sep = <span class="string">'⮃'</span></span><br><span class="line"> let g:airline_symbols<span class="selector-class">.branch</span> = <span class="string">'⭠'</span></span><br><span class="line"> let g:airline_symbols<span class="selector-class">.readonly</span> = <span class="string">'⭤'</span></span><br></pre></td></tr></table></figure><p><strong>第二步：要安装字体，如果没有安装字体的话，vim-airline的效果就没法正确的显示</strong></p><p>字体安装GitHub地址：<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">https://github.com/powerline/fonts</a></p><p>在终端上一步步输入下面的内容即可：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># clone</span><br><span class="line">git clone https:<span class="comment">//github.com/powerline/fonts.git --depth=1</span></span><br><span class="line"># install</span><br><span class="line">cd fonts</span><br><span class="line">./install.sh</span><br><span class="line"># clean-up a bit</span><br><span class="line">cd ..</span><br><span class="line">rm -rf fonts</span><br></pre></td></tr></table></figure><p>第三步：继续执行安装Vundle的第四步即可</p><p>效果图如下：<br> <img src="字体.png" alt="Ubuntu"></p><blockquote><p> 注意：在安装的时候，如果遇到权限不够，使用sudo vim 临时提高权限<br> 使用vim时遇到的问题： 如何用vim命令把编辑文件的几行内容拷贝到一个新文件 — 如把58行到79行拷贝到~/test.txt文件可以使用下面的命令&gt;&gt; :58,79w!~/.test.txt</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;我在学习Linux这段时间里，使用vim编程，为了提高自己的逼格，也为了提高自己的效率，就尝试着安装了2个插件。感觉逼格高了
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux，vim，Vundle" scheme="http://yoursite.com/tags/Linux%EF%BC%8Cvim%EF%BC%8CVundle/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解JVM】总结</title>
    <link href="http://yoursite.com/2017/10/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/10/20/深入理解JVM总结/</id>
    <published>2017-10-20T02:33:00.000Z</published>
    <updated>2017-12-05T06:50:42.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过三周的时间我把<strong>周志明</strong>的【深入理解java虚拟机】看完了，对我而言我感觉只是看到一些皮毛，以上的文章都是基于这本书来写的，基本上能理解的都写了上去，我也参考了许多大V的博客，下面我把主要参考博客链接发下下面，如果觉得我写的一般般，可以参考他们的，谢谢！</p><blockquote><p> 兰亭风雨：<a href="http://my.csdn.net/mmc_maodun" target="_blank" rel="noopener">http://my.csdn.net/mmc_maodun</a><br> ChangWen的博客： <a href="http://blog.csdn.net/oChangWen" target="_blank" rel="noopener">http://blog.csdn.net/oChangWen</a><br> 生命壹号：<a href="http://www.cnblogs.com/smyhvae/category/587723.html" target="_blank" rel="noopener">http://www.cnblogs.com/smyhvae/category/587723.html</a></p></blockquote><p>生命壹号对于JVM的总结：<br><a href="http://www.cnblogs.com/smyhvae/p/4810168.html" target="_blank" rel="noopener">http://www.cnblogs.com/smyhvae/p/4810168.html</a></p><p>以下是我的总结：通过XMind见到总结了一下，希望对你有用：<br><img src="JVM常见问题总结.png" alt="总结"></p><blockquote><p>一个菜鸟到一个大神，需要经历许多许多，但是只要梦想在，就要继续前进，因为有很多人需要你照顾。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;经过三周的时间我把&lt;strong&gt;周志明&lt;/strong&gt;的【深入理解java虚拟机】看完了，对我而言我感觉只是看到一些皮毛，以上的文章都是
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM，总结" scheme="http://yoursite.com/tags/JVM%EF%BC%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【深入理解JVM】之七：Javac编译与JIT编译</title>
    <link href="http://yoursite.com/2017/10/15/Javac%E7%BC%96%E8%AF%91%E4%B8%8EJIT%E7%BC%96%E8%AF%91/"/>
    <id>http://yoursite.com/2017/10/15/Javac编译与JIT编译/</id>
    <published>2017-10-15T02:33:00.000Z</published>
    <updated>2017-12-05T06:51:06.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>本文章参考周志明的【深入理解Java虚拟机】<br>代码编译的结果从本地机器码转变成字节码，是存储格式发展的一小步，却是编译语言发展的一大步。</p></blockquote><hr><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java虚拟机的执行引擎在执行java代码的时候都有解释执行（通过解释器执行）和编译执行（通过编译器产生本地代码执行）这两种选择。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不论是解释还是编译，也不论是物理机还是虚拟机，大部分的程序代码从开始编译到最终转化成物理机的目标代码或虚拟机能执行的指令集之前，都会按照如下图所示的各个步骤进行：<br><img src="编译过程.png" alt="JIT"></p><blockquote><p>其中绿色的模块可以选择性实现。很容易看出，上图中间的那条分支是解释执行的过程（即一条字节码一条字节码地解释执行，如JavaScript），而下面的那条分支就是传统编译原理中从源代码到目标机器代码的生成过程。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今，基于物理机、虚拟机等的语言，大多都遵循这种基于现代经典编译原理的思路，在执行前先对程序源码进行词法解析和语法解析处理，把源码转化为抽象语法树。<strong>对于一门具体语言的实现来说，词法和语法分析乃至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言。也可以把抽象语法树或指令流之前的步骤实现一个半独立的编译器，这类代表是Java语言。又或者可以把这些步骤和执行引擎全部集中在一起实现，如大多数的JavaScript执行器。</strong></p><h2 id="Javac编译"><a href="#Javac编译" class="headerlink" title="Javac编译"></a>Javac编译</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java中提到“编译”，<strong>自然很容易想到Javac编译器将<em>.java文件编译成为</em>.class文件的过程，这里的Javac编译器称为前端编译器</strong>，其他的前端编译器还有诸如Eclipse JDT中的增量式编译器ECJ等。<strong>相对应的还有后端编译器，它在程序运行期间将字节码转变成机器码（现在的Java程序在运行时基本都是解释执行加编译执行）</strong>，如HotSpot虚拟机自带的JIT（Just In Time Compiler）编译器（分Client端和Server端）。另外，<strong>有时候还有可能会碰到静态提前编译器（AOT，Ahead Of Time Compiler）直接把*.java文件编译成本地机器代码</strong>，如GCJ、Excelsior JET等，这类编译器我们应该比较少遇到。<br>下面简要说下Javac编译（前端编译）的过程：</p><h3 id="词法、语法分析"><a href="#词法、语法分析" class="headerlink" title="词法、语法分析"></a>词法、语法分析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;词法分析是将源代码的字符流转变为标记（Token）集合。单个字符是程序编写过程中的的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符等都可以成为标记，比如整型标志int由三个字符构成，但是它只是一个标记，不可拆分。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语法分析是根据Token序列来构造抽象语法树的过程。抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，如bao、类型、修饰符、运算符等。经过这个步骤后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上。</p><h3 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成了语法分析和词法分析之后，下一步就是填充符号表的过程。符号表是由一组符号地址和符号信息构成的表格。符号表中所登记的信息在编译的不同阶段都要用到，在语义分析（后面的步骤）中，符号表所登记的内容将用于语义检查和产生中间代码，在目标代码生成阶段，党对符号名进行地址分配时，符号表是地址分配的依据。</p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是读结构上正确的源程序进行上下文有关性质的审查。语义分析过程分为标注检查和数据及控制流分析两个步骤：</p><ul><li>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量和赋值之间的数据类型是否匹配等。</li><li>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题</li></ul><h3 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字节码生成是Javac编译过程的最后一个阶段。字节码生成阶段不仅仅是把前面各个步骤所生成的信息转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。 实例构造器<init>（）方法和类构造器<clinit>（）方法就是在这个阶段添加到语法树之中的（这里的实例构造器并不是指默认的构造函数，而是指我们自己重载的构造函数，如果用户代码中没有提供任何构造函数，那编译器会自动添加一个没有参数、访问权限与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成了）。</clinit></init></p><hr><h2 id="JIT编译"><a href="#JIT编译" class="headerlink" title="JIT编译"></a>JIT编译</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java程序最初是仅仅通过解释器解释执行的，即对字节码逐条解释执行，这种方式的执行速度相对会比较慢，尤其当某个方法或代码块运行的特别频繁时，这种方式的执行效率就显得很低。于是后来在虚拟机中引入了<strong>JIT编译器</strong>（即时编译器），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是JIT编译器。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在主流的商用虚拟机（如Sun HotSpot、IBM J9）中几乎都同时包含解释器和编译器（三大商用虚拟机之一的JRockit是个例外，它内部没有解释器，因此会有启动相应时间长之类的缺点，但它主要是面向服务端的应用，这类应用一般不会重点关注启动时间）。</p><blockquote><p><strong>二者各有优势：</strong><br> <strong>当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行；当程序运行后，随着时间的推移，编译器逐渐会返回作用，把越来越多的代码编译成本地代码后，可以获取更高的执行效率。解释执行可以节约内存，而编译执行可以提升效率。</strong></p></blockquote><p>同时解释器还可以作为编译器激进优化时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类后类型继承结构出现变化，出现“罕见陷阱”时可以通过逆优化退回到解释状态继续执行（部分没有解释器的虚拟机中也会采用不进行激进优化的C1编译器-（在虚拟机中习惯将Client compiler称为C1，将Server Compiler称为C2）担任“逃生门”的角色），因此，在整个虚拟机执行机构中，解释器与编译器经常配合工作，如下图：<br><img src="解释器与编译器的交互.png" alt="JIT"></p><p>  HotSpot虚拟机中内置了两个JIT编译器：Client Complier和Server Complier，分别用在客户端和服务端，目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。<br>无论采用的编译器hiClient Compiler还是Server Compiler，解释器与编译器搭配使用的方式在虚拟机中称为“混合模式”（Mixed Mode）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启用分层编译的策略（1.7默认开启），分层编译根据编译器编译，优化的规模与耗时，划分出不同的编译层次，其中包括：</p><ul><li>第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译</li><li>第1层，也成C1编译，将字节码编译为本地代码，进行简单，可靠的优化，如有必要将加入性能监控的逻辑。</li><li>第2层（或2层以上），也成C2编译，也是将字节码编译成本地代码，但是会启用一些耗时较长的优化甚至会根据性能监控信息进行一些不可靠的激进优化。</li></ul><h3 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h3><p><strong>运行过程中会被即时编译器编译的“热点代码”有两类：</strong></p><ul><li>被多次调用的方法。</li><li>被多次调用的循环体。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 两种情况，编译器都是以整个方法作为编译对象，这种编译也是虚拟机中标准的编译方式。要知道一段代码或方法是不是热点代码，是不是需要触发即时编译，需要进行Hot Spot Detection（热点探测）。<strong>目前主要的热点 判定方式有以下两种：</strong></p><ul><li><strong>基于采样的热点探测</strong>：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li><li><p><strong>基于计数器的热点探测</strong>：采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。</p><p><strong>在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。</strong></p><p><strong>方法调用计数器用来统计方法调用的次数</strong>，在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数。。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，<strong>按这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减，而这段时间就称为此方法统计的半衰周期。</strong></p></li></ul><p>  <strong>回边计数器用于统计一个方法中循环体代码执行的次数</strong>（准确地说，应该是回边的次数，因为并非所有的循环都是回边），在字节码中遇到控制流向后跳转的指令就称为“回边”<br><strong>在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。</strong>   触发了JIT编译后，在默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成为止（编译工作在后台线程中进行）。当编译工作完成后，下一次调用该方法或代码时，就会使用已编译的版本。</p><hr><p>方法调用计数器触发即时编译的流程如下图：<br><img src="方法调用计数器触发即时编译.png" alt="JIT"></p><p>回边计数器触发即时编译的流程和方法调用计数器流程基本相同，这里不再累述。</p><hr><p><strong>这个世界不会亏欠每一个在孤独中重生的人。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;本文章参考周志明的【深入理解Java虚拟机】&lt;br&gt;代码编译的结果从本地机器码转变成字节码，是存储格式发展的一小步
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="http://yoursite.com/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM，类加载" scheme="http://yoursite.com/tags/JVM%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
</feed>

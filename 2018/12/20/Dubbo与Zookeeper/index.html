<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="true" />




  <meta name="baidu-site-verification" content="true" />






  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Dubbo，Zookeeper，分布式," />





  <link rel="alternate" href="/atom.xml" title="Foutin" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="概述目前进入一家，做仓库存储的公司，公司使用的技术也都是现在使用比较多的。以下只是个人记录，不做任何商业用途。 Dubbo关于Dubbo，网上的资料很多，我也都看了很多，林林丛丛的都是对Dubbo技术的介绍，Dubbo用起来很简单，基本上就是配置配置xml文件。这里就不在介绍Dubbo怎么使用了。 我对Dubbo主要的疑虑主要有以下几点：   RPC原理是什么? 为什么Dubbo可以达到调用远程服">
<meta name="keywords" content="Dubbo，Zookeeper，分布式">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo与Zookeeper">
<meta property="og:url" content="http://yoursite.com/2018/12/20/Dubbo与Zookeeper/index.html">
<meta property="og:site_name" content="Foutin">
<meta property="og:description" content="概述目前进入一家，做仓库存储的公司，公司使用的技术也都是现在使用比较多的。以下只是个人记录，不做任何商业用途。 Dubbo关于Dubbo，网上的资料很多，我也都看了很多，林林丛丛的都是对Dubbo技术的介绍，Dubbo用起来很简单，基本上就是配置配置xml文件。这里就不在介绍Dubbo怎么使用了。 我对Dubbo主要的疑虑主要有以下几点：   RPC原理是什么? 为什么Dubbo可以达到调用远程服">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2018/12/20/Dubbo与Zookeeper/zk2.jpg">
<meta property="og:image" content="http://yoursite.com/2018/12/20/Dubbo与Zookeeper/zk3.jpg">
<meta property="og:image" content="http://yoursite.com/2018/12/20/Dubbo与Zookeeper/zk1.jpg">
<meta property="og:image" content="http://yoursite.com/2018/12/20/Dubbo与Zookeeper/strategy流程图.jpg">
<meta property="og:updated_time" content="2019-01-17T08:21:12.487Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dubbo与Zookeeper">
<meta name="twitter:description" content="概述目前进入一家，做仓库存储的公司，公司使用的技术也都是现在使用比较多的。以下只是个人记录，不做任何商业用途。 Dubbo关于Dubbo，网上的资料很多，我也都看了很多，林林丛丛的都是对Dubbo技术的介绍，Dubbo用起来很简单，基本上就是配置配置xml文件。这里就不在介绍Dubbo怎么使用了。 我对Dubbo主要的疑虑主要有以下几点：   RPC原理是什么? 为什么Dubbo可以达到调用远程服">
<meta name="twitter:image" content="http://yoursite.com/2018/12/20/Dubbo与Zookeeper/zk2.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '5a8e9aeb6aad13d9f3471d44095328f5',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/12/20/Dubbo与Zookeeper/"/>





  <title> Dubbo与Zookeeper | Foutin </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Foutin</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/20/Dubbo与Zookeeper/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Foutlook">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/head.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Foutin">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Foutin" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Dubbo与Zookeeper
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-20T09:00:00+08:00">
                2018-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式，Dubbo，Zookeeper/" itemprop="url" rel="index">
                    <span itemprop="name">分布式，Dubbo，Zookeeper</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/12/20/Dubbo与Zookeeper/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/12/20/Dubbo与Zookeeper/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">本文总阅读量
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
		  
		  
		  <!--以下部分为: 字数统计、阅读时长插入代码-->
		
        <span class="post-time">
			&nbsp; | &nbsp;
           <span class="post-meta-item-icon">
             <i class="fa fa-calendar-o"></i>
           </span>
           <span class="post-meta-item-text">字数统计:</span>
           <span class="post-count">9,204(字)</span>
           
        </span>
	  
		<span class="post-time">
			&nbsp; | &nbsp;
           <span class="post-meta-item-icon">
             <i class="fa fa-calendar-o"></i>
           </span>
           <span class="post-meta-item-text">阅读时长:</span>
           <span class="post-count">35(分)</span>
           
        </span>
		<!-- 以上部分为: 字数统计、阅读时长插入代码 -->

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>目前进入一家，做仓库存储的公司，公司使用的技术也都是现在使用比较多的。以下只是个人记录，不做任何商业用途。</p>
<h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><p>关于Dubbo，网上的资料很多，我也都看了很多，林林丛丛的都是对Dubbo技术的介绍，Dubbo用起来很简单，基本上就是配置配置xml文件。这里就不在介绍Dubbo怎么使用了。</p>
<p>我对Dubbo主要的疑虑主要有以下几点：</p>
<blockquote>
<ol>
<li>RPC原理是什么?</li>
<li>为什么Dubbo可以达到调用远程服务的目的？</li>
<li>Dubbo为什么能够实现软负载均衡，服务注册与发现的？</li>
</ol>
</blockquote>
<p>不过想要解决这些疑问，需要研究源码。因为对Dubbo涉及到的部分技术还有很多不是特别懂，暂时没有看源码。这部分技术分享暂时不做，等我看完源码再好好分享。</p>
<p><a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html" target="_blank" rel="noopener">Dubbo官方文档</a></p>
<h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h2 id="Zookeeper的简介"><a href="#Zookeeper的简介" class="headerlink" title="Zookeeper的简介"></a>Zookeeper的简介</h2><p>ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode。每个ZNode都可以通过其路径唯一标识，<strong>在每个ZNode上可存储少量数据(默认是1M</strong>, 可以通过配置修改,通常不建议在ZNode上存储大量的数据)。另外，每个ZNode上还存储了其Acl信息，这里需要注意，虽说ZNode的树形结构跟Unix文件系统很类似，但是其Acl与Unix文件系统是完全不同的，每个ZNode的Acl是独立的，子结点不会继承父结点的。</p>
<p><img src="zk2.jpg" alt="ZK"></p>
<p>ZNode根据其本身的特性，可以分为下面两类：</p>
<blockquote>
<ul>
<li>Regular ZNode: 常规型ZNode, 用户需要显式的创建、删除</li>
<li>Ephemeral ZNode: 临时型ZNode,用户创建它之后，可以显式的删除，也可以在创建它的Session结束后，由ZooKeeper Server自动删除</li>
</ul>
</blockquote>
<p><strong>Zookeeper这种数据结构有如下这些特点：</strong></p>
<blockquote>
<ul>
<li><p>1）<strong>每个子目录项如NameService都被称作为znode</strong>，这个znode是被它所在的路径唯一标识，如Server1这个znode的标识为/NameService/Server1。</p>
</li>
<li><p>2）<strong>znode可以有子节点目录</strong>，并且每个znode可以存储数据，注意EPHEMERAL（临时的）类型的目录节点不能有子节点目录。ZNode一个Sequential的特性，如果创建的时候指定的话，该ZNode的名字后面会自动Append一个不断增加的SequenceNo。</p>
</li>
<li><p>3）<strong>znode是有版本的</strong>（version），每个znode中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据，version号自动增加。</p>
</li>
<li><p>4）<strong>znode可以是临时节点（EPHEMERAL），可以是持久节点（PERSISTENT）</strong>。如果创建的是临时节点，一旦创建这个EPHEMERALznode的客户端与服务器失去联系，这个znode也将自动删除，Zookeeper的客户端和服务器通信采用长连接方式，每个客户端和服务器通过心跳来保持连接，这个连接状态称为session，如果znode是临时节点，这个session失效，znode也就删除了。</p>
</li>
<li><p>5）<strong>znode的目录名可以自动编号</strong>，如App1已经存在，再创建的话，将会自动命名为App2。</p>
</li>
<li><p>6）<strong>znode可以被监控</strong>，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端，这个是Zookeeper的核心特性，Zookeeper的很多功能都是基于这个特性实现的。Watcher ZooKeeper支持一种Watch操作，Client可以在某个ZNode上设置一个Watcher，来Watch该ZNode上的变化。如果该ZNode上有相应的变化，就会触发这个Watcher，把相应的事件通知给设置Watcher的Client。需要注意的是，ZooKeeper中的Watcher是一次性的，即触发一次就会被取消，如果想继续Watch的话，需要客户端重新设置Watcher。这个跟epoll里的oneshot模式有点类似。</p>
</li>
<li><p>7）<strong>ZXID</strong>：每次对Zookeeper的状态的改变都会产生一个zxid（ZooKeeper Transaction Id），zxid是全局有序的，如果zxid1小于zxid2，则zxid1在zxid2之前发生。</p>
</li>
<li><p>8)<strong>Session</strong>: Client与ZooKeeper之间的通信，需要创建一个Session，这个Session会有一个超时时间。因为ZooKeeper集群会把Client的Session信息持久化，所以在Session没超时之前，Client与ZooKeeper Server的连接可以在各个ZooKeeper Server之间透明地移动。在实际的应用中，如果Client与Server之间的通信足够频繁，Session的维护就不需要其它额外的消息了。否则，ZooKeeper Client会每t/3 ms发一次心跳给Server，如果Client 2t/3 ms没收到来自Server的心跳回应，就会换到一个新的ZooKeeper Server上。这里t是用户配置的Session的超时时间。</p>
</li>
</ul>
</blockquote>
<h2 id="Zookeeper的结构"><a href="#Zookeeper的结构" class="headerlink" title="Zookeeper的结构"></a>Zookeeper的结构</h2><p>如下图：</p>
<p><img src="zk3.jpg" alt="ZK"></p>
<p><img src="zk1.jpg" alt="ZK"></p>
<p>client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。</p>
<h3 id="ZooKeeper-Watch"><a href="#ZooKeeper-Watch" class="headerlink" title="ZooKeeper Watch"></a>ZooKeeper Watch</h3><p><strong>Zookeeper watch是一种监听通知机制</strong>。Zookeeper所有的读操作getData(), getChildren()和 exists()都可以设置监视(watch)，监视事件可以理解为一次性的触发器，官方定义如下：<code>a watch event is one-time trigger, sent to the client that set the watch, whichoccurs when the data for which the watch was set changes。</code></p>
<p><strong>Watch的三个关键点：</strong></p>
<h4 id="（一次性触发）One-time-trigger"><a href="#（一次性触发）One-time-trigger" class="headerlink" title="（一次性触发）One-time trigger"></a>（一次性触发）One-time trigger</h4><p>当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了getData(“/znode1”, true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件<strong>，而如果 /znode1 再一次发生了变化，除非客户端再次对/znode1 设置监视，否则客户端不会收到事件通知。</strong></p>
<h4 id="（发送至客户端）Sent-to-the-client"><a href="#（发送至客户端）Sent-to-the-client" class="headerlink" title="（发送至客户端）Sent to the client"></a>（发送至客户端）Sent to the client</h4><p><strong>Zookeeper客户端和服务端是通过 socket 进行通信的</strong>，由于网络存在故障， 所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了顺序保证(ordering guarantee)：<strong>即客户端只有首先看到了监视事件后，才会感知到它所设置监视的znode发生了变化</strong>。网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。</p>
<h4 id="（被设置-watch-的数据）The-data-for-which-the-watch-was-set"><a href="#（被设置-watch-的数据）The-data-for-which-the-watch-was-set" class="headerlink" title="（被设置 watch 的数据）The data for which the watch was set"></a>（被设置 watch 的数据）The data for which the watch was set</h4><p><strong>这意味着znode节点本身具有不同的改变方式。你也可以想象 Zookeeper 维护了两条监视链表</strong>：<strong>数据监视和子节点监视</strong>(data watches and child watches) <code>getData() 和exists()</code>设置数据监视，<code>getChildren()</code>设置子节点监视。或者你也可以想象 Zookeeper 设置的不同监视返回不同的数据，<code>getData() 和 exists()</code> 返回znode节点的相关信息，而<code>getChildren()</code> 返回子节点列表。因此，<code>setData()</code> 会触发设置在某一节点上所设置的数据监视（假定数据设置成功），而一次成功的<code>create()</code> 操作则会出发当前节点上所设置的数据监视以及父节点的子节点监视。一次成功的 delete操作将会触发当前节点的数据监视和子节点监视事件，同时也会触发该节点父节点的child watch。</p>
<p><strong>Zookeeper 中的监视是轻量级的，因此容易设置、维护和分发</strong>。当客户端与 Zookeeper 服务器失去联系时，客户端并不会收到监视事件的通知，只有当客户端重新连接后，若在必要的情况下，以前注册的监视会重新被注册并触发，对于开发人员来说这通常是透明的。只有一种情况会导致监视事件的丢失，<strong>即：通过exists()设置了某个znode节点的监视，但是如果某个客户端在此znode节点被创建和删除的时间间隔内与zookeeper服务器失去了联系，该客户端即使稍后重新连接 zookeeper服务器后也得不到事件通知。</strong></p>
<h2 id="ZooKeeper的工作原理"><a href="#ZooKeeper的工作原理" class="headerlink" title="ZooKeeper的工作原理"></a>ZooKeeper的工作原理</h2><p>在zookeeper的集群中，各个节点共有下面3种角色和4种状态：</p>
<blockquote>
<ul>
<li>角色：leader,follower,observer</li>
<li>状态：leading,following,observing,looking</li>
</ul>
</blockquote>
<p><strong>Zookeeper的核心是原子广播</strong>，这个机制保证了各个<code>Server</code>之间的同步。实现这个机制的协议叫做<code>Zab协议（ZooKeeper Atomic Broadcast protocol）</code>。Zab协议有<code>两种</code>模式，它们分别是<code>恢复模式（Recovery选主）和广播模式（Broadcast同步）</code>。当服务启动或者在领导者崩溃后，<strong>Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了</strong>。状态同步保证了leader和Server具有相同的系统状态。</p>
<p>为了<code>保证事务的顺序一致性</code>，zookeeper采用了递增的事务<code>id号（zxid）</code>来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</p>
<p>每个Server在工作过程中有4种状态：</p>
<blockquote>
<ul>
<li>LOOKING：当前Server不知道leader是谁，正在搜寻。</li>
<li>LEADING：当前Server即为选举出来的leader。</li>
<li>FOLLOWING：leader已经选举出来，当前Server与之同步。</li>
<li>OBSERVING：observer的行为在大多数情况下与follower完全一致，但是他们不参加选举和投票，而仅仅接受(observing)选举和投票的结果。</li>
</ul>
</blockquote>
<h2 id="Zookeeper的典型应用场景"><a href="#Zookeeper的典型应用场景" class="headerlink" title="Zookeeper的典型应用场景"></a>Zookeeper的典型应用场景</h2><p>参考：<a href="http://jm.taobao.org/2011/10/08/1232/" target="_blank" rel="noopener">阿里中间件博客</a></p>
<h3 id="数据发布与订阅（配置中心）"><a href="#数据发布与订阅（配置中心）" class="headerlink" title="数据发布与订阅（配置中心）"></a>数据发布与订阅（配置中心）</h3><p>发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到ZK节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，服务式服务框架的服务地址列表等就非常适合使用。</p>
<blockquote>
<p><strong>应用中用到的一些配置信息放到ZK上进行集中管理。这类场景通常是这样</strong>：应用在启动的时候会主动来获取一次配置，同时，在节点上注册一个Watcher，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。 分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在ZK的一些指定节点，供各个客户端订阅使用。</p>
<p><strong>分布式日志收集系统</strong>。这个系统的核心工作是收集分布在不同机器的日志。收集器通常是按照应用来分配收集任务单元，因此需要在ZK上创建一个以应用名作为path的节点P，并将这个应用的所有机器ip，以子节点的形式注册到节点P上，这样一来就能够实现机器变动的时候，能够实时通知到收集器调整任务分配。 系统中有些信息需要动态获取，并且还会存在人工手动去修改这个信息的发问。通常是暴露出接口，例如JMX接口，来获取一些运行时的信息。引入ZK之后，就不用自己实现一套方案了，只要将这些信息存放到指定的ZK节点上即可。 </p>
<p>==注意：在上面提到的应用场景中，有个默认前提是：数据量很小，但是数据更新可能会比较快的场景。==</p>
</blockquote>
<hr>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>这里说的负载均衡是指软负载均衡。在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，其中比较典型的是消息中间件中的生产者，消费者负载均衡。<br>消息中间件中发布者和订阅者的负载均衡，linkedin开源的KafkaMQ和阿里开源的metaq都是通过zookeeper来做到生产者、消费者的负载均衡。这里以metaq为例如讲下：</p>
<blockquote>
<p><strong>生产者负载均衡</strong>：metaq发送消息的时候，生产者在发送消息的时候必须选择一台broker上的一个分区来发送消息，因此metaq在运行过程中，会把所有broker和对应的分区信息全部注册到ZK指定节点上，默认的策略是一个依次轮询的过程，生产者在通过ZK获取分区列表之后，会按照brokerId和partition的顺序排列组织成一个有序的分区列表，发送的时候按照从头到尾循环往复的方式选择一个分区来发送消息。 </p>
<p><strong>消费负载均衡：</strong> 在消费过程中，一个消费者会消费一个或多个分区中的消息，但是一个分区只会由一个消费者来消费。MetaQ的消费策略是：</p>
<ul>
<li>每个分区针对同一个group只挂载一个消费者。 </li>
<li>如果同一个group的消费者数目大于分区数目，则多出来的消费者将不参与消费。</li>
<li>如果同一个group的消费者数目小于分区数目，则有部分消费者需要额外承担消费任务。</li>
<li>在某个消费者故障或者重启等情况下，其他消费者会感知到这一变化（通过 zookeeper watch消费者列表），然后重新进行负载均衡，保证所有的分区都有消费者进行消费。</li>
</ul>
</blockquote>
<hr>
<h3 id="命名服务-Naming-Service"><a href="#命名服务-Naming-Service" class="headerlink" title="命名服务(Naming Service)"></a>命名服务(Naming Service)</h3><p><strong>命名服务也是分布式系统中比较常见的一类场景</strong>。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等等——这些我们都可以统称他们为名字（Name）。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建节点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。</p>
<blockquote>
<p>阿里巴巴集团开源的分布式服务框架Dubbo中使用ZooKeeper来作为其命名服务，维护全局的服务地址列表，点击这里查看Dubbo开源项目。在Dubbo实现中：</p>
<ul>
<li><p>服务提供者在启动的时候，向ZK上的指定节点/dubbo/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的发布。</p>
</li>
<li><p>服务消费者启动的时候，订阅/dubbo/${serviceName}/providers目录下的提供者URL地址， 并向/dubbo/${serviceName} /consumers目录下写入自己的URL地址。</p>
</li>
</ul>
<p>==<strong>注意，所有向ZK上注册的地址都是临时节点，这样就能够保证服务提供者和消费者能够自动感应资源的变化。</strong>==</p>
<p>另外，Dubbo还有针对服务粒度的监控，方法是订阅/dubbo/${serviceName}目录下所有提供者和消费者的信息。</p>
</blockquote>
<hr>
<h3 id="分布式通知-协调"><a href="#分布式通知-协调" class="headerlink" title="分布式通知/协调"></a>分布式通知/协调</h3><p>ZooKeeper中特有watcher注册与异步通知机制，能够很好的实现分布式环境下不同系统之间的通知与协调，实现对数据变更的实时处理。使用方法通常是不同系统都对ZK上同一个znode进行注册，监听znode的变化（包括znode本身内容及子节点的），其中一个系统update了znode，那么另一个系统能够收到通知，并作出相应处理</p>
<blockquote>
<ul>
<li><strong>另一种心跳检测机制</strong>：检测系统和被检测系统之间并不直接关联起来，而是通过zk上某个节点关联，大大减少系统耦合。 </li>
<li><strong>另一种系统调度模式</strong>：某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了ZK上某些节点的状态，而ZK就把这些变化通知给他们注册Watcher的客户端，即推送系统，于是，作出相应的推送任务。</li>
<li><strong>另一种工作汇报模式</strong>：一些类似于任务分发系统，子任务启动后，到zk来注册一个临时节点，并且定时将自己的进度进行汇报（将进度写回这个临时节点），这样任务管理者就能够实时知道任务进度。</li>
</ul>
<p>总之，使用zookeeper来进行分布式通知和协调能够大大降低系统之间的耦合</p>
</blockquote>
<hr>
<h3 id="集群管理与Master选举"><a href="#集群管理与Master选举" class="headerlink" title="集群管理与Master选举"></a>集群管理与Master选举</h3><p>集群机器监控：这通常用于那种对集群中机器状态，机器在线率有较高要求的场景，能够快速对集群中机器变化作出响应。这样的场景中，往往有一个监控系统，实时检测集群机器是否存活。过去的做法通常是：监控系统通过某种手段（比如ping）定时检测每个机器，或者每个机器自己定时向监控系统汇报“我还活着”。 这种做法可行，但是存在两个比较明显的问题：</p>
<blockquote>
<ol>
<li>集群中机器有变动的时候，牵连修改的东西比较多。</li>
<li>有一定的延时。</li>
</ol>
<p>利用ZooKeeper有两个特性，就可以实时另一种集群机器存活性监控系统：</p>
<ol>
<li>客户端在节点 x 上注册一个Watcher，那么如果 x?的子节点变化了，会通知该客户端。</li>
<li>创建EPHEMERAL类型的节点，一旦客户端和服务器的会话结束或过期，那么该节点就会消失。</li>
</ol>
<p>例如，监控系统在 /clusterServers 节点上注册一个Watcher，以后每动态加机器，那么就往 /clusterServers 下创建一个 EPHEMERAL类型的节点：/clusterServers/{hostname}. 这样，监控系统就能够实时知道机器的增减情况，至于后续处理就是监控系统的业务了。 Master选举则是zookeeper中最为经典的应用场景了。</p>
<p>在分布式环境中，相同的业务应用分布在不同的机器上，有些业务逻辑（例如一些耗时的计算，网络I/O处理），往往只需要让整个集群中的某一台机器进行执行，其余机器可以共享这个结果，这样可以大大减少重复劳动，提高性能，于是这个master选举便是这种场景下的碰到的主要问题。</p>
<p>利用ZooKeeper的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建 /currentMaster 节点，最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很轻易的在分布式环境中进行集群选取了。</p>
</blockquote>
<p>另外，这种场景演化一下，就是动态Master选举。这就要用到?EPHEMERAL_SEQUENTIAL类型节点的特性了。</p>
<p>上文中提到，所有客户端创建请求，最终只有一个能够创建成功。在这里稍微变化下，就是允许所有请求都能够创建成功，但是得有个创建顺序，于是所有的请求最终在ZK上创建结果的一种可能情况是这样： /currentMaster/{sessionId}-1 ,?/currentMaster/{sessionId}-2 ,?/currentMaster/{sessionId}-3 ….. 每次选取序列号最小的那个机器作为Master，如果这个机器挂了，由于他创建的节点会马上小时，那么之后最小的那个机器就是Master了。</p>
<p>在搜索系统中，如果集群中每个机器都生成一份全量索引，不仅耗时，而且不能保证彼此之间索引数据一致。因此让集群中的Master来进行全量索引的生成，然后同步到集群中其它机器。另外，Master选举的容灾措施是，可以随时进行手动指定master，就是说应用在zk在无法获取master信息时，可以通过比如http方式，向一个地方获取master。 在Hbase中，也是使用ZooKeeper来实现动态HMaster的选举。在Hbase实现中，会在ZK上存储一些ROOT表的地址和HMaster的地址，HRegionServer也会把自己以临时节点（Ephemeral）的方式注册到Zookeeper中，使得HMaster可以随时感知到各个HRegionServer的存活状态，同时，一旦HMaster出现问题，会重新选举出一个HMaster来运行，从而避免了HMaster的单点问题</p>
<hr>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁，这个主要得益于ZooKeeper为我们保证了数据的强一致性。锁服务可以分为两类，一个是保持独占，另一个是控制时序。</p>
<blockquote>
<p><strong>所谓保持独占</strong>，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把zk上的一个znode看作是一把锁，通过create znode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。</p>
<p><strong>控制时序</strong>，就是所有视图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里 /distribute_lock 已经预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode.EPHEMERAL_SEQUENTIAL来指定）。Zk的父节点（/distribute_lock）维持一份sequence,保证子节点创建的时序性，从而也形成了每个客户端的全局时序。</p>
</blockquote>
<hr>
<h3 id="分布式队列"><a href="#分布式队列" class="headerlink" title="分布式队列"></a>分布式队列</h3><p>队列方面，简单地讲有两种，一种是常规的先进先出队列，另一种是要等到队列成员聚齐之后的才统一按序执行。对于第一种先进先出队列，和分布式锁服务中的控制时序场景基本原理一致，这里不再赘述。</p>
<blockquote>
<p><strong>第二种队列其实是在FIFO队列的基础上作了一个增强</strong>。通常可以在 /queue 这个znode下预先建立一个/queue/num 节点，并且赋值为n（或者直接给/queue赋值n），表示队列大小，之后每次有队列成员加入后，就判断下是否已经到达队列大小，决定是否可以开始执行了。这种用法的典型场景是，分布式环境中，一个大任务Task A，需要在很多子任务完成（或条件就绪）情况下才能进行。这个时候，凡是其中一个子任务完成（就绪），那么就去 /taskList 下建立自己的临时时序节点（CreateMode.EPHEMERAL_SEQUENTIAL），当 /taskList 发现自己下面的子节点满足指定个数，就可以进行下一步按序进行处理了。</p>
</blockquote>
<hr>
<h2 id="Zookeeper应用"><a href="#Zookeeper应用" class="headerlink" title="Zookeeper应用"></a>Zookeeper应用</h2><p>近期公司给了我一个简单的任务，就是利用zk 实现当外界的某一个条件改变的时候，通知客户端或者服务端重新获取新的取值。技术上使用zk的分布式通知/协调来实现。</p>
<h3 id="Zookeeper客户端Curator的使用"><a href="#Zookeeper客户端Curator的使用" class="headerlink" title="Zookeeper客户端Curator的使用"></a>Zookeeper客户端Curator的使用</h3><p>Curator是Netflix公司开源的一套zookeeper客户端框架，解决了很多Zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册Watcher和NodeExistsException异常等等。</p>
<p>Curator包含了几个包：</p>
<blockquote>
<ul>
<li>curator-framework：对zookeeper的底层api的一些封装。</li>
<li>curator-client：提供一些客户端的操作，例如重试策略等。</li>
<li>curator-recipes：封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式计数器、分布式Barrier等。</li>
</ul>
</blockquote>
<p>Maven依赖(使用curator的版本：2.12.0，对应Zookeeper的版本为：3.4.x，如果跨版本会有兼容性问题，很有可能导致节点操作失败)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Curator的基本Api"><a href="#Curator的基本Api" class="headerlink" title="Curator的基本Api"></a>Curator的基本Api</h3><h4 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h4><p><strong>1.使用静态工程方法创建客户端</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);</span><br><span class="line">CuratorFramework<span class="built_in"> client </span>= CuratorFrameworkFactory.newClient(</span><br><span class="line">        						connectionInfo,</span><br><span class="line">        						5000,</span><br><span class="line">        						3000,</span><br><span class="line">        						retryPolicy);</span><br></pre></td></tr></table></figure>
<p><strong>newClient静态工厂方法包含四个主要参数：</strong></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>connectionString</td>
<td>服务器列表，格式host1:port1,host2:port2,…</td>
</tr>
<tr>
<td>retryPolicy</td>
<td>重试策略,内建有四种重试策略,也可以自行实现RetryPolicy接口</td>
</tr>
<tr>
<td>sessionTimeoutMs</td>
<td>会话超时时间，单位毫秒，默认60000ms</td>
</tr>
<tr>
<td>connectionTimeoutMs</td>
<td>连接创建超时时间，单位毫秒，默认60000ms</td>
</tr>
</tbody>
</table>
<p><strong>2.使用Fluent风格的Api创建会话</strong></p>
<p>核心参数变为流式设置，一个列子如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);</span><br><span class="line">CuratorFramework<span class="built_in"> client </span>=</span><br><span class="line">CuratorFrameworkFactory.builder()</span><br><span class="line">		.connectString(connectionInfo)</span><br><span class="line">		.sessionTimeoutMs(5000)</span><br><span class="line">		.connectionTimeoutMs(5000)</span><br><span class="line">		.retryPolicy(retryPolicy)</span><br><span class="line">		.build();</span><br></pre></td></tr></table></figure>
<p><strong>3.创建包含隔离命名空间的会话</strong></p>
<p>为了实现不同的Zookeeper业务之间的隔离，需要为每个业务分配一个独立的命名空间（<strong>NameSpace</strong>），即指定一个Zookeeper的根路径（官方术语：为Zookeeper添加“Chroot”特性）。例如（下面的例子）当客户端指定了独立命名空间为“/base”，那么该客户端对Zookeeper上的数据节点的操作都是基于该目录进行的。通过设置Chroot可以将客户端应用与Zookeeper服务端的一棵子树相对应，在多个应用共用一个Zookeeper集群的场景下，这对于实现不同应用之间的相互隔离十分有意义。</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RetryPolicy</span> retryPolicy = <span class="function"><span class="keyword">new</span> <span class="title">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>);</span></span><br><span class="line"><span class="function"><span class="title">CuratorFramework</span> <span class="title">client</span> =</span></span><br><span class="line"><span class="function">		<span class="title">CuratorFrameworkFactory</span>.<span class="title">builder</span>()</span></span><br><span class="line"><span class="function">				.<span class="title">connectString</span>(connectionInfo)</span></span><br><span class="line"><span class="function">				.<span class="title">sessionTimeoutMs</span>(<span class="number">5000</span>)</span></span><br><span class="line"><span class="function">				.<span class="title">connectionTimeoutMs</span>(<span class="number">5000</span>)</span></span><br><span class="line"><span class="function">				.<span class="title">retryPolicy</span>(retryPolicy)</span></span><br><span class="line"><span class="function">				.<span class="title">namespace</span>("base")     <span class="comment">//命名空间</span></span></span><br><span class="line"><span class="function">				.<span class="title">build</span>();</span></span><br></pre></td></tr></table></figure>
<h3 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h3><p>当创建会话成功，得到client的实例然后可以直接调用其 <strong>start( )</strong> 方法：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.start()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="CuratorFramework的方法"><a href="#CuratorFramework的方法" class="headerlink" title="CuratorFramework的方法"></a>CuratorFramework的方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>create()</td>
<td>开始创建操作， 可以调用额外的方法(比如方式mode 或者后台执行background) 并在最后调用forPath()指定要操作的ZNode</td>
</tr>
<tr>
<td>delete()</td>
<td>开始删除操作. 可以调用额外的方法(版本或者后台处理version or background)并在最后调用forPath()指定要操作的ZNode</td>
</tr>
<tr>
<td>checkExists()</td>
<td>开始检查ZNode是否存在的操作. 可以调用额外的方法(监控或者后台处理)并在最后调用forPath()指定要操作的ZNode</td>
</tr>
<tr>
<td>getData()</td>
<td>开始获得ZNode节点数据的操作. 可以调用额外的方法(监控、后台处理或者获取状态watch, background or get stat) 并在最后调用forPath()指定要操作的ZNode</td>
</tr>
<tr>
<td>setData()</td>
<td>开始设置ZNode节点数据的操作. 可以调用额外的方法(版本或者后台处理) 并在最后调用forPath()指定要操作的ZNode</td>
</tr>
<tr>
<td>getChildren()</td>
<td>开始获得ZNode的子节点列表。 以调用额外的方法(监控、后台处理或者获取状态watch, background or get stat) 并在最后调用forPath()指定要操作的ZNode</td>
</tr>
<tr>
<td>inTransaction()</td>
<td>开始是原子ZooKeeper事务. 可以复合create, setData, check, and/or delete 等操作然后调用commit()作为一个原子操作提交</td>
</tr>
</tbody>
</table>
<h3 id="数据节点操作"><a href="#数据节点操作" class="headerlink" title="数据节点操作"></a>数据节点操作</h3><h4 id="创建数据节点"><a href="#创建数据节点" class="headerlink" title="创建数据节点"></a>创建数据节点</h4><p><strong>Zookeeper的节点属性：</strong></p>
<blockquote>
<ul>
<li>PERSISTENT：持久化</li>
<li>PERSISTENT_SEQUENTIAL：持久化并且带序列号</li>
<li>EPHEMERAL：临时</li>
<li>EPHEMERAL_SEQUENTIAL：临时并且带序列号</li>
</ul>
</blockquote>
<p><strong>注意：如果没有设置节点属性，节点创建模式默认为持久化节点，内容默认为空</strong></p>
<p>a.创建一个节点，初始内容为空：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">client</span><span class="selector-class">.create</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>);</span><br></pre></td></tr></table></figure>
<p>b.创建一个节点，附带初始化内容</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">client</span><span class="selector-class">.create</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>,<span class="string">"init"</span>.getBytes());</span><br></pre></td></tr></table></figure>
<p>c.创建一个节点，指定创建模式（临时节点），内容为空</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">client</span><span class="selector-class">.create</span>()<span class="selector-class">.withMode</span>(<span class="selector-tag">CreateMode</span><span class="selector-class">.EPHEMERAL</span>)<span class="selector-class">.forPath</span>("<span class="selector-tag">path</span>");</span><br></pre></td></tr></table></figure>
<p>d.创建一个节点，指定创建模式（临时节点），附带初始化内容</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">client</span><span class="selector-class">.create</span>()<span class="selector-class">.withMode</span>(<span class="selector-tag">CreateMode</span><span class="selector-class">.EPHEMERAL</span>)<span class="selector-class">.forPath</span>("<span class="selector-tag">path</span>","<span class="selector-tag">init</span>"<span class="selector-class">.getBytes</span>());</span><br></pre></td></tr></table></figure>
<p>e.创建一个节点，指定创建模式（临时节点），附带初始化内容，并且自动递归创建父节点</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">client</span><span class="selector-class">.create</span>()</span><br><span class="line">      <span class="selector-class">.creatingParentContainersIfNeeded</span>()</span><br><span class="line">      <span class="selector-class">.withMode</span>(<span class="selector-tag">CreateMode</span><span class="selector-class">.EPHEMERAL</span>)</span><br><span class="line">      <span class="selector-class">.forPath</span>("<span class="selector-tag">path</span>","<span class="selector-tag">init</span>"<span class="selector-class">.getBytes</span>());</span><br></pre></td></tr></table></figure>
<p><strong>这个creatingParentContainersIfNeeded()接口非常有用，因为一般情况开发人员在创建一个子节点必须判断它的父节点是否存在，如果不存在直接创建会抛出NoNodeException，使用creatingParentContainersIfNeeded()之后Curator能够自动递归创建所有所需的父节点。</strong></p>
<h4 id="删除数据节点"><a href="#删除数据节点" class="headerlink" title="删除数据节点"></a>删除数据节点</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.删除一个节点，此方法只能删除叶子节点，否则会抛出异常。</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.delete</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.删除一个节点，并且递归删除其所有的子节点</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.delete</span>()<span class="selector-class">.deletingChildrenIfNeeded</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.删除一个节点，强制指定版本进行删除</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.delete</span>()<span class="selector-class">.withVersion</span>(<span class="number">10086</span>)<span class="selector-class">.forPath</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.删除一个节点，强制保证删除,guaranteed()接口是一个保障措施，只要客户端会话有效，那么Curator会在后台持续进行删除操作，直到删除节点成功。</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.delete</span>()<span class="selector-class">.guaranteed</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.上面的多个流式接口是可以自由组合,例如:</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.delete</span>()<span class="selector-class">.guaranteed</span>()<span class="selector-class">.deletingChildrenIfNeeded</span>()<span class="selector-class">.withVersion</span>(<span class="number">10086</span>)<span class="selector-class">.forPath</span>(<span class="string">"path"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="读取数据节点数据"><a href="#读取数据节点数据" class="headerlink" title="读取数据节点数据"></a>读取数据节点数据</h4><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.读取一个节点的数据内容,注意，此方法返的返回值是byte[ ];</span></span><br><span class="line">client.getData().forPath(<span class="string">"path"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读取一个节点的数据内容，同时获取到该节点的stat</span></span><br><span class="line"><span class="keyword">Stat</span> <span class="keyword">stat</span> = new <span class="keyword">Stat</span>()<span class="comment">;</span></span><br><span class="line">client.getData().storingStatIn(<span class="keyword">stat</span>).forPath(<span class="string">"path"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="更新数据节点数据"><a href="#更新数据节点数据" class="headerlink" title="更新数据节点数据"></a>更新数据节点数据</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.更新一个节点的数据内容,该接口会返回一个Stat实例</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.setData</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>,<span class="string">"data"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.更新一个节点的数据内容，强制指定版本进行更新</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.setData</span>()<span class="selector-class">.withVersion</span>(<span class="number">10086</span>)<span class="selector-class">.forPath</span>(<span class="string">"path"</span>,<span class="string">"data"</span>.getBytes());</span><br></pre></td></tr></table></figure>
<h4 id="检查节点是否存在"><a href="#检查节点是否存在" class="headerlink" title="检查节点是否存在"></a>检查节点是否存在</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法返回一个Stat实例，用于检查ZNode是否存在的操作.</span></span><br><span class="line"><span class="comment">//可以调用额外的方法(监控或者后台处理)并在最后调用forPath()指定要操作的ZNode</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.checkExists</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="获取某个节点的所有子节点路径"><a href="#获取某个节点的所有子节点路径" class="headerlink" title="获取某个节点的所有子节点路径"></a>获取某个节点的所有子节点路径</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法的返回值为List,获得ZNode的子节点Path列表。</span></span><br><span class="line"><span class="comment">//可以调用额外的方法(监控、后台处理或者获取状态watch, background or get stat)</span></span><br><span class="line"><span class="comment">//并在最后调用forPath()指定要操作的父ZNode</span></span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.getChildren</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>CuratorFramework的实例包含inTransaction( )接口方法，调用此方法开启一个ZooKeeper事务. 可以复合create, setData, check, and/or delete 等操作然后调用commit()作为一个原子操作提交。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">client</span><span class="selector-class">.inTransaction</span>()<span class="selector-class">.check</span>()<span class="selector-class">.forPath</span>(<span class="string">"path"</span>)</span><br><span class="line">      <span class="selector-class">.and</span>()</span><br><span class="line">      <span class="selector-class">.create</span>()<span class="selector-class">.withMode</span>(CreateMode.EPHEMERAL)<span class="selector-class">.forPath</span>(<span class="string">"path"</span>,<span class="string">"data"</span>.getBytes())</span><br><span class="line">      <span class="selector-class">.and</span>()</span><br><span class="line">      <span class="selector-class">.setData</span>()<span class="selector-class">.withVersion</span>(<span class="number">10086</span>)<span class="selector-class">.forPath</span>(<span class="string">"path"</span>,<span class="string">"data2"</span>.getBytes())</span><br><span class="line">      <span class="selector-class">.and</span>()</span><br><span class="line">      <span class="selector-class">.commit</span>();</span><br></pre></td></tr></table></figure>
<h4 id="异步接口"><a href="#异步接口" class="headerlink" title="异步接口"></a>异步接口</h4><p>上面提到的创建、删除、更新、读取等方法都是同步的，Curator提供异步接口，引入了<strong>BackgroundCallback</strong>接口用于处理异步接口调用之后服务端返回的结果信息。<strong>BackgroundCallback</strong>接口中一个重要的回调值为<strong>CuratorEvent</strong>，里面包含事件类型、响应吗和节点的详细信息。</p>
<p><strong>CuratorEventType</strong></p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>对应CuratorFramework实例的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>CREATE</td>
<td>create()</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete()</td>
</tr>
<tr>
<td>EXISTS</td>
<td>checkExists()</td>
</tr>
<tr>
<td>GET_DATA</td>
<td>getData()</td>
</tr>
<tr>
<td>SET_DATA</td>
<td>setData()</td>
</tr>
<tr>
<td>CHILDREN</td>
<td>getChildren()</td>
</tr>
<tr>
<td>SYNC</td>
<td>sync(String,Object)</td>
</tr>
<tr>
<td>GET_ACL</td>
<td>getACL()</td>
</tr>
<tr>
<td>SET_ACL</td>
<td>setACL()</td>
</tr>
<tr>
<td>WATCHED</td>
<td>Watcher(Watcher)</td>
</tr>
<tr>
<td>CLOSING</td>
<td>close()</td>
</tr>
</tbody>
</table>
<p><strong>响应码(#getResultCode())</strong></p>
<table>
<thead>
<tr>
<th>响应码</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>OK，即调用成功</td>
</tr>
<tr>
<td>-4</td>
<td>ConnectionLoss，即客户端与服务端断开连接</td>
</tr>
<tr>
<td>-110</td>
<td>NodeExists，即节点已经存在</td>
</tr>
<tr>
<td>-112</td>
<td>SessionExpired，即会话过期</td>
</tr>
</tbody>
</table>
<p><strong>异步创建节点的示例如下：</strong></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Executor executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">client.create()</span><br><span class="line">      .creatingParentsIfNeeded()</span><br><span class="line">      .withMode(CreateMode.EPHEMERAL)</span><br><span class="line">      .inBackground<span class="function"><span class="params">((curatorFramework, curatorEvent) -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            System.out.println(String.format(<span class="string">"eventType:%s,resultCode:%s"</span>,curatorEvent.getType(),curatorEvent.getResultCode()));</span></span></span><br><span class="line"><span class="function"><span class="params">      &#125;,executor)</span>.<span class="title">forPath</span><span class="params">(<span class="string">"path"</span>)</span>;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：如果#inBackground()方法不指定executor，那么会默认使用Curator的EventThread去进行异步处理。</strong></p>
<h3 id="Curator高级特性"><a href="#Curator高级特性" class="headerlink" title="Curator高级特性"></a>Curator高级特性</h3><p>以上都是Curator简单的使用，在实际应用中会使用更高级的方式来管理zk节点。</p>
<p><strong>提醒：首先你必须添加curator-recipes依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>Zookeeper原生支持通过注册<strong>Watcher</strong>来进行事件监听，但是开发者需要反复注册(Watcher只能单次注册单次使用)。<strong>Cache</strong>是Curator中对事件监听的包装，可以看作是对事件监听的本地缓存视图，能够自动为开发者处理反复注册监听。Curator提供了三种 <strong>Watcher(Cache)</strong> 来监听结点的变化。</p>
<h5 id="Path-Cache"><a href="#Path-Cache" class="headerlink" title="Path Cache"></a>Path Cache</h5><p>Path Cache用来监控一个<strong>ZNode的子节点</strong>. 当一个子节点增加， 更新，删除时， Path Cache会改变它的状态， 会包含最新的子节点， 子节点的数据和状态，而状态的更变将通过<strong>PathChildrenCacheListener</strong>通知。</p>
<p><strong>实际使用时会涉及到四个类：</strong></p>
<blockquote>
<ul>
<li>PathChildrenCache</li>
<li>PathChildrenCacheEvent</li>
<li>PathChildrenCacheListener</li>
<li>ChildData</li>
</ul>
</blockquote>
<p>通过下面的构造函数创建Path Cache:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PathChildrenCache(CuratorFramework client, <span class="keyword">String</span> path, <span class="keyword">boolean</span> cacheData)</span><br></pre></td></tr></table></figure>
<p>想使用cache，必须调用它的start方法，使用完后调用close方法。 可以设置StartMode来实现启动的模式，</p>
<p>StartMode有下面几种：</p>
<blockquote>
<ul>
<li>NORMAL：正常初始化。</li>
<li>BUILD_INITIAL_CACHE：在调用start()之前会调用rebuild()。</li>
<li>POST_INITIALIZED_EVENT：当Cache初始化数据后发送一个PathChildrenCacheEvent.Type#INITIALIZED事件</li>
</ul>
</blockquote>
<p>++public void addListener(PathChildrenCacheListener listener)++ 可以增加listener监听缓存的变化。</p>
<p>++getCurrentData()++ 方法返回一个<strong>List<childdata></childdata></strong> 对象，可以遍历所有的子节点。</p>
<p><strong>设置/更新、移除其实是使用client (CuratorFramework)来操作, 不通过PathChildrenCache操作：项目示例：</strong></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 监听子节点</span></span><br><span class="line"><span class="comment">    * 子节点新增，就往里面写数据</span></span><br><span class="line"><span class="comment">    * 子节点更新，</span></span><br><span class="line"><span class="comment">    * 子节点删除，</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">final</span> String path = ZKContant.ROOT_PATH + <span class="string">"/"</span> + strategy;</span><br><span class="line">       <span class="comment">//client是通过 CuratorFrameworkFactory.newClient创建的</span></span><br><span class="line">       <span class="keyword">final</span> PathChildrenCache cache = <span class="keyword">new</span> PathChildrenCache(client, path,<span class="keyword">true</span>);</span><br><span class="line">       ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">       cache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener()&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework curatorFramework, PathChildrenCacheEvent pathChildrenCacheEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               ChildData data = pathChildrenCacheEvent.getData();</span><br><span class="line">               <span class="keyword">switch</span> (pathChildrenCacheEvent.getType()) &#123;</span><br><span class="line">                   <span class="keyword">case</span> CHILD_ADDED:</span><br><span class="line">                       //向子节点写入信息 并更新信息</span><br><span class="line">                       childrenWatch.childrenAdd(data);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> CHILD_UPDATED:</span><br><span class="line">                       childrenWatch.childrenUpdate(data);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> CHILD_REMOVED:</span><br><span class="line">                       childrenWatch.childrenRemove(data);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, pool);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           cache.start();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           logger.<span class="keyword">error</span>(e.toString());</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果new PathChildrenCache(client, PATH, true)中的参数cacheData值设置为false，则示例中的pathChildrenCacheEvent.getData().getData()、data.getData()将返回null，cache将不会缓存节点数据。</p>
<h5 id="Node-Cache"><a href="#Node-Cache" class="headerlink" title="Node Cache"></a>Node Cache</h5><p>Node Cache与Path Cache类似，Node Cache只是监听某一个特定的节点。它涉及到下面的三个类：</p>
<blockquote>
<ul>
<li>NodeCache - Node Cache实现类</li>
<li>NodeCacheListener - 节点监听器</li>
<li>ChildData - 节点数据</li>
</ul>
</blockquote>
<p><strong>注意：使用cache，依然要调用它的start()方法，使用完后调用close()方法。</strong></p>
<p>getCurrentData()将得到节点当前的状态，通过它的状态可以得到当前的值。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String path = ZKContant.ROOT_PATH + <span class="string">"/"</span> + strategy;</span><br><span class="line">        <span class="keyword">final</span> NodeCache cache = <span class="keyword">new</span> NodeCache(client, path, <span class="keyword">true</span>);</span><br><span class="line">        ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">        cache.getListenable().addListener(<span class="keyword">new</span> NodeCacheListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ChildData currentData = cache.getCurrentData();</span><br><span class="line">                <span class="keyword">if</span> (currentData != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    Properties props = ObjectUtil.toObject(currentData.getData());</span><br><span class="line">                    nodeWatch.handle(props, path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cache.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.<span class="keyword">error</span>(e.toString());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意：NodeCache只能监听一个节点的状态变化。</p>
<h5 id="Tree-Cache"><a href="#Tree-Cache" class="headerlink" title="Tree Cache"></a>Tree Cache</h5><p>Tree Cache可以监控整个树上的所有节点，类似于PathCache和NodeCache的组合，主要涉及到下面四个类：</p>
<blockquote>
<ul>
<li>TreeCache - Tree Cache实现类</li>
<li>TreeCacheListener - 监听器类</li>
<li>TreeCacheEvent - 触发的事件类</li>
<li>ChildData - 节点数据</li>
</ul>
</blockquote>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeCacheDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/cache"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws Exception &#123;</span><br><span class="line">		TestingServer <span class="keyword">server</span> = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework <span class="keyword">client</span> = CuratorFrameworkFactory.newClient(<span class="keyword">server</span>.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">		<span class="keyword">client</span>.start();</span><br><span class="line">		<span class="keyword">client</span>.create().creatingParentsIfNeeded().forPath(PATH);</span><br><span class="line">		TreeCache cache = <span class="keyword">new</span> TreeCache(<span class="keyword">client</span>, PATH);</span><br><span class="line">		TreeCacheListener listener = (client1, event) -&gt;</span><br><span class="line">				System.out.println(<span class="string">"事件类型："</span> + event.getType() +</span><br><span class="line">						<span class="string">" | 路径："</span> + (<span class="keyword">null</span> != event.getData() ? event.getData().getPath() : <span class="keyword">null</span>));</span><br><span class="line">		cache.getListenable().addListener(listener);</span><br><span class="line">		cache.start();</span><br><span class="line">		<span class="keyword">client</span>.setData().forPath(PATH, <span class="string">"01"</span>.getBytes());</span><br><span class="line">		Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		<span class="keyword">client</span>.setData().forPath(PATH, <span class="string">"02"</span>.getBytes());</span><br><span class="line">		Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		<span class="keyword">client</span>.delete().deletingChildrenIfNeeded().forPath(PATH);</span><br><span class="line">		Thread.sleep(<span class="number">1000</span> * <span class="number">2</span>);</span><br><span class="line">		cache.close();</span><br><span class="line">		<span class="keyword">client</span>.close();</span><br><span class="line">		System.out.println(<span class="string">"OK!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：TreeCache在初始化(调用start()方法)的时候会回调TreeCacheListener实例一个事TreeCacheEvent，而回调的TreeCacheEvent对象的Type为INITIALIZED，ChildData为null，此时event.getData().getPath()很有可能导致空指针异常，这里应该主动处理并避免这种情况。</strong></p>
<p>工作中主要使用了<strong>Path Cache</strong> 和<strong>Node Cache</strong>,一个监控子节点，一个监控节点。<br>系统中会有很多种策略，每种策略都会在根节点上创建一个ZKNode，当另一个系统启动的时候，也会检测这个策略节点，当这个策略节点信息改变的时候，监控客户端和服务端就回收到改变的通知。然后做出相应的处理。</p>
<p>大致如流程图所示：</p>
<p><img src="strategy流程图.jpg" alt="ZK"></p>
<hr>
<h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1><p>参考：</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat-reward.png" alt="Foutlook WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay-reward.png" alt="Foutlook Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>
	
	<div>
	  
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
	  
	</div>
	
	


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Dubbo，Zookeeper，分布式/" rel="tag"># Dubbo，Zookeeper，分布式</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/28/浅谈MQ/" rel="next" title="浅谈MQ">
                <i class="fa fa-chevron-left"></i> 浅谈MQ
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/01/2018总结/" rel="prev" title="来自2019的2018">
                来自2019的2018 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <!--
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
   -->
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.jpg"
               alt="Foutlook" />
          <p class="site-author-name" itemprop="name">Foutlook</p>
          <p class="site-description motion-element" itemprop="description">生活如果很顺利,那该多无聊</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Foutlook" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/foutlook6" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/5431985539" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/fxkai-ai" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://my.csdn.net/kai_12" title="我的CSDN" target="_blank">我的CSDN</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Dubbo"><span class="nav-number">2.</span> <span class="nav-text">Dubbo</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Zookeeper"><span class="nav-number">3.</span> <span class="nav-text">Zookeeper</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper的简介"><span class="nav-number">3.1.</span> <span class="nav-text">Zookeeper的简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper的结构"><span class="nav-number">3.2.</span> <span class="nav-text">Zookeeper的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ZooKeeper-Watch"><span class="nav-number">3.2.1.</span> <span class="nav-text">ZooKeeper Watch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（一次性触发）One-time-trigger"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">（一次性触发）One-time trigger</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（发送至客户端）Sent-to-the-client"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">（发送至客户端）Sent to the client</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（被设置-watch-的数据）The-data-for-which-the-watch-was-set"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">（被设置 watch 的数据）The data for which the watch was set</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZooKeeper的工作原理"><span class="nav-number">3.3.</span> <span class="nav-text">ZooKeeper的工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper的典型应用场景"><span class="nav-number">3.4.</span> <span class="nav-text">Zookeeper的典型应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据发布与订阅（配置中心）"><span class="nav-number">3.4.1.</span> <span class="nav-text">数据发布与订阅（配置中心）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#负载均衡"><span class="nav-number">3.4.2.</span> <span class="nav-text">负载均衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名服务-Naming-Service"><span class="nav-number">3.4.3.</span> <span class="nav-text">命名服务(Naming Service)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式通知-协调"><span class="nav-number">3.4.4.</span> <span class="nav-text">分布式通知/协调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群管理与Master选举"><span class="nav-number">3.4.5.</span> <span class="nav-text">集群管理与Master选举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式锁"><span class="nav-number">3.4.6.</span> <span class="nav-text">分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式队列"><span class="nav-number">3.4.7.</span> <span class="nav-text">分布式队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zookeeper应用"><span class="nav-number">3.5.</span> <span class="nav-text">Zookeeper应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Zookeeper客户端Curator的使用"><span class="nav-number">3.5.1.</span> <span class="nav-text">Zookeeper客户端Curator的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Curator的基本Api"><span class="nav-number">3.5.2.</span> <span class="nav-text">Curator的基本Api</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建会话"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">创建会话</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动客户端"><span class="nav-number">3.5.3.</span> <span class="nav-text">启动客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CuratorFramework的方法"><span class="nav-number">3.5.4.</span> <span class="nav-text">CuratorFramework的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据节点操作"><span class="nav-number">3.5.5.</span> <span class="nav-text">数据节点操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建数据节点"><span class="nav-number">3.5.5.1.</span> <span class="nav-text">创建数据节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除数据节点"><span class="nav-number">3.5.5.2.</span> <span class="nav-text">删除数据节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读取数据节点数据"><span class="nav-number">3.5.5.3.</span> <span class="nav-text">读取数据节点数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更新数据节点数据"><span class="nav-number">3.5.5.4.</span> <span class="nav-text">更新数据节点数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检查节点是否存在"><span class="nav-number">3.5.5.5.</span> <span class="nav-text">检查节点是否存在</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取某个节点的所有子节点路径"><span class="nav-number">3.5.5.6.</span> <span class="nav-text">获取某个节点的所有子节点路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事务"><span class="nav-number">3.5.5.7.</span> <span class="nav-text">事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步接口"><span class="nav-number">3.5.5.8.</span> <span class="nav-text">异步接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Curator高级特性"><span class="nav-number">3.5.6.</span> <span class="nav-text">Curator高级特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Cache"><span class="nav-number">3.5.6.1.</span> <span class="nav-text">Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Path-Cache"><span class="nav-number">3.5.6.1.1.</span> <span class="nav-text">Path Cache</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Node-Cache"><span class="nav-number">3.5.6.1.2.</span> <span class="nav-text">Node Cache</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Tree-Cache"><span class="nav-number">3.5.6.1.3.</span> <span class="nav-text">Tree Cache</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#end"><span class="nav-number">4.</span> <span class="nav-text">end</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Foutlook</span>
</div>




<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<div class="powered-by">
  <span class="post-count">博客全站共119.2k字</span>
</div>

<!--
<div class="powered-by">
  由  强力驱动
</div>
-->


<div class="theme-info">
  主题 - 豫ICP备17009860号
</div>


        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'foutlook';
      var disqus_identifier = '2018/12/20/Dubbo与Zookeeper/';

      var disqus_title = "Dubbo与Zookeeper";


      function run_disqus_script(disqus_script) {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');

      
        var disqus_config = function () {
            this.page.url = disqus_url;
            this.page.identifier = disqus_identifier;
            this.page.title = disqus_title;
        };
        run_disqus_script('embed.js');
      

    </script>
  








  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>

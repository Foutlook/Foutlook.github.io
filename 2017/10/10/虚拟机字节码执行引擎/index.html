<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="true" />




  <meta name="baidu-site-verification" content="true" />






  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JVM，类加载," />





  <link rel="alternate" href="/atom.xml" title="Foutin" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="概述 本文章参考周志明的【深入理解Java虚拟机】代码编译的结果从本地机器码转变成字节码，是存储格式发展的一小步，却是编译语言发展的一大步。  在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观(Facade)。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行">
<meta name="keywords" content="JVM，类加载">
<meta property="og:type" content="article">
<meta property="og:title" content="【深入理解JVM】之六：虚拟机字节码执行引擎">
<meta property="og:url" content="http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/index.html">
<meta property="og:site_name" content="Foutin">
<meta property="og:description" content="概述 本文章参考周志明的【深入理解Java虚拟机】代码编译的结果从本地机器码转变成字节码，是存储格式发展的一小步，却是编译语言发展的一大步。  在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观(Facade)。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/栈帧的概念结构.png">
<meta property="og:image" content="http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/栈之间的数据共享.png">
<meta property="og:image" content="http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/Slot.png">
<meta property="og:image" content="http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/解释器1.png">
<meta property="og:image" content="http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/解释器2.png">
<meta property="og:image" content="http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/解释器3.png">
<meta property="og:image" content="http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/解释器4.png">
<meta property="og:image" content="http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/解释器5.png">
<meta property="og:image" content="http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/解释器6.png">
<meta property="og:image" content="http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/解释器7.png">
<meta property="og:image" content="http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/invokestatic.png">
<meta property="og:image" content="http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/反编译.png">
<meta property="og:image" content="http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/方法表结构.png">
<meta property="og:updated_time" content="2017-12-05T06:49:19.433Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【深入理解JVM】之六：虚拟机字节码执行引擎">
<meta name="twitter:description" content="概述 本文章参考周志明的【深入理解Java虚拟机】代码编译的结果从本地机器码转变成字节码，是存储格式发展的一小步，却是编译语言发展的一大步。  在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观(Facade)。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行">
<meta name="twitter:image" content="http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/栈帧的概念结构.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '5a8e9aeb6aad13d9f3471d44095328f5',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/"/>





  <title> 【深入理解JVM】之六：虚拟机字节码执行引擎 | Foutin </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Foutin</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/10/虚拟机字节码执行引擎/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Foutlook">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/head.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Foutin">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Foutin" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                【深入理解JVM】之六：虚拟机字节码执行引擎
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-10T10:33:00+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java虚拟机/" itemprop="url" rel="index">
                    <span itemprop="name">Java虚拟机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/10/虚拟机字节码执行引擎/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/10/10/虚拟机字节码执行引擎/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">本文总阅读量
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
		  
		  
		  <!--以下部分为: 字数统计、阅读时长插入代码-->
		
        <span class="post-time">
			&nbsp; | &nbsp;
           <span class="post-meta-item-icon">
             <i class="fa fa-calendar-o"></i>
           </span>
           <span class="post-meta-item-text">字数统计:</span>
           <span class="post-count">7,245(字)</span>
           
        </span>
	  
		<span class="post-time">
			&nbsp; | &nbsp;
           <span class="post-meta-item-icon">
             <i class="fa fa-calendar-o"></i>
           </span>
           <span class="post-meta-item-text">阅读时长:</span>
           <span class="post-count">27(分)</span>
           
        </span>
		<!-- 以上部分为: 字数统计、阅读时长插入代码 -->

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>本文章参考周志明的【深入理解Java虚拟机】<br>代码编译的结果从本地机器码转变成字节码，是存储格式发展的一小步，却是编译语言发展的一大步。</p>
</blockquote>
<p>在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观(Facade)。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行)两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎，但从外观上看起来，所有的Java虚拟机的执行引擎都是一致的：<strong>输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行过程</strong>，下面将从概念模型的角度来讲解虚拟机的<strong>方法调用和字节码执行</strong>。</p>
<hr>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p><strong>栈帧(Stack Frame)</strong>是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的<strong>虚拟机栈(Virtual Machine Stack)的栈元素</strong>。栈帧存储了方法的<strong>局部变量表，操作数栈，动态链接，方法返回地址和一些额外的附加信息</strong>等信息。每一个方法从调用开始到执行完成，就对应着一个栈帧在虚拟机栈中从<strong>入栈到出栈</strong>的过程。<br><strong>在编译代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了</strong>，并且写入到了方法表的Code属性中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体虚拟机的实现。<br>在活动线程中，只有位于栈顶的栈帧才是有效的，称为<strong>当前栈帧</strong>，与这个当前栈帧关联的方法称为<strong>当前方法</strong>。<strong>执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作</strong>。<br>下图是栈帧结构的概念模型：<br><img src="栈帧的概念结构.png" alt="执行引擎"></p>
<h3 id="局部变量变"><a href="#局部变量变" class="headerlink" title="局部变量变"></a>局部变量变</h3><p><strong>局部变量表</strong>是一组变量值存储空间，用于存放<strong>方法参数和方法内部定义的局部变量</strong>。在Java程序编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。<br><strong>局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位</strong>。虚拟机规范中并没有明确指明一个Slot应占的内存空间的大小，只是说到每个Slot都应该存放一个boolean，byte，char，short，int，float，reference和returnAddress这8种类型数据。<br>第七种reference类型表示对一个对象实例的引用，虚拟机规范即没有说明它的长度，也没有明确指定这种应用应有怎样的结构。但一般来说，虚拟机实现至少都应该能<strong>通过这个引用做到两点</strong>：一是从此引用中直接或间接的查找到对象在java堆中的数据存放的起始地址索引，二是此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则无法实现java语言规范中定义的语法约束的约束。<br>对于64位的数据类型，虚拟机会高位对齐的方式为其分配两个连续的Slot空间，java语言规定的64位数据类型只有long和double两种（reference类型可能是32位也可能是64位）。</p>
<p>虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的Slot数量。如果访问的是32位数据类型的变量，<strong>索引n就代表了使用第n个Slot</strong>，如果是64位数据类型的变量，则说明会同时使用n和n+1两个Slot。对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用任何方式单独访问其中的某一个，Java虚拟机规范中明确要求了如果遇到进行这种操作的字节码序列，虚拟机应该在类加载的校验阶段抛出异常。 </p>
<p>在方法执行时，虚拟机是使用局部变量表完成参数变量列表的传递过程，如果是<strong>实例方法(非static方法</strong>)，那<strong>么局部变量表中的第0位索引的Slot默认是用于传递方法所属对象实例的引用</strong>，在方法中可以通过关键字<strong>“this”</strong>来访问这个隐含的参数，其余参数则按照参数列表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据<strong>方法体内部定义的变量顺序和作用域来分配其余的Slot</strong>。</p>
<p><strong>局部变量表中的Slot是可重用的</strong>，方法体中定义的变量，其作用域并不一定会覆盖整个方法，如果当前字节码PC计算器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其它变量使用。</p>
<blockquote>
<p>注意：虽然Slot重用可以节省栈帧空间，但是重用栈帧会伴随一些额外的副作用。如，某些情况下，Slot的复用会影响垃圾收集行为。</p>
</blockquote>
<p>影响之一：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		byte[] placeholder = new byte[64*1024*1024];</span><br><span class="line">		System.gc();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc())  <span class="number">68198</span>K-&gt;<span class="number">66120</span>K(<span class="number">125952</span>K), <span class="number">0.0027128</span> secs]</span><br><span class="line">[Full GC (System.gc())  <span class="number">66120</span>K-&gt;<span class="number">66063</span>K(<span class="number">125952</span>K), <span class="number">0.0080045</span> secs]</span><br></pre></td></tr></table></figure>
<p><strong>从结果中可以看出，在运行System.gc（）后并没有回收64M的内存。主要原因是在执行GC时，变量placeholder还处于作用域之内，虚拟机无法回收。</strong></p>
<p>修改代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			byte[] placeholder = new byte[64*1024*1024];</span><br><span class="line">		&#125;</span><br><span class="line">		System.gc();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc())  <span class="number">67532</span>K-&gt;<span class="number">66176</span>K(<span class="number">125952</span>K), <span class="number">0.0013205</span> secs]</span><br><span class="line">[Full GC (System.gc())  <span class="number">66176</span>K-&gt;<span class="number">66060</span>K(<span class="number">125952</span>K), <span class="number">0.0067795</span> secs]</span><br></pre></td></tr></table></figure>
<p><strong>加了花括号之后，placeholder的作用域被限制在花括号之内，从逻辑代码上讲，在执行System.gc（）时，placeholder已经不可能被访问了，但结果发现，还是有64M的内存无法别回收。这又是为什么呢？？？</strong></p>
<p>下面我们继续修改代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			byte[] placeholder = new byte[64*1024*1024];</span><br><span class="line">		&#125;</span><br><span class="line">		int a =0;</span><br><span class="line">		System.gc();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc())  <span class="number">67532</span>K-&gt;<span class="number">66176</span>K(<span class="number">125952</span>K), <span class="number">0.0008704</span> secs]</span><br><span class="line">[Full GC (System.gc())  <span class="number">66176</span>K-&gt;<span class="number">524</span>K(<span class="number">125952</span>K), <span class="number">0.0063974</span> secs]</span><br></pre></td></tr></table></figure>
<p><strong>结果中我们发现，64M内存被回收了，这中间发生了什么？</strong><br>根本原因：</p>
<blockquote>
<p>placeholder被收回要看局部变量表中的slot是否还存有关于placeholder数组对象的引用，第一次修改中，代码虽然已经离开了placeholder的作用域，但在此以后，没有任何对局部变量表的读写操作，placeholder原本所占用的slot没有被其他变量复用，局部变量表仍保持着对它的关联。这种关联没有及时被打断，在绝大部分情况下影响都是很轻微的，但如果遇到一个方法，其后的代码有一些耗时很长的操作，而前面有定义了占用大量内存，实际上已经不会再使用的变量，手动将其设置为null（用来代替a=0，把变量对应的局部变量表Slot清空）便不见得是一个绝对无意义的操作。<br>但是我们不应该对赋null值的操作有过多的依赖，原因是：从编码角度将，<strong>以恰当的变量作用域来控制变量回收时间才是最优雅的解决办法</strong>。</p>
</blockquote>
<p>局部变量不像前面介绍的类变量那样存在“准备阶段”。类变量有两次赋初始值的过程，<br><strong>一次在准备阶段，赋予系统初始值。</strong><br><strong>另外一次在初始化阶段，赋予程序员定义的值。</strong><br>因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。<br><strong>但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的。不要认为Java中任何情况下都存在诸如整型变量默认为0，布尔变量默认为false等这样的默认值。</strong></p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈也常被称为操作栈，它是一个<strong>后入先出栈</strong>。同局部变量表一样，操作数栈的最大深度也是编译的时候被写入到方法表的Code属性的max_stacks数据项中。<br>　当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在<strong>方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作</strong>。例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。<br> 　操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类检验阶段的数据流分析中还要再次验证这一点。<strong>以iadd指令为例，这个指令用于整型数加法，这在执行时，最接近栈顶的两个元素的数据类型必须为int型，不能出现一个long和一个float使用iadd命令相加的情况</strong><br>　另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了，如下图所示：<br> <img src="栈之间的数据共享.png" alt="执行引擎"></p>
<hr>
<blockquote>
<p><strong>Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。</strong></p>
</blockquote>
<p>下面我们来讲解一下</p>
<blockquote>
<p>许多java虚拟机的执行引擎在执行java代码的时候都有<strong>解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择</strong>—-关于编译执行（JIT），在以后的文章中将会讲解。<br><strong>解释执行即对字节码逐条解释执行。</strong></p>
</blockquote>
<h3 id="基于栈的解释器执行过程"><a href="#基于栈的解释器执行过程" class="headerlink" title="基于栈的解释器执行过程"></a>基于栈的解释器执行过程</h3><p>本节准备一段java代码，看看虚拟机总实际是如何执行的：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int calc()&#123;</span><br><span class="line">		int a=100;</span><br><span class="line">		int b=200;</span><br><span class="line">		int c =300;</span><br><span class="line">		return (a+b)*c;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>使用javap命令看看它的字节码指令：<br> <img src="Slot.png" alt="执行引擎"><br>javap 提示这段代码需要深度位2的操作数栈和4个Slot的局部变量空间。我们通过图的方式来观察javap字节码指令执行中的代码，操作数栈和局部变量表的变化：<br><strong>偏移地址为0的指令的情况：</strong><br> <img src="解释器1.png" alt="执行引擎"></p>
<p> <strong>偏移地址为1的指令的情况：</strong><br> <img src="解释器2.png" alt="执行引擎"></p>
<p> <strong>偏移地址为11的指令的情况：</strong><br> <img src="解释器3.png" alt="执行引擎"></p>
<p> <strong>偏移地址为12的指令的情况：</strong><br> <img src="解释器4.png" alt="执行引擎"></p>
<p> <strong>偏移地址为13的指令的情况：</strong><br> <img src="解释器5.png" alt="执行引擎"></p>
<p> <strong>偏移地址为14的指令的情况：</strong><br> <img src="解释器6.png" alt="执行引擎"></p>
<p> <strong>偏移地址为16的指令的情况：</strong><br> <img src="解释器7.png" alt="执行引擎"></p>
<blockquote>
<p>上面的执行过程仅仅是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述…….更准确的说，实际情况会和上面描述的概念模型差距非常大，这种差距产生的原因是虚拟机中解析器和即时编译器都会对输入的字节码进行优化。</p>
</blockquote>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>　</p>
<blockquote>
<p>每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(Dynamic<br>Linking)。通过前面类文件结构，我们知道在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为<strong>静态解析</strong>。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为<strong>动态连接</strong>。</p>
</blockquote>
<h3 id="方法返回值地址"><a href="#方法返回值地址" class="headerlink" title="方法返回值地址"></a>方法返回值地址</h3><p><strong>当一个方法被执行后，有两种方式退出这个方法。</strong> </p>
<blockquote>
<p>第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口(Normal Method Invocation Completion)。<br>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口(Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。</p>
</blockquote>
<p>无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说， </p>
<ul>
<li>方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。 </li>
<li>而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。</li>
</ul>
<p><strong>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：</strong> </p>
<blockquote>
<p>①.恢复上层方法的局部变量表和操作数栈，<br>②.把返回值(如果有的话)压入调用都栈帧的操作数栈中，<br>③.调用PC计数器的值以指向方法调用指令后面的一条指令等。</p>
</blockquote>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。<br>所以可以说栈帧分为三部分：<strong>局部变量区、操作数栈和栈帧信息</strong>。</p>
<hr>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>　<strong>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。</strong><br>Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于直接引用）。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期才能确定目标方法的直接引用。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><blockquote>
<p><strong>所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用。 在类加载的解析阶段会将一部分符号引用转化为直接引用</strong>，这种解析能成功的前提是：<strong>方法在程序真正运行之前就有一个课确定的调用版本，并且这个方法的调用版本在运行期是不可变的。</strong>也就是说，调用目标在程序代码写好，编译器进行编译时就确定下来，<strong>这类方法的调用称为解析（Resolution）</strong>。</p>
</blockquote>
<p>　在java语言中满足“编译期确定，运行期不变”的方法有<strong>静态方法和私有方法两大类</strong>。前者与类型直接关联，后者在外部不可被访问，这两种方式各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合<strong>在类加载阶段进行解析</strong>。<br>　与之相对应的是 ，在Java虚拟机里提供了5条方法调用字节码指令(实际上在JVM jdk 1.6层面只有前面四种方法调用的指令)，分别如下：<br>　1).invokestatic：调用静态方法<br>　2).invokespecial：调用类实例的构造器&lt; init&gt;方法、私有方法和父类方法<br>　3).invokevirtual：调用所有的虚方法<br>　4).invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。<br>　5).invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。 </p>
<p>通过以上描述，我们可以得出下面两种概念：<br><strong>非虚方法</strong>：只要能被invokestatic和invokespecial指令调用的方法，都可以在类加载的时候把符号引用解析为该方法的直接引用。这里主要是指，私有方法，静态方法，实例构造器，父类方法.（Java中明确说明了final方法是一种非虚方法，虽然被invokevirtual调用，但它无法被覆盖，没有其它版本）<br><strong>虚方法（除去final方法）</strong>，被invokevirtual和invokeinterface调用的则为虚方法，因为在编译期间并不能确定要调用的真正方法，所以称为虚方法。<br>示例如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class StaticResolution &#123;</span><br><span class="line">	public static void sayHello()&#123;</span><br><span class="line">		System.out.println("hello world");</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		StaticResolution.sayHello();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用javap命令查看字节码如下：<br> <img src="invokestatic.png" alt="执行引擎"><br> 我们发现的确是通过invokestatic命令来调用sayHello（）方法的</p>
<p> 对于被final修饰的方法，虽然final方法是使用invokevirtual指令来调用，但是由于它无法被覆盖，没有其他的版本，所以也无须对方法接受者进行多态选择，又或者说多态选择的结果肯定是唯一的。<strong>在java语言规范中明确说明了final方法是一种非虚方法</strong>。</p>
<p> <strong>解析调用</strong>一定是个静态的过程，在编译期间就完全确定，在<strong>类装载的解析阶段就会把符号引用转为直接引用</strong>，不会延迟到运行期再去完成。而<strong>分派(Dispatch)调用</strong>则可能是静态的也可能是动态的，根据分派依据的宗量数(本文后面有讲)可分为单分派和多分派。这两类分派方式的两两组合就构成了<strong>静态单分派、静态多分派、动态单分派、动态多分派</strong>4种分派组合情况。</p>
<hr>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p><strong>众所周知java面向对象的三个重要特性，封装、继承、多态。而在jvm层面多态的实现由分派完成。分派有静态分派、动态分派。</strong> </p>
<h4 id="静态分派–代表重载"><a href="#静态分派–代表重载" class="headerlink" title="静态分派–代表重载"></a>静态分派–代表重载</h4><p>在讲解之前，我们先看下面的代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class StaticDispatch &#123;</span><br><span class="line">    static abstract class Human &#123;&#125;</span><br><span class="line"></span><br><span class="line">    static class Man extends Human &#123;&#125;</span><br><span class="line"></span><br><span class="line">    static class Woman extends Human &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello(Human human) &#123;</span><br><span class="line">        System.out.println("hello human");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello(Man man) &#123;</span><br><span class="line">        System.out.println("hello man");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello(Woman woman) &#123;</span><br><span class="line">        System.out.println("hello woman");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Human man = new Man();</span><br><span class="line">        Human woman = new Woman();</span><br><span class="line"></span><br><span class="line">        StaticDispatch sr = new StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello ,guy!</span><br><span class="line">hello ,guy!</span><br></pre></td></tr></table></figure>
<p><strong>为什么会出现上面的结果呢？？？我们来看看反编译的结果</strong>：<br> <img src="反编译.png" alt="执行引擎"></p>
<p>解决以上 问题之前，我们先解释两个重要的概念：<br>Human man = new Man();<br>代码里的<strong>Human称为静态类型（或者叫外观类型</strong>）：其变化仅在使用时发生，变量本身的静态类型不会改变，并且最终的静态类型是在编译期可知的。<br>而<strong>Man称为实际类型</strong>：其变化的结果在运行期才可确定，编译器不编译程序时并不知道一个对象的实际类型是什么。</p>
<blockquote>
<p>main()方法的两次sayHello方法的调用，在方法接收者已经确定是对象sr的前提下，使用哪个重载版本，<strong>完全取决于传入参数的数量和数据类型</strong>，代码中刻意定义了<strong>两个静态类型相同但实际类型不同的变量</strong>，但虚拟机（准确的说是编译器）在重载时通过参数的静态类型，而不是实际类型作为判定依据。<br> 而且通过以上的反编译结果我们可以发现，<strong>man和woman在编译的时候被强转成了Human类型</strong>，所以导致上面的结果</p>
</blockquote>
<p><strong>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派</strong>。 </p>
<blockquote>
<p>静态分派典型的应用是方法重载(虚拟机准确的说是编译器，在重载时是通过参数的静态类型而不是实际类型作为判定依据的)<br>静态分派发生在编译阶段(也就是说在编译期是可知的)，因此确定静态分派的动作实际上不是由虚拟机来执行的<br>对于方法参数的匹配也是根据变量的静态类型来确定，在很多情况下根据参数的类型并不能找到”唯一的”方法调用，这个时候的处理方式是找到一个”最合适’的方法。</p>
</blockquote>
<p>如下代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class OverLoad &#123;</span><br><span class="line">    public static void sayHello(char arg) &#123;</span><br><span class="line">        System.out.println("hello char");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(int arg) &#123;</span><br><span class="line">        System.out.println("hello int");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(long arg) &#123;</span><br><span class="line">        System.out.println("hello long");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(Character arg) &#123;</span><br><span class="line">        System.out.println("hello Character");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(Serializable arg) &#123;</span><br><span class="line">        System.out.println("hello Serializable");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(Object arg) &#123;</span><br><span class="line">        System.out.println("hello object");</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sayHello(char ...arg) &#123;</span><br><span class="line">        System.out.println("hello arg...");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        sayHello('a');</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从头注解方法，结果会按顺序输出。<br>注意:1、基本类型是重载按char-&gt;int-&gt;long-&gt;float-&gt;double顺序匹配的。<br>　　2、可变参数的重载优先级是最低的。</p>
<h4 id="动态分派–代表重写"><a href="#动态分派–代表重写" class="headerlink" title="动态分派–代表重写"></a>动态分派–代表重写</h4><p>想了解动态分派，必须先了解多态另一个体现—重写。如下示例：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicDispatch &#123;</span><br><span class="line">    static abstract class Human &#123;</span><br><span class="line">        protected abstract void sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Man extends Human &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void sayHello() &#123;</span><br><span class="line">            System.out.println("man say hello");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Woman extends Human &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void sayHello() &#123;</span><br><span class="line">            System.out.println("woman say hello");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Human man = new Man();</span><br><span class="line">        Human woman = new Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line"></span><br><span class="line">        man = new Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man say hello </span><br><span class="line">woman say hello </span><br><span class="line">woman say hello</span><br></pre></td></tr></table></figure>
<p>显然这里不可能再根据静态类型来决定，因为静态类型同样都是Human的两个变量man和woman在调用sayHello()方法时执行了不同的行为，并且变量在两次调用中执行了不同的方法。<br>导致这个现象的原因：是这两个变量的实际类型不同。<br>由于invokevirtual指令执行的第一步就是在运行期间确定接收者的实际类型，所以两次调用的invokevirtual指令把常量池中的类方法<strong>符号引用解析到了不同的直接引用</strong>上，这个过程就是Java语言方法重写的本质。这种<strong>在运行期间根据实际类型确定方法执行版本的过程称为动态分派</strong>。<br><strong>动态分派的一个重要体现就是方法的重写，虽然父类引用可以指向子类对象，但是动态分派的方法调用是在运行时根据对象的实际类型去确认的。</strong></p>
<h4 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h4><p><strong>方法的接收者与方法的参数称为方法的宗量。 单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。</strong></p>
<p>示例如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Dispatch &#123;</span><br><span class="line">	static class QQ&#123;&#125;</span><br><span class="line">	static class _360&#123;&#125;</span><br><span class="line">	public static class Father&#123;</span><br><span class="line">		public void hardChoice(QQ arg)&#123;</span><br><span class="line">			System.out.println("father choose 11");</span><br><span class="line">		&#125;</span><br><span class="line">		public void hardChoice(_360 arg)&#123;</span><br><span class="line">			System.out.println("father choose 360");</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static class Son extends Father&#123;</span><br><span class="line">		<span class="comment">//重写父类的方法</span></span><br><span class="line">		@Override</span><br><span class="line">		public void hardChoice(QQ arg)&#123;</span><br><span class="line">			System.out.println("son choose qq");</span><br><span class="line">		&#125;</span><br><span class="line">		@Override</span><br><span class="line">		public void hardChoice(_360 arg)&#123;</span><br><span class="line">			System.out.println("son choose 360");</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Father father = new Father();</span><br><span class="line">		Father son = new Son();</span><br><span class="line">		father.hardChoice(new _360());</span><br><span class="line">		son.hardChoice(new QQ());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">father choose <span class="number">360</span> </span><br><span class="line">son choose qq</span><br></pre></td></tr></table></figure>
<p>看编译阶段编译器的选择过程，也就是静态分派的过程。这时选择目标方法的依据有两点：<strong>一是静态类型是Father还是Son，二是方法参数是QQ还是360。因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。</strong><br>再看运行阶段虚拟机的选择，也就是动态分派的过程。在执行“son.hardChoose(new QQ())”这句代码时（准确的说是在执行这句代码所对应的invokevirtual指令），由于编译期已经决定目标方法的签名必须为hardChoice(QQ)，虚拟机不会关心传递过来的参数”QQ”是什么，因为这时参数的静态类型、实际类型都对方的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有此方法的接收者的实际类型是Father还是Son。因为<strong>只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型</strong>。</p>
<p><strong>Java语言是一门静态多分派，动态单分派的语言</strong>。</p>
<h4 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h4><p>虚拟机在实际实现动态分派是基于性能考虑的。jvm在实现层面提供了一个叫做虚方法表的索引来代替元数据查找以提高性能，下面是书中的一张虚方法表结构图：<br> <img src="方法表结构.png" alt="执行引擎"></p>
<blockquote>
<p><strong>虚方法表中</strong>存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果重写了这个方法，子类方法表中的地址将会替换指向子类实现版本的入口地址。<br>Father是父类son是子类，并且子类重写了父类的连个方法，hardChoice(QQ),hardChoice(_360)，因此子类中的这两个方法指向了Son的类型数据，而这两个类都继承自Object且没重写它的任何方法，因此都指向了Object的类型数据。<br>方法表一般在类加载的链接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。</p>
</blockquote>
<hr>
<blockquote>
<p><strong><em>你敢不敢问自己到底要去哪里，<br>背负着恐惧寻找的终点，<br>非要是末路吗，<br>你能听到吗，<br>你还能听到吗，<br>你还有勇气直面你的恐惧吗？</em></strong></p>
</blockquote>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat-reward.png" alt="Foutlook WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay-reward.png" alt="Foutlook Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>
	
	<div>
	  
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
	  
	</div>
	
	


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JVM，类加载/" rel="tag"># JVM，类加载</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/04/虚拟机的类加载机制/" rel="next" title="【深入理解JVM】之五：虚拟机的类加载机制">
                <i class="fa fa-chevron-left"></i> 【深入理解JVM】之五：虚拟机的类加载机制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/15/Javac编译与JIT编译/" rel="prev" title="【深入理解JVM】之七：Javac编译与JIT编译">
                【深入理解JVM】之七：Javac编译与JIT编译 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <!--
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
   -->
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.jpg"
               alt="Foutlook" />
          <p class="site-author-name" itemprop="name">Foutlook</p>
          <p class="site-description motion-element" itemprop="description">生活如果很顺利,那该多无聊</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Foutlook" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/foutlook6" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/5431985539" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/fxkai-ai" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://my.csdn.net/kai_12" title="我的CSDN" target="_blank">我的CSDN</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行时栈帧结构"><span class="nav-number">2.</span> <span class="nav-text">运行时栈帧结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#局部变量变"><span class="nav-number">2.1.</span> <span class="nav-text">局部变量变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作数栈"><span class="nav-number">2.2.</span> <span class="nav-text">操作数栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于栈的解释器执行过程"><span class="nav-number">2.3.</span> <span class="nav-text">基于栈的解释器执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态链接"><span class="nav-number">2.4.</span> <span class="nav-text">动态链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法返回值地址"><span class="nav-number">2.5.</span> <span class="nav-text">方法返回值地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#附加信息"><span class="nav-number">2.6.</span> <span class="nav-text">附加信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法调用"><span class="nav-number">3.</span> <span class="nav-text">方法调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解析"><span class="nav-number">3.1.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分派"><span class="nav-number">3.2.</span> <span class="nav-text">分派</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#静态分派–代表重载"><span class="nav-number">3.2.1.</span> <span class="nav-text">静态分派–代表重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态分派–代表重写"><span class="nav-number">3.2.2.</span> <span class="nav-text">动态分派–代表重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单分派与多分派"><span class="nav-number">3.2.3.</span> <span class="nav-text">单分派与多分派</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟机动态分派的实现"><span class="nav-number">3.2.4.</span> <span class="nav-text">虚拟机动态分派的实现</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Foutlook</span>
</div>




<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<div class="powered-by">
  <span class="post-count">博客全站共98.0k字</span>
</div>

<!--
<div class="powered-by">
  由  强力驱动
</div>
-->


<div class="theme-info">
  主题 - 豫ICP备17009860号
</div>


        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'foutlook';
      var disqus_identifier = '2017/10/10/虚拟机字节码执行引擎/';

      var disqus_title = "【深入理解JVM】之六：虚拟机字节码执行引擎";


      function run_disqus_script(disqus_script) {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');

      
        var disqus_config = function () {
            this.page.url = disqus_url;
            this.page.identifier = disqus_identifier;
            this.page.title = disqus_title;
        };
        run_disqus_script('embed.js');
      

    </script>
  








  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
